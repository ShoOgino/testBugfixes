{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","commits":[{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + dimValues[dim][dimValue]);\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + dimValues[dim][dimValue2]);\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(drillDowns[dim]));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e70df4d80cde893a6897f8e6543c2d7666b73d7a","7f5270cef865567fdb969a7f4c43d0f53c28f527"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"052966821bd0c4ac232b8c11a7f33741a3b12462","date":1361902299,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + dimValues[dim][dimValue]);\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + dimValues[dim][dimValue2]);\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(drillDowns[dim]));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + dimValues[dim][dimValue]);\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + dimValues[dim][dimValue2]);\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(drillDowns[dim]));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"694538e5ec59774a19c025ae093580d6462c8b46","date":1362060117,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          // We cannot include this character else the label\n          // is silently truncated:\n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1) {\n            break;\n          }\n        }\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + dimValues[dim][dimValue]);\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + dimValues[dim][dimValue2]);\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(drillDowns[dim]));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n          if (canUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(cp));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n          if (canUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(cp));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (canUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      boolean useSortedSetDV = canUseDV && random().nextBoolean();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + useSortedSetDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (useSortedSetDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, useSortedSetDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, useSortedSetDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          // We cannot include this character else the label\n          // is silently truncated:\n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1) {\n            break;\n          }\n        }\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          paths.add(new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]));\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    for(int i=0;i<numDims;i++) {\n      requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n    }\n\n    FacetSearchParams fsp = new FacetSearchParams(requests);\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown);\n      }\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSidewaysResult actual = new DrillSideways(s, tr).search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      \n      verifyEquals(dimValues, s, expected, actual, scores);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":["e70df4d80cde893a6897f8e6543c2d7666b73d7a","d1f7dc2d5ba61f478d9439f5b6afe27c8809422a","7f5270cef865567fdb969a7f4c43d0f53c28f527"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2","date":1363472247,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n        if (canUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (canUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      boolean useSortedSetDV = canUseDV && random().nextBoolean();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + useSortedSetDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (useSortedSetDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, useSortedSetDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, useSortedSetDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n          if (canUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(cp));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n          if (canUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(cp));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (canUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      boolean useSortedSetDV = canUseDV && random().nextBoolean();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + useSortedSetDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (useSortedSetDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, useSortedSetDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, useSortedSetDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":["7f5270cef865567fdb969a7f4c43d0f53c28f527"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f5270cef865567fdb969a7f4c43d0f53c28f527","date":1363480008,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        facetFields.addFields(doc, paths);\n        if (canUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (canUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      boolean useSortedSetDV = canUseDV && random().nextBoolean();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + useSortedSetDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (useSortedSetDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, useSortedSetDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, useSortedSetDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798","7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2","5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"bugIntro":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e70df4d80cde893a6897f8e6543c2d7666b73d7a","date":1365615272,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      String[][] drillDowns = new String[numDims][];\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      requests = new ArrayList<FacetRequest>();\n      for(int i=0;i<numDims;i++) {\n        requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), topN));\n      }\n      fsp = new FacetSearchParams(requests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798","7f5270cef865567fdb969a7f4c43d0f53c28f527","5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a","date":1365621037,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Make sure topN works:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc","date":1366056945,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = new IndexSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2f479a58780f0a2a9c1c6f7202207a75d094cd9","date":1366841689,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db7658c9a28c362e50fc37b91f00b427ac9bf284","date":1371313295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee834e58357f79a6fc8770119cbf9d614da67c90","date":1371379780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938c2ea94a9fb325547d177cd35b5a26512bf837","date":1373914690,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(r);\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, null) {\n            @Override\n            protected FacetsAccumulator getDrillDownAccumulator(FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n\n            @Override\n            protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n              return new SortedSetDocValuesAccumulator(fsp, sortedSetDVState);\n            }\n          };\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84becf9f21f25fe1b9b54cf2a176015749af0283","date":1383417412,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    // TestRuleSetupAndRestoreClassEnv can sometimes\n    // randomly pick the non-general Facet42DocValuesFormat:\n    DocValuesFormat dvf = Codec.getDefault().docValuesFormat();\n    if (dvf instanceof PerFieldDocValuesFormat) {\n      dvf = ((PerFieldDocValuesFormat) dvf).getDocValuesFormatForField(\"$facets\");\n    }\n    if (dvf instanceof Facet42DocValuesFormat) {\n      canUseDV = false;\n    }\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<FacetLabel> paths = new ArrayList<FacetLabel>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          FacetLabel cp = new FacetLabel(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          FacetLabel cp = new FacetLabel(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new FacetLabel(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          FacetLabel[] paths = new FacetLabel[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new FacetLabel(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce7aff7772c162c15d520e31af46c555f60d5c3b","date":1385135519,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":null,"sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<FacetLabel> paths = new ArrayList<FacetLabel>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          FacetLabel cp = new FacetLabel(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          FacetLabel cp = new FacetLabel(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new FacetLabel(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          FacetLabel[] paths = new FacetLabel[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new FacetLabel(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways#testRandom().mjava","sourceNew":null,"sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    /*\n    aChance = .01;\n    bChance = 0.5;\n    cChance = 1.0;\n    */\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s;\n        while (true) {\n          s = _TestUtil.randomRealisticUnicodeString(random());\n          //s = _TestUtil.randomSimpleString(random());\n          // We cannot include this character else we hit\n          // IllegalArgExc: \n          if (s.indexOf(FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR) == -1 &&\n              (!canUseDV || s.indexOf('/') == -1)) {\n            break;\n          }\n        }\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    facetFields = new FacetFields(tw);\n    SortedSetDocValuesFacetFields dvFacetFields = new SortedSetDocValuesFacetFields();\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n      List<CategoryPath> paths = new ArrayList<CategoryPath>();\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          CategoryPath cp = new CategoryPath(\"dim\" + dim, dimValues[dim][dimValue2]);\n          paths.add(cp);\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n      if (!paths.isEmpty()) {\n        if (doUseDV) {\n          dvFacetFields.addFields(doc, paths);\n        } else {\n          facetFields.addFields(doc, paths);\n        }\n      }\n\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n    tw.close();\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      List<FacetRequest> requests = new ArrayList<FacetRequest>();\n      while(true) {\n        for(int i=0;i<numDims;i++) {\n          // LUCENE-4915: sometimes don't request facet\n          // counts on the dim(s) we drill down on\n          if (random().nextDouble() <= 0.9) {\n            if (VERBOSE) {\n              System.out.println(\"  do facet request on dim=\" + i);\n            }\n            requests.add(new CountFacetRequest(new CategoryPath(\"dim\" + i), dimValues[numDims-1].length));\n          } else {\n            if (VERBOSE) {\n              System.out.println(\"  skip facet request on dim=\" + i);\n            }\n          }\n        }\n        if (!requests.isEmpty()) {\n          break;\n        }\n      }\n      FacetSearchParams fsp = new FacetSearchParams(requests);\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            paths[upto++] = new CategoryPath(\"dim\" + dim, value);\n          }\n          ddq.add(paths);\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           }, fsp);\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector(), fsp);\n      }\n\n      SimpleFacetResult expected = slowDrillSidewaysSearch(s, requests, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(requests, dimValues, s, expected, actual, scores, -1, doUseDV);\n\n      // Retrieve topN facets:\n      int topN = _TestUtil.nextInt(random(), 1, 20);\n\n      List<FacetRequest> newRequests = new ArrayList<FacetRequest>();\n      for(FacetRequest oldRequest : requests) {\n        newRequests.add(new CountFacetRequest(oldRequest.categoryPath, topN));\n      }\n      fsp = new FacetSearchParams(newRequests);\n      actual = ds.search(ddq, filter, null, numDocs, sort, true, true, fsp);\n      if (VERBOSE) {\n        System.out.println(\"  verify topN=\" + topN);\n      }\n      verifyEquals(newRequests, dimValues, s, expected, actual, scores, topN, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    tr.close();\n    r.close();\n    td.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"84becf9f21f25fe1b9b54cf2a176015749af0283":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"694538e5ec59774a19c025ae093580d6462c8b46":["052966821bd0c4ac232b8c11a7f33741a3b12462"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"db7658c9a28c362e50fc37b91f00b427ac9bf284":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["ee834e58357f79a6fc8770119cbf9d614da67c90","938c2ea94a9fb325547d177cd35b5a26512bf837"],"ee834e58357f79a6fc8770119cbf9d614da67c90":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9","db7658c9a28c362e50fc37b91f00b427ac9bf284"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["694538e5ec59774a19c025ae093580d6462c8b46"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["84becf9f21f25fe1b9b54cf2a176015749af0283"],"938c2ea94a9fb325547d177cd35b5a26512bf837":["db7658c9a28c362e50fc37b91f00b427ac9bf284"],"052966821bd0c4ac232b8c11a7f33741a3b12462":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["7f5270cef865567fdb969a7f4c43d0f53c28f527"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["84becf9f21f25fe1b9b54cf2a176015749af0283","ce7aff7772c162c15d520e31af46c555f60d5c3b"],"7f5270cef865567fdb969a7f4c43d0f53c28f527":["7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["938c2ea94a9fb325547d177cd35b5a26512bf837"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"84becf9f21f25fe1b9b54cf2a176015749af0283":["c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"694538e5ec59774a19c025ae093580d6462c8b46":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["052966821bd0c4ac232b8c11a7f33741a3b12462"],"db7658c9a28c362e50fc37b91f00b427ac9bf284":["ee834e58357f79a6fc8770119cbf9d614da67c90","938c2ea94a9fb325547d177cd35b5a26512bf837"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"ee834e58357f79a6fc8770119cbf9d614da67c90":["37a0f60745e53927c4c876cfe5b5a58170f0646c"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["ce7aff7772c162c15d520e31af46c555f60d5c3b"],"938c2ea94a9fb325547d177cd35b5a26512bf837":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"052966821bd0c4ac232b8c11a7f33741a3b12462":["694538e5ec59774a19c025ae093580d6462c8b46"],"e70df4d80cde893a6897f8e6543c2d7666b73d7a":["d1f7dc2d5ba61f478d9439f5b6afe27c8809422a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"e2f479a58780f0a2a9c1c6f7202207a75d094cd9":["db7658c9a28c362e50fc37b91f00b427ac9bf284","ee834e58357f79a6fc8770119cbf9d614da67c90"],"d1f7dc2d5ba61f478d9439f5b6afe27c8809422a":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2":["7f5270cef865567fdb969a7f4c43d0f53c28f527"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f5270cef865567fdb969a7f4c43d0f53c28f527":["e70df4d80cde893a6897f8e6543c2d7666b73d7a"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["84becf9f21f25fe1b9b54cf2a176015749af0283"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["e2f479a58780f0a2a9c1c6f7202207a75d094cd9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}