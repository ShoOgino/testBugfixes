{"path":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","commits":[{"id":"0cd8367c3d48e4b63dee1895a261d4986c716bbb","date":1279637747,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"/dev/null","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        MultiFields.getFields(reader).terms(\"content\");\n        reader.document(0); // to catch also 2.9->3.0 stored field change\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        writer.optimize();\n        reader = writer.getReader();\n        reader.document(0); // to catch also 2.9->3.0 stored field change\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97","2784b760ab1d583d39c71930e097b94700431c81"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2784b760ab1d583d39c71930e097b94700431c81","date":1279640454,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        MultiFields.getFields(reader).terms(\"content\");\n        reader.document(0); // to catch also 2.9->3.0 stored field change\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        writer.optimize();\n        reader = writer.getReader();\n        reader.document(0); // to catch also 2.9->3.0 stored field change\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"/dev/null","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b21422ff1d1d56499dec481f193b402e5e8def5b","date":1281472367,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(rnd,\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(rnd,\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2100714e7e90fc106e6bbbbc39ede8bb8051ce97","date":1287828400,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a13a126d15299d5c1e117ea99ddae6fb0fa3f209","date":1291909583,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece","date":1291922179,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    final Random rnd = newRandom();\n    for(int i=0;i<unsupportedNames.length;i++) {\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (rnd.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) writer.close();\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","date":1295759448,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdad2c6b6234338031bcc1f24c001a5ad66f714","date":1296866109,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer())\n          .setMergeScheduler(new SerialMergeScheduler()) // no threads!\n        );\n        // TODO: Make IndexWriter fail on open!\n        if (random.nextBoolean()) {\n          writer.optimize();\n        } else {\n          reader = writer.getReader();\n        }\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n        if (writer != null) {\n          try {\n            writer.close();\n          } catch (IndexFormatTooOldException e) {\n            // OK -- since IW gives merge scheduler a chance\n            // to merge at close, it's possible and fine to\n            // hit this exc here\n            writer.close(false);\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), unsupportedNames[i]);\n\n      String fullPath = fullDir(unsupportedNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      rmDir(unsupportedNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2c5f0cb44df114db4228c8f77861714b5cabaea","date":1302542431,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer()));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1efe3edca215dd9891cb42af283fed96f792ca0","date":1320428891,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece"],"a13a126d15299d5c1e117ea99ddae6fb0fa3f209":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97"],"2100714e7e90fc106e6bbbbc39ede8bb8051ce97":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["f2c5f0cb44df114db4228c8f77861714b5cabaea"],"2784b760ab1d583d39c71930e097b94700431c81":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["1f653cfcf159baeaafe5d01682a911e95bba4012","2100714e7e90fc106e6bbbbc39ede8bb8051ce97"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["b12d3e81e0f95a4527b5703953c503f71120ffcc","bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2784b760ab1d583d39c71930e097b94700431c81"],"962d04139994fce5193143ef35615499a9a96d78":["bde51b089eb7f86171eb3406e38a274743f9b7ac","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["b21422ff1d1d56499dec481f193b402e5e8def5b"],"a3776dccca01c11e7046323cfad46a3b4a471233":["3cdad2c6b6234338031bcc1f24c001a5ad66f714","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece":["a13a126d15299d5c1e117ea99ddae6fb0fa3f209"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["2784b760ab1d583d39c71930e097b94700431c81"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["3cdad2c6b6234338031bcc1f24c001a5ad66f714","bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"a13a126d15299d5c1e117ea99ddae6fb0fa3f209":["bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece"],"2100714e7e90fc106e6bbbbc39ede8bb8051ce97":["a13a126d15299d5c1e117ea99ddae6fb0fa3f209","b12d3e81e0f95a4527b5703953c503f71120ffcc"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2784b760ab1d583d39c71930e097b94700431c81":["5f4e87790277826a2aea119328600dfb07761f32","b21422ff1d1d56499dec481f193b402e5e8def5b"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["f2c5f0cb44df114db4228c8f77861714b5cabaea","a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["2784b760ab1d583d39c71930e097b94700431c81"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"962d04139994fce5193143ef35615499a9a96d78":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["f1efe3edca215dd9891cb42af283fed96f792ca0","135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","a3776dccca01c11e7046323cfad46a3b4a471233"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97","b12d3e81e0f95a4527b5703953c503f71120ffcc"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","5f4e87790277826a2aea119328600dfb07761f32"],"bd5f1c7e032b68c9fb4c7454926dbff57cbb6ece":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["962d04139994fce5193143ef35615499a9a96d78"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","962d04139994fce5193143ef35615499a9a96d78","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}