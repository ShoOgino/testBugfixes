{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","commits":[{"id":"226abb667f503323e0d9473af1883fa03ef3a3fd","date":1163596173,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"/dev/null","sourceNew":"    public String showRunData(String prefix)\r\n    {\r\n        if (runData.size() == 0)\r\n        {\r\n            return \"# [NO RUN DATA]\";\r\n        }\r\n        HashMap resByTask = new HashMap(); \r\n        StringBuffer sb = new StringBuffer();\r\n        String lineSep = System.getProperty(\"line.separator\");\r\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\r\n        for (int i = 0; i < COLS.length; i++) {\r\n          sb.append(COLS[i]);\r\n        }\r\n        sb.append(\"\\n\");\r\n        LinkedHashMap mapMem = new LinkedHashMap();\r\n        LinkedHashMap mapSpeed = new LinkedHashMap();\r\n        for (int i = 0; i < runData.size(); i++)\r\n        {\r\n            TestRunData trd = (TestRunData) runData.get(i);\r\n            Collection labels = trd.getLabels();\r\n            Iterator it = labels.iterator();\r\n            while (it.hasNext())\r\n            {\r\n                String label = (String) it.next();\r\n                MemUsage mem = trd.getMemUsage(label);\r\n                if (mem != null)\r\n                {\r\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\r\n                    if (tm == null)\r\n                    {\r\n                        tm = new TestData.LCounter[2];\r\n                        tm[0] = new TestData.LCounter();\r\n                        tm[1] = new TestData.LCounter();\r\n                        mapMem.put(label, tm);\r\n                    }\r\n                    tm[0].total += mem.avgFree;\r\n                    tm[0].count++;\r\n                    tm[1].total += mem.avgTotal;\r\n                    tm[1].count++;\r\n                }\r\n                TimeData td = trd.getTotals(label);\r\n                if (td != null)\r\n                {\r\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\r\n                    if (dc == null)\r\n                    {\r\n                        dc = new TestData.DCounter();\r\n                        mapSpeed.put(label, dc);\r\n                    }\r\n                    dc.count++;\r\n                    //dc.total += td.getRate();\r\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume atleast 1ms for any countable op\r\n                    dc.recordCount += td.count;\r\n                }\r\n            }\r\n        }\r\n        LinkedHashMap res = new LinkedHashMap();\r\n        Iterator it = mapSpeed.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\r\n            res.put(label, \r\n                format(dc.count, RUNCNT) + \r\n                format(dc.recordCount / dc.count, RECCNT) +\r\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\r\n                //format((float) (dc.total / (double) dc.count), RECSEC)\r\n                );\r\n            \r\n            // also sum by task\r\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            if (ldc==null) {\r\n              ldc = new LDCounter();\r\n              resByTask.put(task,ldc);\r\n            }\r\n            ldc.Dcount += dc.count;\r\n            ldc.DrecordCount += dc.recordCount;\r\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume atleast 1ms for any countable op \r\n        }\r\n        it = mapMem.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\r\n            String speed = (String) res.get(label);\r\n            boolean makeSpeed = false;\r\n            if (speed == null)\r\n            {\r\n                makeSpeed = true;\r\n                speed =  \r\n                  format(lc[0].count, RUNCNT) + \r\n                  format(0, RECCNT) + \r\n                  format(0,(float)0.0, RECSEC);\r\n            }\r\n            res.put(label, speed + \r\n                format(0, lc[0].total / lc[0].count, FREEMEM) + \r\n                format(0, lc[1].total / lc[1].count, TOTMEM));\r\n            \r\n            // also sum by task\r\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            if (ldc==null) {\r\n              ldc = new LDCounter();\r\n              resByTask.put(task,ldc);\r\n              makeSpeed = true;\r\n            }\r\n            if (makeSpeed) {\r\n              ldc.Dcount += lc[0].count;\r\n            }\r\n            ldc.Lcount0 += lc[0].count;\r\n            ldc.Lcount1 += lc[1].count;\r\n            ldc.Ltotal0 += lc[0].total;\r\n            ldc.Ltotal1 += lc[1].total;\r\n        }\r\n        it = res.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            sb.append(format(prefix, ID));\r\n            sb.append(format(label, OP));\r\n            sb.append(res.get(label)).append(\"\\n\");\r\n        }\r\n        // show results by task (srch, optimize, etc.) \r\n        sb.append(\"\\n\");\r\n        for (int i = 0; i < COLS.length; i++) {\r\n          sb.append(COLS[i]);\r\n        }\r\n        sb.append(\"\\n\");\r\n        it = resByTask.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String task = (String) it.next();\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            sb.append(format(\"    \", ID));\r\n            sb.append(format(task, OP));\r\n            sb.append(format(ldc.Dcount, RUNCNT)); \r\n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\r\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\r\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \r\n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\r\n            sb.append(\"\\n\");\r\n        }\r\n        return sb.toString();\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738fa43eaa87dc7b393fe98b04cde1019e20bac","date":1175557034,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap resByTask = new HashMap(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap mapMem = new LinkedHashMap();\n        LinkedHashMap mapSpeed = new LinkedHashMap();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = (TestRunData) runData.get(i);\n            Collection labels = trd.getLabels();\n            Iterator it = labels.iterator();\n            while (it.hasNext())\n            {\n                String label = (String) it.next();\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume atleast 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap res = new LinkedHashMap();\n        Iterator it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume atleast 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\n            String speed = (String) res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = (String) it.next();\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\r\n    {\r\n        if (runData.size() == 0)\r\n        {\r\n            return \"# [NO RUN DATA]\";\r\n        }\r\n        HashMap resByTask = new HashMap(); \r\n        StringBuffer sb = new StringBuffer();\r\n        String lineSep = System.getProperty(\"line.separator\");\r\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\r\n        for (int i = 0; i < COLS.length; i++) {\r\n          sb.append(COLS[i]);\r\n        }\r\n        sb.append(\"\\n\");\r\n        LinkedHashMap mapMem = new LinkedHashMap();\r\n        LinkedHashMap mapSpeed = new LinkedHashMap();\r\n        for (int i = 0; i < runData.size(); i++)\r\n        {\r\n            TestRunData trd = (TestRunData) runData.get(i);\r\n            Collection labels = trd.getLabels();\r\n            Iterator it = labels.iterator();\r\n            while (it.hasNext())\r\n            {\r\n                String label = (String) it.next();\r\n                MemUsage mem = trd.getMemUsage(label);\r\n                if (mem != null)\r\n                {\r\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\r\n                    if (tm == null)\r\n                    {\r\n                        tm = new TestData.LCounter[2];\r\n                        tm[0] = new TestData.LCounter();\r\n                        tm[1] = new TestData.LCounter();\r\n                        mapMem.put(label, tm);\r\n                    }\r\n                    tm[0].total += mem.avgFree;\r\n                    tm[0].count++;\r\n                    tm[1].total += mem.avgTotal;\r\n                    tm[1].count++;\r\n                }\r\n                TimeData td = trd.getTotals(label);\r\n                if (td != null)\r\n                {\r\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\r\n                    if (dc == null)\r\n                    {\r\n                        dc = new TestData.DCounter();\r\n                        mapSpeed.put(label, dc);\r\n                    }\r\n                    dc.count++;\r\n                    //dc.total += td.getRate();\r\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume atleast 1ms for any countable op\r\n                    dc.recordCount += td.count;\r\n                }\r\n            }\r\n        }\r\n        LinkedHashMap res = new LinkedHashMap();\r\n        Iterator it = mapSpeed.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\r\n            res.put(label, \r\n                format(dc.count, RUNCNT) + \r\n                format(dc.recordCount / dc.count, RECCNT) +\r\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\r\n                //format((float) (dc.total / (double) dc.count), RECSEC)\r\n                );\r\n            \r\n            // also sum by task\r\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            if (ldc==null) {\r\n              ldc = new LDCounter();\r\n              resByTask.put(task,ldc);\r\n            }\r\n            ldc.Dcount += dc.count;\r\n            ldc.DrecordCount += dc.recordCount;\r\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume atleast 1ms for any countable op \r\n        }\r\n        it = mapMem.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\r\n            String speed = (String) res.get(label);\r\n            boolean makeSpeed = false;\r\n            if (speed == null)\r\n            {\r\n                makeSpeed = true;\r\n                speed =  \r\n                  format(lc[0].count, RUNCNT) + \r\n                  format(0, RECCNT) + \r\n                  format(0,(float)0.0, RECSEC);\r\n            }\r\n            res.put(label, speed + \r\n                format(0, lc[0].total / lc[0].count, FREEMEM) + \r\n                format(0, lc[1].total / lc[1].count, TOTMEM));\r\n            \r\n            // also sum by task\r\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            if (ldc==null) {\r\n              ldc = new LDCounter();\r\n              resByTask.put(task,ldc);\r\n              makeSpeed = true;\r\n            }\r\n            if (makeSpeed) {\r\n              ldc.Dcount += lc[0].count;\r\n            }\r\n            ldc.Lcount0 += lc[0].count;\r\n            ldc.Lcount1 += lc[1].count;\r\n            ldc.Ltotal0 += lc[0].total;\r\n            ldc.Ltotal1 += lc[1].total;\r\n        }\r\n        it = res.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String label = (String) it.next();\r\n            sb.append(format(prefix, ID));\r\n            sb.append(format(label, OP));\r\n            sb.append(res.get(label)).append(\"\\n\");\r\n        }\r\n        // show results by task (srch, optimize, etc.) \r\n        sb.append(\"\\n\");\r\n        for (int i = 0; i < COLS.length; i++) {\r\n          sb.append(COLS[i]);\r\n        }\r\n        sb.append(\"\\n\");\r\n        it = resByTask.keySet().iterator();\r\n        while (it.hasNext())\r\n        {\r\n            String task = (String) it.next();\r\n            LDCounter ldc = (LDCounter) resByTask.get(task);\r\n            sb.append(format(\"    \", ID));\r\n            sb.append(format(task, OP));\r\n            sb.append(format(ldc.Dcount, RUNCNT)); \r\n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\r\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\r\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \r\n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\r\n            sb.append(\"\\n\");\r\n        }\r\n        return sb.toString();\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap resByTask = new HashMap(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap mapMem = new LinkedHashMap();\n        LinkedHashMap mapSpeed = new LinkedHashMap();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = (TestRunData) runData.get(i);\n            Collection labels = trd.getLabels();\n            Iterator it = labels.iterator();\n            while (it.hasNext())\n            {\n                String label = (String) it.next();\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap res = new LinkedHashMap();\n        Iterator it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\n            String speed = (String) res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = (String) it.next();\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap resByTask = new HashMap(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap mapMem = new LinkedHashMap();\n        LinkedHashMap mapSpeed = new LinkedHashMap();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = (TestRunData) runData.get(i);\n            Collection labels = trd.getLabels();\n            Iterator it = labels.iterator();\n            while (it.hasNext())\n            {\n                String label = (String) it.next();\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume atleast 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap res = new LinkedHashMap();\n        Iterator it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume atleast 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\n            String speed = (String) res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = (String) it.next();\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e1ce9be74263e9659aad8a6ee1f213193710b71","date":1256298843,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap resByTask = new HashMap(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap mapMem = new LinkedHashMap();\n        LinkedHashMap mapSpeed = new LinkedHashMap();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = (TestRunData) runData.get(i);\n            Collection labels = trd.getLabels();\n            Iterator it = labels.iterator();\n            while (it.hasNext())\n            {\n                String label = (String) it.next();\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap res = new LinkedHashMap();\n        Iterator it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);\n            String speed = (String) res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = (String) it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = (String) it.next();\n            LDCounter ldc = (LDCounter) resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData#showRunData(String).mjava","sourceNew":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","sourceOld":"    public String showRunData(String prefix)\n    {\n        if (runData.size() == 0)\n        {\n            return \"# [NO RUN DATA]\";\n        }\n        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); \n        StringBuffer sb = new StringBuffer();\n        String lineSep = System.getProperty(\"line.separator\");\n        sb.append(\"warm = Warm Index Reader\").append(lineSep).append(\"srch = Search Index\").append(lineSep).append(\"trav = Traverse Hits list, optionally retrieving document\").append(lineSep).append(lineSep);\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();\n        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();\n        for (int i = 0; i < runData.size(); i++)\n        {\n            TestRunData trd = runData.get(i);\n            for (final String label : trd.getLabels()) \n            {\n                MemUsage mem = trd.getMemUsage(label);\n                if (mem != null)\n                {\n                    TestData.LCounter[] tm = mapMem.get(label);\n                    if (tm == null)\n                    {\n                        tm = new TestData.LCounter[2];\n                        tm[0] = new TestData.LCounter();\n                        tm[1] = new TestData.LCounter();\n                        mapMem.put(label, tm);\n                    }\n                    tm[0].total += mem.avgFree;\n                    tm[0].count++;\n                    tm[1].total += mem.avgTotal;\n                    tm[1].count++;\n                }\n                TimeData td = trd.getTotals(label);\n                if (td != null)\n                {\n                    TestData.DCounter dc = mapSpeed.get(label);\n                    if (dc == null)\n                    {\n                        dc = new TestData.DCounter();\n                        mapSpeed.put(label, dc);\n                    }\n                    dc.count++;\n                    //dc.total += td.getRate();\n                    dc.total += (td.count>0 && td.elapsed<=0 ? 1 : td.elapsed); // assume at least 1ms for any countable op\n                    dc.recordCount += td.count;\n                }\n            }\n        }\n        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();\n        Iterator<String> it = mapSpeed.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.DCounter dc = mapSpeed.get(label);\n            res.put(label, \n                format(dc.count, RUNCNT) + \n                format(dc.recordCount / dc.count, RECCNT) +\n                format(1,(float) (dc.recordCount * 1000.0 / (dc.total>0 ? dc.total : 1.0)), RECSEC)\n                //format((float) (dc.total / (double) dc.count), RECSEC)\n                );\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n            }\n            ldc.Dcount += dc.count;\n            ldc.DrecordCount += dc.recordCount;\n            ldc.Dtotal += (dc.count>0 && dc.total<=0 ? 1 : dc.total); // assume at least 1ms for any countable op \n        }\n        it = mapMem.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            TestData.LCounter[] lc =  mapMem.get(label);\n            String speed = res.get(label);\n            boolean makeSpeed = false;\n            if (speed == null)\n            {\n                makeSpeed = true;\n                speed =  \n                  format(lc[0].count, RUNCNT) + \n                  format(0, RECCNT) + \n                  format(0,(float)0.0, RECSEC);\n            }\n            res.put(label, speed + \n                format(0, lc[0].total / lc[0].count, FREEMEM) + \n                format(0, lc[1].total / lc[1].count, TOTMEM));\n            \n            // also sum by task\n            String task = label.substring(label.lastIndexOf(\"-\")+1);\n            LDCounter ldc = resByTask.get(task);\n            if (ldc==null) {\n              ldc = new LDCounter();\n              resByTask.put(task,ldc);\n              makeSpeed = true;\n            }\n            if (makeSpeed) {\n              ldc.Dcount += lc[0].count;\n            }\n            ldc.Lcount0 += lc[0].count;\n            ldc.Lcount1 += lc[1].count;\n            ldc.Ltotal0 += lc[0].total;\n            ldc.Ltotal1 += lc[1].total;\n        }\n        it = res.keySet().iterator();\n        while (it.hasNext())\n        {\n            String label = it.next();\n            sb.append(format(prefix, ID));\n            sb.append(format(label, OP));\n            sb.append(res.get(label)).append(\"\\n\");\n        }\n        // show results by task (srch, optimize, etc.) \n        sb.append(\"\\n\");\n        for (int i = 0; i < COLS.length; i++) {\n          sb.append(COLS[i]);\n        }\n        sb.append(\"\\n\");\n        it = resByTask.keySet().iterator();\n        while (it.hasNext())\n        {\n            String task = it.next();\n            LDCounter ldc = resByTask.get(task);\n            sb.append(format(\"    \", ID));\n            sb.append(format(task, OP));\n            sb.append(format(ldc.Dcount, RUNCNT)); \n            sb.append(format(ldc.DrecordCount / ldc.Dcount, RECCNT));\n            sb.append(format(1,(float) (ldc.DrecordCount * 1000.0 / (ldc.Dtotal>0 ? ldc.Dtotal : 1.0)), RECSEC));\n            sb.append(format(0, ldc.Ltotal0 / ldc.Lcount0, FREEMEM)); \n            sb.append(format(0, ldc.Ltotal1 / ldc.Lcount1, TOTMEM));\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"226abb667f503323e0d9473af1883fa03ef3a3fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["226abb667f503323e0d9473af1883fa03ef3a3fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4e1ce9be74263e9659aad8a6ee1f213193710b71"]},"commit2Childs":{"226abb667f503323e0d9473af1883fa03ef3a3fd":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"4e1ce9be74263e9659aad8a6ee1f213193710b71":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["226abb667f503323e0d9473af1883fa03ef3a3fd"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["4e1ce9be74263e9659aad8a6ee1f213193710b71"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}