{"path":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1bb50752d43a65ef1b623eabdb8e865983d3cd6","date":1304257984,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = q.weight(s);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = q.weight(indexSearcher);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc1f3f78b299e125f7e60f43b5d457392bea23f","date":1317431015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                scorer = w.scorer(readerContextArray[leafPtr], ScorerContext.def());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)previousReader.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final IndexReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader.getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final IndexReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n              indexSearcher.close();\n            }\n            lastReader[0] = context.reader;\n            assert readerContextArray[leafPtr].reader == context.reader;\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = (AtomicReaderContext)previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a3776dccca01c11e7046323cfad46a3b4a471233","6f7fee42303a18cc146043c96f66491311b345d9"],"7b91922b55d15444d554721b352861d028eb8278":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"6f7fee42303a18cc146043c96f66491311b345d9":["c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6f7fee42303a18cc146043c96f66491311b345d9"],"a3776dccca01c11e7046323cfad46a3b4a471233":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","c1bb50752d43a65ef1b623eabdb8e865983d3cd6"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"6f7fee42303a18cc146043c96f66491311b345d9":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["7b91922b55d15444d554721b352861d028eb8278"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["6f7fee42303a18cc146043c96f66491311b345d9","a3776dccca01c11e7046323cfad46a3b4a471233","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","c1bb50752d43a65ef1b623eabdb8e865983d3cd6","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","135621f3a0670a9394eb563224a3b76cc4dddc0f","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}