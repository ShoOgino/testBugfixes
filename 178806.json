{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final InvertedFields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final InvertedFields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, 0);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, 0);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, 0);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, false);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0e3c1c21aac8ecf75706605133012833585c7","date":1347535263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, 0);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Fields fields = reader.fields();\n      if (fields == null) continue;\n\n      final Bits liveDocs = reader.getLiveDocs();\n      \n      final DocsEnum docs = reader.termDocsEnum(liveDocs, field, idBytes, 0);\n\n      if (docs == null) continue;\n      int id = docs.nextDoc();\n      if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n      assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n      return (((long)i) << 32) | id;\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, 0);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, 0);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes, true)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final AtomicReaderContext leaf = leafContexts.get(i);\n      final AtomicReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        DocsEnum docs = te.docs(reader.getLiveDocs(), null, DocsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.FLAG_NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator(null);\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(null, PostingsEnum.NONE);\n        docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(reader.getLiveDocs(), null, PostingsEnum.NONE);\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /**\n   * lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the\n   * index of the leaf reader in the high 32 bits. -1 is returned if not found.\n   * \n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i = 0, c = leafContexts.size(); i < c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n\n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(null, PostingsEnum.NONE);\n        docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long) i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","sourceOld":"  /** lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the index of the leaf reader in the high 32 bits.\n   * -1 is returned if not found.\n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i=0, c=leafContexts.size(); i<c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n      \n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(null, PostingsEnum.NONE);\n        docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long)i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf29cc8a76949bbcbc15b386a9e46a533f5b3332","date":1527778512,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#lookupId(BytesRef).mjava","sourceNew":"  /**\n   * lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the\n   * index of the leaf reader in the high 32 bits. -1 is returned if not found.\n   * \n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    return lookupId(schema.getUniqueKeyField().getName(), idBytes);\n  }\n\n","sourceOld":"  /**\n   * lookup the docid by the unique key field, and return the id *within* the leaf reader in the low 32 bits, and the\n   * index of the leaf reader in the high 32 bits. -1 is returned if not found.\n   * \n   * @lucene.internal\n   */\n  public long lookupId(BytesRef idBytes) throws IOException {\n    String field = schema.getUniqueKeyField().getName();\n\n    for (int i = 0, c = leafContexts.size(); i < c; i++) {\n      final LeafReaderContext leaf = leafContexts.get(i);\n      final LeafReader reader = leaf.reader();\n\n      final Terms terms = reader.terms(field);\n      if (terms == null) continue;\n\n      TermsEnum te = terms.iterator();\n      if (te.seekExact(idBytes)) {\n        PostingsEnum docs = te.postings(null, PostingsEnum.NONE);\n        docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n        int id = docs.nextDoc();\n        if (id == DocIdSetIterator.NO_MORE_DOCS) continue;\n        assert docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;\n\n        return (((long) i) << 32) | id;\n      }\n    }\n\n    return -1;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b6a0e3c1c21aac8ecf75706605133012833585c7","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["0d22ac6a4146774c1bc8400160fc0b6150294e92"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bf29cc8a76949bbcbc15b386a9e46a533f5b3332":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"51f5280f31484820499077f41fcdfe92d527d9dc":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","96d207426bd26fa5c1014e26d21d87603aea68b7"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["b6a0e3c1c21aac8ecf75706605133012833585c7"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","02331260bb246364779cb6f04919ca47900d01bb"],"b6a0e3c1c21aac8ecf75706605133012833585c7":["02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","02331260bb246364779cb6f04919ca47900d01bb"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bf29cc8a76949bbcbc15b386a9e46a533f5b3332"],"02331260bb246364779cb6f04919ca47900d01bb":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["51f5280f31484820499077f41fcdfe92d527d9dc"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["96d207426bd26fa5c1014e26d21d87603aea68b7"],"bf29cc8a76949bbcbc15b386a9e46a533f5b3332":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["bf29cc8a76949bbcbc15b386a9e46a533f5b3332"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"b6a0e3c1c21aac8ecf75706605133012833585c7":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","5cab9a86bd67202d20b6adc463008c8e982b070a"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["c9fb5f46e264daf5ba3860defe623a89d202dd87","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"02331260bb246364779cb6f04919ca47900d01bb":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","b6a0e3c1c21aac8ecf75706605133012833585c7","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}