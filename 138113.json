{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","commits":[{"id":"5e38f40562eb7c165ae08ab2367a031883138354","date":1340287338,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"/dev/null","sourceNew":"  private final void updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["18e20fa02735869173a20f36b8bfb855be5e5a13"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"/dev/null","sourceNew":"  private final void updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18e20fa02735869173a20f36b8bfb855be5e5a13","date":1353071141,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private final boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private final void updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n  }\n\n","bugFix":["5e38f40562eb7c165ae08ab2367a031883138354"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private final boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private final void updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb","date":1400265925,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private final boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private final boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = ((activeBytes + flushBytes) > limit)  &&\n                          (activeBytes < limit) &&\n                          !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be382406ee6e8449e49c082b50c31367e7add702","date":1469488703,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n\n    if (infoStream.isEnabled(\"DWFC\")) {\n      if (stall != stallControl.anyStalledThreads()) {\n        if (stall) {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n          stallStartNS = System.nanoTime();\n        } else {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n        }\n      }\n    }\n\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n\n    if (infoStream.isEnabled(\"DWFC\")) {\n      if (stall != stallControl.anyStalledThreads()) {\n        if (stall) {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n          stallStartNS = System.nanoTime();\n        } else {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n        }\n      }\n    }\n\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n\n    if (infoStream.isEnabled(\"DWFC\")) {\n      if (stall != stallControl.anyStalledThreads()) {\n        if (stall) {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n          stallStartNS = System.nanoTime();\n        } else {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n        }\n      }\n    }\n\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"130574de275b668a12d70a2c1d9cfc72fbfb76f6","date":1535620307,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#updateStallState().mjava","sourceNew":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n\n    if (infoStream.isEnabled(\"DWFC\")) {\n      if (stall != stallControl.anyStalledThreads()) {\n        if (stall) {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 netBytes()/1024./1024., getFlushingBytes()/1024./1024., fullFlush));\n          stallStartNS = System.nanoTime();\n        } else {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., getFlushingBytes()/1024./1024., fullFlush));\n        }\n      }\n    }\n\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","sourceOld":"  private boolean updateStallState() {\n    \n    assert Thread.holdsLock(this);\n    final long limit = stallLimitBytes();\n    /*\n     * we block indexing threads if net byte grows due to slow flushes\n     * yet, for small ram buffers and large documents we can easily\n     * reach the limit without any ongoing flushes. we need to ensure\n     * that we don't stall/block if an ongoing or pending flush can\n     * not free up enough memory to release the stall lock.\n     */\n    final boolean stall = (activeBytes + flushBytes) > limit &&\n      activeBytes < limit &&\n      !closed;\n\n    if (infoStream.isEnabled(\"DWFC\")) {\n      if (stall != stallControl.anyStalledThreads()) {\n        if (stall) {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"now stalling flushes: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n          stallStartNS = System.nanoTime();\n        } else {\n          infoStream.message(\"DW\", String.format(Locale.ROOT, \"done stalling flushes for %.1f msec: netBytes: %.1f MB flushBytes: %.1f MB fullFlush: %b\",\n                                                 (System.nanoTime()-stallStartNS)/1000000., netBytes()/1024./1024., flushBytes()/1024./1024., fullFlush));\n        }\n      }\n    }\n\n    stallControl.updateStalled(stall);\n    return stall;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5e38f40562eb7c165ae08ab2367a031883138354":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"130574de275b668a12d70a2c1d9cfc72fbfb76f6":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"407687e67faf6e1f02a211ca078d8e3eed631027":["5e38f40562eb7c165ae08ab2367a031883138354","18e20fa02735869173a20f36b8bfb855be5e5a13"],"56572ec06f1407c066d6b7399413178b33176cd8":["18e20fa02735869173a20f36b8bfb855be5e5a13","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["18e20fa02735869173a20f36b8bfb855be5e5a13"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c02b804ab16489b95429791a2d8fb0e0728354d4","d08973aa47f2cf98a588293a53af4e948952ccfb"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"18e20fa02735869173a20f36b8bfb855be5e5a13":["5e38f40562eb7c165ae08ab2367a031883138354"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e38f40562eb7c165ae08ab2367a031883138354"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be382406ee6e8449e49c082b50c31367e7add702":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["c02b804ab16489b95429791a2d8fb0e0728354d4","be382406ee6e8449e49c082b50c31367e7add702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["130574de275b668a12d70a2c1d9cfc72fbfb76f6"]},"commit2Childs":{"5e38f40562eb7c165ae08ab2367a031883138354":["407687e67faf6e1f02a211ca078d8e3eed631027","18e20fa02735869173a20f36b8bfb855be5e5a13","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"130574de275b668a12d70a2c1d9cfc72fbfb76f6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb":["56572ec06f1407c066d6b7399413178b33176cd8","c02b804ab16489b95429791a2d8fb0e0728354d4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c02b804ab16489b95429791a2d8fb0e0728354d4":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","be382406ee6e8449e49c082b50c31367e7add702","d08973aa47f2cf98a588293a53af4e948952ccfb"],"18e20fa02735869173a20f36b8bfb855be5e5a13":["407687e67faf6e1f02a211ca078d8e3eed631027","56572ec06f1407c066d6b7399413178b33176cd8","5b7d69c53c444cbbdbc1cd27e9f51f83b3ed14cb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5e38f40562eb7c165ae08ab2367a031883138354","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"be382406ee6e8449e49c082b50c31367e7add702":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["130574de275b668a12d70a2c1d9cfc72fbfb76f6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","56572ec06f1407c066d6b7399413178b33176cd8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}