{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","commits":[{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35ccdc47096dd6985b18e9ae3b8b73163af6c254","date":1510978942,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n\n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = getClusterStateProvider().getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            getClusterStateProvider().getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n\n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBSolrClient.Req req = new LBSolrClient.Req(request, theUrlList);\n    LBSolrClient.Rsp rsp = getLbClient().request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(Utils.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        if (col == null) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"Collection not found: \" + collectionName);\n        }\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"35ccdc47096dd6985b18e9ae3b8b73163af6c254":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["35ccdc47096dd6985b18e9ae3b8b73163af6c254"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"]},"commit2Childs":{"35ccdc47096dd6985b18e9ae3b8b73163af6c254":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["35ccdc47096dd6985b18e9ae3b8b73163af6c254"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}