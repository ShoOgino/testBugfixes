{"path":"lucene/facet/src/java/org/apache/lucene/facet/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","commits":[{"id":"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30","date":1387399235,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"/dev/null","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/range/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/LongRangeCounter#LongRangeCounter(LongRange[]).mjava","sourceNew":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","sourceOld":"  public LongRangeCounter(LongRange[] ranges) {\n    // Maps all range inclusive endpoints to int flags; 1\n    // = start of interval, 2 = end of interval.  We need to\n    // track the start vs end case separately because if a\n    // given point is both, then it must be its own\n    // elementary interval:\n    Map<Long,Integer> endsMap = new HashMap<Long,Integer>();\n\n    endsMap.put(Long.MIN_VALUE, 1);\n    endsMap.put(Long.MAX_VALUE, 2);\n\n    for(LongRange range : ranges) {\n      Integer cur = endsMap.get(range.minIncl);\n      if (cur == null) {\n        endsMap.put(range.minIncl, 1);\n      } else {\n        endsMap.put(range.minIncl, cur.intValue() | 1);\n      }\n      cur = endsMap.get(range.maxIncl);\n      if (cur == null) {\n        endsMap.put(range.maxIncl, 2);\n      } else {\n        endsMap.put(range.maxIncl, cur.intValue() | 2);\n      }\n    }\n\n    List<Long> endsList = new ArrayList<Long>(endsMap.keySet());\n    Collections.sort(endsList);\n\n    // Build elementaryIntervals (a 1D Venn diagram):\n    List<InclusiveRange> elementaryIntervals = new ArrayList<InclusiveRange>();\n    int upto0 = 1;\n    long v = endsList.get(0);\n    long prev;\n    if (endsMap.get(v) == 3) {\n      elementaryIntervals.add(new InclusiveRange(v, v));\n      prev = v+1;\n    } else {\n      prev = v;\n    }\n\n    while (upto0 < endsList.size()) {\n      v = endsList.get(upto0);\n      int flags = endsMap.get(v);\n      //System.out.println(\"  v=\" + v + \" flags=\" + flags);\n      if (flags == 3) {\n        // This point is both an end and a start; we need to\n        // separate it:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        elementaryIntervals.add(new InclusiveRange(v, v));\n        prev = v+1;\n      } else if (flags == 1) {\n        // This point is only the start of an interval;\n        // attach it to next interval:\n        if (v > prev) {\n          elementaryIntervals.add(new InclusiveRange(prev, v-1));\n        }\n        prev = v;\n      } else {\n        assert flags == 2;\n        // This point is only the end of an interval; attach\n        // it to last interval:\n        elementaryIntervals.add(new InclusiveRange(prev, v));\n        prev = v+1;\n      }\n      //System.out.println(\"    ints=\" + elementaryIntervals);\n      upto0++;\n    }\n\n    // Build binary tree on top of intervals:\n    root = split(0, elementaryIntervals.size(), elementaryIntervals);\n\n    // Set outputs, so we know which range to output for\n    // each node in the tree:\n    for(int i=0;i<ranges.length;i++) {\n      root.addOutputs(i, ranges[i]);\n    }\n\n    // Set boundaries (ends of each elementary interval):\n    boundaries = new long[elementaryIntervals.size()];\n    for(int i=0;i<boundaries.length;i++) {\n      boundaries[i] = elementaryIntervals.get(i).end;\n    }\n\n    leafCounts = new int[boundaries.length];\n\n    //System.out.println(\"ranges: \" + Arrays.toString(ranges));\n    //System.out.println(\"intervals: \" + elementaryIntervals);\n    //System.out.println(\"boundaries: \" + Arrays.toString(boundaries));\n    //System.out.println(\"root:\\n\" + root);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30"],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4edc984f0f4ac77c37e48ace2932f780f888453c":[],"6119ef33e3fbd8582640c23b3f5b3fbb22ba8d30":["4edc984f0f4ac77c37e48ace2932f780f888453c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4edc984f0f4ac77c37e48ace2932f780f888453c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}