{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, cloudConfig, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, cloudConfig, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(cloudConfig, collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    if (ocmh.zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      ocmh.zkStateReader.aliasesManager.update();\n    }\n    final Aliases aliases = ocmh.zkStateReader.getAliases();\n    final String collectionName = message.getStr(NAME);\n    final boolean waitForFinalState = message.getBool(WAIT_FOR_FINAL_STATE, false);\n    final String alias = message.getStr(ALIAS, collectionName);\n    log.info(\"Create collection {}\", collectionName);\n    if (clusterState.hasCollection(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection already exists: \" + collectionName);\n    }\n    if (aliases.hasAlias(collectionName)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"collection alias already exists: \" + collectionName);\n    }\n\n    String withCollection = message.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String withCollectionShard = null;\n    if (withCollection != null) {\n      String realWithCollection = aliases.resolveSimpleAlias(withCollection);\n      if (!clusterState.hasCollection(realWithCollection)) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + realWithCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(realWithCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        withCollectionShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n\n    String configName = getConfigName(collectionName, message);\n    if (configName == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No config set found to associate with the collection.\");\n    }\n\n    ocmh.validateConfigOrThrowSolrException(configName);\n\n    String router = message.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = populateShardNames(message, router);\n    checkReplicaTypes(message);\n\n\n\n    try {\n\n      final String async = message.getStr(ASYNC);\n\n      ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n      OverseerCollectionMessageHandler.createConfNode(stateManager, configName, collectionName);\n\n      Map<String,String> collectionParams = new HashMap<>();\n      Map<String,Object> collectionProps = message.getProperties();\n      for (Map.Entry<String, Object> entry : collectionProps.entrySet()) {\n        String propName = entry.getKey();\n        if (propName.startsWith(ZkController.COLLECTION_PARAM_PREFIX)) {\n          collectionParams.put(propName.substring(ZkController.COLLECTION_PARAM_PREFIX.length()), (String) entry.getValue());\n        }\n      }\n\n      createCollectionZkNode(stateManager, collectionName, collectionParams);\n      \n      ocmh.overseer.offerStateUpdate(Utils.toJSON(message));\n\n      // wait for a while until we see the collection\n      TimeOut waitUntil = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean created = false;\n      while (! waitUntil.hasTimedOut()) {\n        waitUntil.sleep(100);\n        created = ocmh.cloudManager.getClusterStateProvider().getClusterState().hasCollection(collectionName);\n        if(created) break;\n      }\n      if (!created) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not fully create collection: \" + collectionName);\n      }\n\n      // refresh cluster state\n      clusterState = ocmh.cloudManager.getClusterStateProvider().getClusterState();\n\n      List<ReplicaPosition> replicaPositions = null;\n      try {\n        replicaPositions = buildReplicaPositions(ocmh.cloudManager, clusterState, cloudConfig, clusterState.getCollection(collectionName), message, shardNames);\n      } catch (Assign.AssignmentException e) {\n        ZkNodeProps deleteMessage = new ZkNodeProps(\"name\", collectionName);\n        new DeleteCollectionCmd(ocmh).call(clusterState, cloudConfig, deleteMessage, results);\n        // unwrap the exception\n        throw new SolrException(ErrorCode.BAD_REQUEST, e.getMessage(), e.getCause());\n      }\n\n      if (replicaPositions.isEmpty()) {\n        log.debug(\"Finished create command for collection: {}\", collectionName);\n        return;\n      }\n\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(async);\n      if (log.isDebugEnabled()) {\n        log.debug(formatString(\"Creating SolrCores for new collection {0}, shardNames {1} , message : {2}\",\n            collectionName, shardNames, message));\n      }\n      Map<String,ShardRequest> coresToCreate = new LinkedHashMap<>();\n      ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n      for (ReplicaPosition replicaPosition : replicaPositions) {\n        String nodeName = replicaPosition.node;\n\n        if (withCollection != null) {\n          // check that we have a replica of `withCollection` on this node and if not, create one\n          DocCollection collection = clusterState.getCollection(withCollection);\n          List<Replica> replicas = collection.getReplicas(nodeName);\n          if (replicas == null || replicas.isEmpty()) {\n            ZkNodeProps props = new ZkNodeProps(\n                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n                ZkStateReader.COLLECTION_PROP, withCollection,\n                ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n                \"node\", nodeName,\n                CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n            new AddReplicaCmd(ocmh).call(clusterState, cloudConfig, props, results);\n            clusterState = zkStateReader.getClusterState(); // refresh\n          }\n        }\n\n        String coreName = Assign.buildSolrCoreName(ocmh.cloudManager.getDistribStateManager(),\n            ocmh.cloudManager.getClusterStateProvider().getClusterState().getCollection(collectionName),\n            replicaPosition.shard, replicaPosition.type, true);\n        if (log.isDebugEnabled()) {\n          log.debug(formatString(\"Creating core {0} as part of shard {1} of collection {2} on {3}\"\n              , coreName, replicaPosition.shard, collectionName, nodeName));\n        }\n\n        String baseUrl = zkStateReader.getBaseUrlForNodeName(nodeName);\n        // create the replica in the collection's state.json in ZK prior to creating the core.\n        // Otherwise the core creation fails\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, replicaPosition.shard,\n            ZkStateReader.CORE_NAME_PROP, coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, baseUrl,\n            ZkStateReader.NODE_NAME_PROP, nodeName,\n            ZkStateReader.REPLICA_TYPE, replicaPosition.type.name(),\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.toString(waitForFinalState));\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n\n        // Need to create new params for each request\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n\n        params.set(CoreAdminParams.NAME, coreName);\n        params.set(COLL_CONF, configName);\n        params.set(CoreAdminParams.COLLECTION, collectionName);\n        params.set(CoreAdminParams.SHARD, replicaPosition.shard);\n        params.set(ZkStateReader.NUM_SHARDS_PROP, shardNames.size());\n        params.set(CoreAdminParams.NEW_COLLECTION, \"true\");\n        params.set(CoreAdminParams.REPLICA_TYPE, replicaPosition.type.name());\n\n        if (async != null) {\n          String coreAdminAsyncId = async + Math.abs(System.nanoTime());\n          params.add(ASYNC, coreAdminAsyncId);\n          shardRequestTracker.track(nodeName, coreAdminAsyncId);\n        }\n        ocmh.addPropertyParams(message, params);\n\n        ShardRequest sreq = new ShardRequest();\n        sreq.nodeName = nodeName;\n        params.set(\"qt\", ocmh.adminPath);\n        sreq.purpose = 1;\n        sreq.shards = new String[]{baseUrl};\n        sreq.actualShards = sreq.shards;\n        sreq.params = params;\n\n        coresToCreate.put(coreName, sreq);\n      }\n\n      // wait for all replica entries to be created\n      Map<String, Replica> replicas = ocmh.waitToSeeReplicasInState(collectionName, coresToCreate.keySet());\n      for (Map.Entry<String, ShardRequest> e : coresToCreate.entrySet()) {\n        ShardRequest sreq = e.getValue();\n        sreq.params.set(CoreAdminParams.CORE_NODE_NAME, replicas.get(e.getKey()).getName());\n        shardHandler.submit(sreq, sreq.shards[0], sreq.params);\n      }\n\n      shardRequestTracker.processResponses(results, shardHandler, false, null, Collections.emptySet());\n      @SuppressWarnings({\"rawtypes\"})\n      boolean failure = results.get(\"failure\") != null && ((SimpleOrderedMap)results.get(\"failure\")).size() > 0;\n      if (failure) {\n        // Let's cleanup as we hit an exception\n        // We shouldn't be passing 'results' here for the cleanup as the response would then contain 'success'\n        // element, which may be interpreted by the user as a positive ack\n        ocmh.cleanupCollection(cloudConfig, collectionName, new NamedList<Object>());\n        log.info(\"Cleaned up artifacts for failed create collection for [{}]\", collectionName);\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Underlying core creation failed while creating collection: \" + collectionName);\n      } else {\n        log.debug(\"Finished create command on all shards for collection: {}\", collectionName);\n\n        // Emit a warning about production use of data driven functionality\n        boolean defaultConfigSetUsed = message.getStr(COLL_CONF) == null ||\n            message.getStr(COLL_CONF).equals(ConfigSetsHandlerApi.DEFAULT_CONFIGSET_NAME);\n        if (defaultConfigSetUsed) {\n          results.add(\"warning\", \"Using _default configset. Data driven schema functionality\"\n              + \" is enabled by default, which is NOT RECOMMENDED for production use. To turn it off:\"\n              + \" curl http://{host:port}/solr/\" + collectionName + \"/config -d '{\\\"set-user-property\\\": {\\\"update.autoCreateFields\\\":\\\"false\\\"}}'\");\n        }\n      }\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        try {\n          zkStateReader.waitForState(withCollection, 5, TimeUnit.SECONDS, (collectionState) -> collectionName.equals(collectionState.getStr(COLOCATED_WITH)));\n        } catch (TimeoutException e) {\n          log.warn(\"Timed out waiting to see the {} property set on collection: {}\", COLOCATED_WITH, withCollection);\n          // maybe the overseer queue is backed up, we don't want to fail the create request\n          // because of this time out, continue\n        }\n      }\n\n      // create an alias pointing to the new collection, if different from the collectionName\n      if (!alias.equals(collectionName)) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(alias, collectionName));\n      }\n\n    } catch (SolrException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, ex);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}