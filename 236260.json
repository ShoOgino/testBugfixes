{"path":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","commits":[{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"/dev/null","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = _TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c661dcad9680b8a6ce5bf2cc583a69ec965328bc","date":1352297862,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = _TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = _TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = _TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"053891414e8cd30f3b9300a8f4b685d9fd345359","date":1401970642,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(mutable.getBitsPerValue(), reader.getBitsPerValue());\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFiles(Collections.singleton(\"packed-ints.bin\"));\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFiles(Collections.singleton(\"packed-ints.bin\"));\n      }\n      directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testSave().mjava","sourceNew":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final Directory directory = new ByteBuffersDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","sourceOld":"  public void testSave() throws IOException {\n    final int valueCount = TestUtil.nextInt(random(), 1, 2048);\n    for (int bpv = 1; bpv <= 64; ++bpv) {\n      final int maxValue = (int) Math.min(PackedInts.maxValue(31), PackedInts.maxValue(bpv));\n      final RAMDirectory directory = new RAMDirectory();\n      List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bpv);\n      for (PackedInts.Mutable mutable : packedInts) {\n        for (int i = 0; i < mutable.size(); ++i) {\n          mutable.set(i, random().nextInt(maxValue));\n        }\n\n        IndexOutput out = directory.createOutput(\"packed-ints.bin\", IOContext.DEFAULT);\n        mutable.save(out);\n        out.close();\n\n        IndexInput in = directory.openInput(\"packed-ints.bin\", IOContext.DEFAULT);\n        PackedInts.Reader reader = PackedInts.getReader(in);\n        assertEquals(valueCount, reader.size());\n        if (mutable instanceof Packed64SingleBlock) {\n          // make sure that we used the right format so that the reader has\n          // the same performance characteristics as the mutable that has been\n          // serialized\n          assertTrue(reader instanceof Packed64SingleBlock);\n        } else {\n          assertFalse(reader instanceof Packed64SingleBlock);\n        }\n        for (int i = 0; i < valueCount; ++i) {\n          assertEquals(mutable.get(i), reader.get(i));\n        }\n        in.close();\n        directory.deleteFile(\"packed-ints.bin\");\n      }\n      directory.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"6613659748fe4411a7dcf85266e55db1f95f7315":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["edb74c83fff94196b864e08ca033d92823252cb7"],"d77dafd89756a5161d244985903e3487ca109182":["053891414e8cd30f3b9300a8f4b685d9fd345359"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["053891414e8cd30f3b9300a8f4b685d9fd345359"],"edb74c83fff94196b864e08ca033d92823252cb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"053891414e8cd30f3b9300a8f4b685d9fd345359":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d77dafd89756a5161d244985903e3487ca109182"]},"commit2Childs":{"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["053891414e8cd30f3b9300a8f4b685d9fd345359"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edb74c83fff94196b864e08ca033d92823252cb7"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"d77dafd89756a5161d244985903e3487ca109182":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"edb74c83fff94196b864e08ca033d92823252cb7":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"053891414e8cd30f3b9300a8f4b685d9fd345359":["d77dafd89756a5161d244985903e3487ca109182","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}