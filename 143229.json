{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","commits":[{"id":"4ff8fcbb5ae20d2286cb666d4694f0a8c3c552f6","date":1357912799,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    final List<AtomicReaderContext> leaves = r.leaves();\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms == null) {\n        norms = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n    }\n    \n    assert anyReal; // nocommit: is this assert safe?\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4f3ebea5dd11cade5d6d2cc2575ed691149b9b1","date":1357915137,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","sourceNew":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    final List<AtomicReaderContext> leaves = r.leaves();\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms == null) {\n        norms = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n    }\n    \n    // assert anyReal; // nocommit: unsafe until 4.0 is done\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    final List<AtomicReaderContext> leaves = r.leaves();\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms == null) {\n        norms = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n    }\n    \n    assert anyReal; // nocommit: is this assert safe?\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8bcc8a3dc0f439d38bb5cca141e4674eab17245","date":1357919773,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","sourceNew":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().simpleNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms != null) {\n        anyReal = true;\n      }\n    }\n    \n    // assert anyReal; // nocommit: unsafe until 4.0 is done\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    final List<AtomicReaderContext> leaves = r.leaves();\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms == null) {\n        norms = NumericDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n    }\n    \n    // assert anyReal; // nocommit: unsafe until 4.0 is done\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94a2758d07e0d83d524af25cee0d8a04b6394f47","date":1357921039,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleNormValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#simpleNormValues(IndexReader,String).mjava","sourceNew":"  // moved to src/java so SlowWrapper can use it... uggggggh\n  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().simpleNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms != null) {\n        anyReal = true;\n      }\n    }\n    \n    // assert anyReal; // nocommit: unsafe until 4.0 is done\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  public static NumericDocValues simpleNormValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().simpleNormValues(field);\n    }\n    FieldInfo fi = MultiFields.getMergedFieldInfos(r).fieldInfo(field);\n    if (fi == null || fi.hasNorms() == false) {\n      return null;\n    }\n    boolean anyReal = false;\n    for(AtomicReaderContext ctx : leaves) {\n      NumericDocValues norms = ctx.reader().simpleNormValues(field);\n\n      if (norms != null) {\n        anyReal = true;\n      }\n    }\n    \n    // assert anyReal; // nocommit: unsafe until 4.0 is done\n\n    return new NumericDocValues() {\n      @Override\n      public long get(int docID) {\n        int subIndex = ReaderUtil.subIndex(docID, leaves);\n        NumericDocValues norms;\n        try {\n          norms = leaves.get(subIndex).reader().simpleNormValues(field);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        if (norms == null) { // WTF? should be EMPTY?\n          return 0;\n        } else {\n          return norms.get(docID - leaves.get(subIndex).docBase);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f4f3ebea5dd11cade5d6d2cc2575ed691149b9b1":["4ff8fcbb5ae20d2286cb666d4694f0a8c3c552f6"],"94a2758d07e0d83d524af25cee0d8a04b6394f47":["f8bcc8a3dc0f439d38bb5cca141e4674eab17245"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f8bcc8a3dc0f439d38bb5cca141e4674eab17245":["f4f3ebea5dd11cade5d6d2cc2575ed691149b9b1"],"4ff8fcbb5ae20d2286cb666d4694f0a8c3c552f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"f4f3ebea5dd11cade5d6d2cc2575ed691149b9b1":["f8bcc8a3dc0f439d38bb5cca141e4674eab17245"],"94a2758d07e0d83d524af25cee0d8a04b6394f47":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ff8fcbb5ae20d2286cb666d4694f0a8c3c552f6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8bcc8a3dc0f439d38bb5cca141e4674eab17245":["94a2758d07e0d83d524af25cee0d8a04b6394f47"],"4ff8fcbb5ae20d2286cb666d4694f0a8c3c552f6":["f4f3ebea5dd11cade5d6d2cc2575ed691149b9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94a2758d07e0d83d524af25cee0d8a04b6394f47","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}