{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","commits":[{"id":"b354f9ab8013d7a8ec8c652cef5f86f635c8443b","date":1460558006,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","pathOld":"/dev/null","sourceNew":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bc0f1175d994495cbd5763445c91c22f543d8687"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","pathOld":"/dev/null","sourceNew":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc0f1175d994495cbd5763445c91c22f543d8687","date":1461352263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","sourceNew":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, LatLonTree.build(polygon));\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":["b354f9ab8013d7a8ec8c652cef5f86f635c8443b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","sourceNew":null,"sourceOld":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, LatLonTree.build(polygon));\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testGrowingPolygon().mjava","sourceNew":null,"sourceOld":"  public void testGrowingPolygon() {\n    double centerLat = -80.0 + random().nextDouble() * 160.0;\n    double centerLon = -170.0 + random().nextDouble() * 340.0;\n    double radiusMeters = 0.0;\n    for(int i=0;i<10;i++) {\n      radiusMeters = Math.nextUp(radiusMeters);\n    }\n\n    // Start with a miniscule polygon, and grow it:\n    int gons = TestUtil.nextInt(random(), 4, 10);\n    while (radiusMeters < GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0) {\n      Polygon polygon;\n      try {\n        polygon = GeoTestUtil.createRegularPolygon(centerLat, centerLon, radiusMeters, gons);\n      } catch (IllegalArgumentException iae) {\n        // OK: we made a too-big poly and it crossed a pole or dateline\n        break;\n      }\n      radiusMeters *= 1.1;\n\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 1000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b354f9ab8013d7a8ec8c652cef5f86f635c8443b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc0f1175d994495cbd5763445c91c22f543d8687":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b354f9ab8013d7a8ec8c652cef5f86f635c8443b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","925fce43f3bac029d912b9b7de03c789e258a333"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"925fce43f3bac029d912b9b7de03c789e258a333":["bc0f1175d994495cbd5763445c91c22f543d8687"]},"commit2Childs":{"b354f9ab8013d7a8ec8c652cef5f86f635c8443b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"bc0f1175d994495cbd5763445c91c22f543d8687":["925fce43f3bac029d912b9b7de03c789e258a333"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["bc0f1175d994495cbd5763445c91c22f543d8687","f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b354f9ab8013d7a8ec8c652cef5f86f635c8443b","9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"925fce43f3bac029d912b9b7de03c789e258a333":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}