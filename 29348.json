{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainCategoryRoutedAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainCategoryRoutedAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    //---- PARSE PRIMARY MESSAGE PARAMS\n    // important that we use NAME for the alias as that is what the Overseer will get a lock on before calling us\n    final String aliasName = message.getStr(NAME);\n    // the client believes this collection name should exist.  Our goal is to ensure it does.\n    final String categoryRequired = message.getStr(IF_CATEGORY_COLLECTION_NOT_FOUND); // optional\n\n\n    //---- PARSE ALIAS INFO FROM ZK\n    final ZkStateReader.AliasesManager aliasesManager = ocmh.zkStateReader.aliasesManager;\n    final Aliases aliases = aliasesManager.getAliases();\n    final Map<String, String> aliasMetadata = aliases.getCollectionAliasProperties(aliasName);\n    if (aliasMetadata == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Alias \" + aliasName + \" does not exist.\"); // if it did exist, we'd have a non-null map\n    }\n    final CategoryRoutedAlias categoryRoutedAlias = (CategoryRoutedAlias) RoutedAlias.fromProps(aliasName, aliasMetadata);\n\n    if (categoryRoutedAlias == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, getClass() + \" got alias metadata with an \" +\n          \"invalid routing type and produced null\");\n    }\n\n\n    //---- SEARCH FOR REQUESTED COLL\n    Map<String, List<String>> collectionAliasListMap = aliases.getCollectionAliasListMap();\n\n    // if we found it the collection already exists and we're done (concurrent creation on another request)\n    // so this if does not need an else.\n    if (!collectionAliasListMap.get(aliasName).contains(categoryRequired)) {\n      //---- DETECT and REMOVE the initial place holder collection if it still exists:\n\n      String initialCollection = categoryRoutedAlias.buildCollectionNameFromValue(UNINITIALIZED);\n\n      // important not to delete the place holder collection it until after a second collection exists,\n      // otherwise we have a situation where the alias has no collections briefly and concurrent\n      // requests to the alias will fail with internal errors (incl. queries etc).\n\n      List<String> colList = new ArrayList<>(collectionAliasListMap.get(aliasName));\n      if (colList.contains(initialCollection) && colList.size() > 1 ) {\n\n        // need to run the delete async, otherwise we may deadlock with incoming updates that are attempting\n        // to create collections (they will have called getCore() but may be waiting on the overseer alias lock\n        // we hold and we will be waiting for the Core reference count to reach zero). By deleting asynchronously\n        // we allow this request to complete and the alias lock to be released, which allows the update to complete\n        // so that we can do the delete. Additionally we don't want to cause multiple delete operations during\n        // the time the delete is in progress, since that just wastes overseer cycles.\n        // TODO: check TRA's are protected against this\n\n        if (DELETE_LOCK.tryAcquire(aliasName)) {\n          // note that the overseer might not have any cores (and the unit test occasionally catches this)\n          ocmh.overseer.getCoreContainer().runAsync(() -> {\n            aliasesManager.applyModificationAndExportToZk(curAliases -> {\n              colList.remove(initialCollection);\n              final String collectionsToKeepStr = StrUtils.join(colList, ',');\n              return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n            });\n            final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n            final SolrParams reqParams = CollectionAdminRequest\n                .deleteCollection(initialCollection).getParams();\n            SolrQueryResponse rsp = new SolrQueryResponse();\n            try {\n              collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n            } catch (Exception e) {\n              log.error(\"Could not delete initial collection from CRA\", e);\n            }\n            //noinspection unchecked\n            results.add(UNINITIALIZED, rsp.getValues());\n            DELETE_LOCK.release(aliasName);\n          });\n        }\n      }\n\n      //---- CREATE THE COLLECTION\n      NamedList createResults = createCollectionAndWait(state, aliasName, aliasMetadata,\n          categoryRequired, ocmh);\n      if (createResults != null) {\n        //noinspection unchecked\n        results.add(\"create\", createResults);\n      }\n      //---- UPDATE THE ALIAS WITH NEW COLLECTION\n      updateAlias(aliasName, aliasesManager, categoryRequired);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27f8671abed52d7fc3010c636b6fd43ae36804ac","date":1556533169,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainCategoryRoutedAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainCategoryRoutedAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    //---- PARSE PRIMARY MESSAGE PARAMS\n    // important that we use NAME for the alias as that is what the Overseer will get a lock on before calling us\n    final String aliasName = message.getStr(NAME);\n    // the client believes this collection name should exist.  Our goal is to ensure it does.\n    final String categoryRequired = message.getStr(IF_CATEGORY_COLLECTION_NOT_FOUND); // optional\n\n\n    //---- PARSE ALIAS INFO FROM ZK\n    final ZkStateReader.AliasesManager aliasesManager = ocmh.zkStateReader.aliasesManager;\n    final Aliases aliases = aliasesManager.getAliases();\n    final Map<String, String> aliasMetadata = aliases.getCollectionAliasProperties(aliasName);\n    if (aliasMetadata.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Alias \" + aliasName + \" does not exist or is not a routed alias.\"); // if it did exist, we'd have a non-null map\n    }\n    final CategoryRoutedAlias categoryRoutedAlias = (CategoryRoutedAlias) RoutedAlias.fromProps(aliasName, aliasMetadata);\n\n    if (categoryRoutedAlias == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, getClass() + \" got alias metadata with an \" +\n          \"invalid routing type and produced null\");\n    }\n\n\n    //---- SEARCH FOR REQUESTED COLL\n    Map<String, List<String>> collectionAliasListMap = aliases.getCollectionAliasListMap();\n\n    // if we found it the collection already exists and we're done (concurrent creation on another request)\n    // so this if does not need an else.\n    if (!collectionAliasListMap.get(aliasName).contains(categoryRequired)) {\n      //---- DETECT and REMOVE the initial place holder collection if it still exists:\n\n      String initialCollection = categoryRoutedAlias.buildCollectionNameFromValue(UNINITIALIZED);\n\n      // important not to delete the place holder collection it until after a second collection exists,\n      // otherwise we have a situation where the alias has no collections briefly and concurrent\n      // requests to the alias will fail with internal errors (incl. queries etc).\n\n      List<String> colList = new ArrayList<>(collectionAliasListMap.get(aliasName));\n      if (colList.contains(initialCollection) && colList.size() > 1 ) {\n\n        // need to run the delete async, otherwise we may deadlock with incoming updates that are attempting\n        // to create collections (they will have called getCore() but may be waiting on the overseer alias lock\n        // we hold and we will be waiting for the Core reference count to reach zero). By deleting asynchronously\n        // we allow this request to complete and the alias lock to be released, which allows the update to complete\n        // so that we can do the delete. Additionally we don't want to cause multiple delete operations during\n        // the time the delete is in progress, since that just wastes overseer cycles.\n        // TODO: check TRA's are protected against this\n\n        if (DELETE_LOCK.tryAcquire(aliasName)) {\n          // note that the overseer might not have any cores (and the unit test occasionally catches this)\n          ocmh.overseer.getCoreContainer().runAsync(() -> {\n            aliasesManager.applyModificationAndExportToZk(curAliases -> {\n              colList.remove(initialCollection);\n              final String collectionsToKeepStr = StrUtils.join(colList, ',');\n              return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n            });\n            final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n            final SolrParams reqParams = CollectionAdminRequest\n                .deleteCollection(initialCollection).getParams();\n            SolrQueryResponse rsp = new SolrQueryResponse();\n            try {\n              collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n            } catch (Exception e) {\n              log.error(\"Could not delete initial collection from CRA\", e);\n            }\n            //noinspection unchecked\n            results.add(UNINITIALIZED, rsp.getValues());\n            DELETE_LOCK.release(aliasName);\n          });\n        }\n      }\n\n      //---- CREATE THE COLLECTION\n      NamedList createResults = createCollectionAndWait(state, aliasName, aliasMetadata,\n          categoryRequired, ocmh);\n      if (createResults != null) {\n        //noinspection unchecked\n        results.add(\"create\", createResults);\n      }\n      //---- UPDATE THE ALIAS WITH NEW COLLECTION\n      updateAlias(aliasName, aliasesManager, categoryRequired);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    //---- PARSE PRIMARY MESSAGE PARAMS\n    // important that we use NAME for the alias as that is what the Overseer will get a lock on before calling us\n    final String aliasName = message.getStr(NAME);\n    // the client believes this collection name should exist.  Our goal is to ensure it does.\n    final String categoryRequired = message.getStr(IF_CATEGORY_COLLECTION_NOT_FOUND); // optional\n\n\n    //---- PARSE ALIAS INFO FROM ZK\n    final ZkStateReader.AliasesManager aliasesManager = ocmh.zkStateReader.aliasesManager;\n    final Aliases aliases = aliasesManager.getAliases();\n    final Map<String, String> aliasMetadata = aliases.getCollectionAliasProperties(aliasName);\n    if (aliasMetadata == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Alias \" + aliasName + \" does not exist.\"); // if it did exist, we'd have a non-null map\n    }\n    final CategoryRoutedAlias categoryRoutedAlias = (CategoryRoutedAlias) RoutedAlias.fromProps(aliasName, aliasMetadata);\n\n    if (categoryRoutedAlias == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, getClass() + \" got alias metadata with an \" +\n          \"invalid routing type and produced null\");\n    }\n\n\n    //---- SEARCH FOR REQUESTED COLL\n    Map<String, List<String>> collectionAliasListMap = aliases.getCollectionAliasListMap();\n\n    // if we found it the collection already exists and we're done (concurrent creation on another request)\n    // so this if does not need an else.\n    if (!collectionAliasListMap.get(aliasName).contains(categoryRequired)) {\n      //---- DETECT and REMOVE the initial place holder collection if it still exists:\n\n      String initialCollection = categoryRoutedAlias.buildCollectionNameFromValue(UNINITIALIZED);\n\n      // important not to delete the place holder collection it until after a second collection exists,\n      // otherwise we have a situation where the alias has no collections briefly and concurrent\n      // requests to the alias will fail with internal errors (incl. queries etc).\n\n      List<String> colList = new ArrayList<>(collectionAliasListMap.get(aliasName));\n      if (colList.contains(initialCollection) && colList.size() > 1 ) {\n\n        // need to run the delete async, otherwise we may deadlock with incoming updates that are attempting\n        // to create collections (they will have called getCore() but may be waiting on the overseer alias lock\n        // we hold and we will be waiting for the Core reference count to reach zero). By deleting asynchronously\n        // we allow this request to complete and the alias lock to be released, which allows the update to complete\n        // so that we can do the delete. Additionally we don't want to cause multiple delete operations during\n        // the time the delete is in progress, since that just wastes overseer cycles.\n        // TODO: check TRA's are protected against this\n\n        if (DELETE_LOCK.tryAcquire(aliasName)) {\n          // note that the overseer might not have any cores (and the unit test occasionally catches this)\n          ocmh.overseer.getCoreContainer().runAsync(() -> {\n            aliasesManager.applyModificationAndExportToZk(curAliases -> {\n              colList.remove(initialCollection);\n              final String collectionsToKeepStr = StrUtils.join(colList, ',');\n              return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n            });\n            final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n            final SolrParams reqParams = CollectionAdminRequest\n                .deleteCollection(initialCollection).getParams();\n            SolrQueryResponse rsp = new SolrQueryResponse();\n            try {\n              collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n            } catch (Exception e) {\n              log.error(\"Could not delete initial collection from CRA\", e);\n            }\n            //noinspection unchecked\n            results.add(UNINITIALIZED, rsp.getValues());\n            DELETE_LOCK.release(aliasName);\n          });\n        }\n      }\n\n      //---- CREATE THE COLLECTION\n      NamedList createResults = createCollectionAndWait(state, aliasName, aliasMetadata,\n          categoryRequired, ocmh);\n      if (createResults != null) {\n        //noinspection unchecked\n        results.add(\"create\", createResults);\n      }\n      //---- UPDATE THE ALIAS WITH NEW COLLECTION\n      updateAlias(aliasName, aliasesManager, categoryRequired);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":4,"author":"Gus Heck","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MaintainCategoryRoutedAliasCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    //---- PARSE PRIMARY MESSAGE PARAMS\n    // important that we use NAME for the alias as that is what the Overseer will get a lock on before calling us\n    final String aliasName = message.getStr(NAME);\n    // the client believes this collection name should exist.  Our goal is to ensure it does.\n    final String categoryRequired = message.getStr(IF_CATEGORY_COLLECTION_NOT_FOUND); // optional\n\n\n    //---- PARSE ALIAS INFO FROM ZK\n    final ZkStateReader.AliasesManager aliasesManager = ocmh.zkStateReader.aliasesManager;\n    final Aliases aliases = aliasesManager.getAliases();\n    final Map<String, String> aliasMetadata = aliases.getCollectionAliasProperties(aliasName);\n    if (aliasMetadata.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Alias \" + aliasName + \" does not exist or is not a routed alias.\"); // if it did exist, we'd have a non-null map\n    }\n    final CategoryRoutedAlias categoryRoutedAlias = (CategoryRoutedAlias) RoutedAlias.fromProps(aliasName, aliasMetadata);\n\n    if (categoryRoutedAlias == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, getClass() + \" got alias metadata with an \" +\n          \"invalid routing type and produced null\");\n    }\n\n\n    //---- SEARCH FOR REQUESTED COLL\n    Map<String, List<String>> collectionAliasListMap = aliases.getCollectionAliasListMap();\n\n    // if we found it the collection already exists and we're done (concurrent creation on another request)\n    // so this if does not need an else.\n    if (!collectionAliasListMap.get(aliasName).contains(categoryRequired)) {\n      //---- DETECT and REMOVE the initial place holder collection if it still exists:\n\n      String initialCollection = categoryRoutedAlias.buildCollectionNameFromValue(UNINITIALIZED);\n\n      // important not to delete the place holder collection it until after a second collection exists,\n      // otherwise we have a situation where the alias has no collections briefly and concurrent\n      // requests to the alias will fail with internal errors (incl. queries etc).\n\n      List<String> colList = new ArrayList<>(collectionAliasListMap.get(aliasName));\n      if (colList.contains(initialCollection) && colList.size() > 1 ) {\n\n        // need to run the delete async, otherwise we may deadlock with incoming updates that are attempting\n        // to create collections (they will have called getCore() but may be waiting on the overseer alias lock\n        // we hold and we will be waiting for the Core reference count to reach zero). By deleting asynchronously\n        // we allow this request to complete and the alias lock to be released, which allows the update to complete\n        // so that we can do the delete. Additionally we don't want to cause multiple delete operations during\n        // the time the delete is in progress, since that just wastes overseer cycles.\n        // TODO: check TRA's are protected against this\n\n        if (DELETE_LOCK.tryAcquire(aliasName)) {\n          // note that the overseer might not have any cores (and the unit test occasionally catches this)\n          ocmh.overseer.getCoreContainer().runAsync(() -> {\n            aliasesManager.applyModificationAndExportToZk(curAliases -> {\n              colList.remove(initialCollection);\n              final String collectionsToKeepStr = StrUtils.join(colList, ',');\n              return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);\n            });\n            final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();\n            final SolrParams reqParams = CollectionAdminRequest\n                .deleteCollection(initialCollection).getParams();\n            SolrQueryResponse rsp = new SolrQueryResponse();\n            try {\n              collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);\n            } catch (Exception e) {\n              log.error(\"Could not delete initial collection from CRA\", e);\n            }\n            //noinspection unchecked\n            results.add(UNINITIALIZED, rsp.getValues());\n            DELETE_LOCK.release(aliasName);\n          });\n        }\n      }\n\n      //---- CREATE THE COLLECTION\n      NamedList createResults = createCollectionAndWait(state, aliasName, aliasMetadata,\n          categoryRequired, ocmh);\n      if (createResults != null) {\n        //noinspection unchecked\n        results.add(\"create\", createResults);\n      }\n      //---- UPDATE THE ALIAS WITH NEW COLLECTION\n      updateAlias(aliasName, aliasesManager, categoryRequired);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b627755385655c7cd3fb296f17593658805cf4d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["27f8671abed52d7fc3010c636b6fd43ae36804ac"],"27f8671abed52d7fc3010c636b6fd43ae36804ac":["b627755385655c7cd3fb296f17593658805cf4d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b627755385655c7cd3fb296f17593658805cf4d5"],"b627755385655c7cd3fb296f17593658805cf4d5":["27f8671abed52d7fc3010c636b6fd43ae36804ac"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"27f8671abed52d7fc3010c636b6fd43ae36804ac":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}