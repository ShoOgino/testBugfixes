{"path":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","commits":[{"id":"f34d83c894e07c24f5f957820777b5da2cc29e5a","date":1489491395,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toNamedMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,BiConsumer[String,Map[String,Object]]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, convertGauge(gauge, compact));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toNamedMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                BiConsumer<String, Map<String, Object>> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, counterToMap(counter));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, gaugeToMap(gauge));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, meterToMap(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, timerToMap(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, histogramToMap(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, aggregateMetricToMap((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b","date":1489651910,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toNamedMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,BiConsumer[String,Map[String,Object]]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, convertGauge(gauge, compact));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toNamedMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                BiConsumer<String, Map<String, Object>> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, counterToMap(counter));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, gaugeToMap(gauge));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, meterToMap(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, timerToMap(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, histogramToMap(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, aggregateMetricToMap((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toNamedMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,BiConsumer[String,Map[String,Object]]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, convertGauge(gauge, compact));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toNamedMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                BiConsumer<String, Map<String, Object>> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, counterToMap(counter));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, gaugeToMap(gauge));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, meterToMap(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, timerToMap(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, histogramToMap(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, aggregateMetricToMap((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"413934793f78ea84d60fafb85e566d4a90277632","date":1490645943,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n              consumer.accept(n, null);\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, convertGauge(gauge, compact));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c21acb733efcbefbc1a81e1152ae1bec1725a3a","date":1490793993,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              if (n.startsWith(\"memory.\") && ie.getMessage().contains(\"Memory Pool not found\")) {\n                LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n                consumer.accept(n, null);\n              } else {\n                throw ie;\n              }\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n              consumer.accept(n, null);\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"983d2e48d6584570adcbdabb7bac1fecdf5fca0d","date":1490873944,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n              consumer.accept(n, null);\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            consumer.accept(n, convertGauge(gauge, compact));\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":["a4c0d58c97db195a961f93ceebc3808cb68c8674"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4c0d58c97db195a961f93ceebc3808cb68c8674","date":1490873947,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              if (n.startsWith(\"memory.\") && ie.getMessage().contains(\"Memory Pool not found\")) {\n                LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n                consumer.accept(n, null);\n              } else {\n                throw ie;\n              }\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n              consumer.accept(n, null);\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":["983d2e48d6584570adcbdabb7bac1fecdf5fca0d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":null,"sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              if (n.startsWith(\"memory.\") && ie.getMessage().contains(\"Memory Pool not found\")) {\n                LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n                consumer.accept(n, null);\n              } else {\n                throw ie;\n              }\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/util/stats/MetricUtils#toMaps(MetricRegistry,List[MetricFilter],MetricFilter,boolean,boolean,boolean,BiConsumer[String,Object]).mjava","sourceNew":null,"sourceOld":"  public static void toMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,\n                            MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,\n                            boolean compact,\n                            BiConsumer<String, Object> consumer) {\n    Map<String, Metric> metrics = registry.getMetrics();\n    SortedSet<String> names = registry.getNames();\n    names.stream()\n        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))\n        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))\n        .forEach(n -> {\n          Metric metric = metrics.get(n);\n          if (metric instanceof Counter) {\n            Counter counter = (Counter) metric;\n            consumer.accept(n, convertCounter(counter, compact));\n          } else if (metric instanceof Gauge) {\n            Gauge gauge = (Gauge) metric;\n            try {\n              consumer.accept(n, convertGauge(gauge, compact));\n            } catch (InternalError ie) {\n              if (n.startsWith(\"memory.\") && ie.getMessage().contains(\"Memory Pool not found\")) {\n                LOG.warn(\"Error converting gauge '\" + n + \"', possible JDK bug: SOLR-10362\", ie);\n                consumer.accept(n, null);\n              } else {\n                throw ie;\n              }\n            }\n          } else if (metric instanceof Meter) {\n            Meter meter = (Meter) metric;\n            consumer.accept(n, convertMeter(meter));\n          } else if (metric instanceof Timer) {\n            Timer timer = (Timer) metric;\n            consumer.accept(n, convertTimer(timer, skipHistograms));\n          } else if (metric instanceof Histogram) {\n            if (!skipHistograms) {\n              Histogram histogram = (Histogram) metric;\n              consumer.accept(n, convertHistogram(histogram));\n            }\n          } else if (metric instanceof AggregateMetric) {\n            consumer.accept(n, convertAggregateMetric((AggregateMetric)metric, skipAggregateValues));\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a4c0d58c97db195a961f93ceebc3808cb68c8674"],"983d2e48d6584570adcbdabb7bac1fecdf5fca0d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"413934793f78ea84d60fafb85e566d4a90277632":["f34d83c894e07c24f5f957820777b5da2cc29e5a"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a4c0d58c97db195a961f93ceebc3808cb68c8674":["983d2e48d6584570adcbdabb7bac1fecdf5fca0d"],"8c21acb733efcbefbc1a81e1152ae1bec1725a3a":["413934793f78ea84d60fafb85e566d4a90277632"],"ab68488225b6a6c357dda72ed11dedca9914a192":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"816521ebaad5add9cb96bb88c577394e2938c40b":["8c21acb733efcbefbc1a81e1152ae1bec1725a3a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["816521ebaad5add9cb96bb88c577394e2938c40b"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"983d2e48d6584570adcbdabb7bac1fecdf5fca0d":["a4c0d58c97db195a961f93ceebc3808cb68c8674"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f34d83c894e07c24f5f957820777b5da2cc29e5a","ab68488225b6a6c357dda72ed11dedca9914a192","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"413934793f78ea84d60fafb85e566d4a90277632":["8c21acb733efcbefbc1a81e1152ae1bec1725a3a"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["413934793f78ea84d60fafb85e566d4a90277632"],"a4c0d58c97db195a961f93ceebc3808cb68c8674":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"ab68488225b6a6c357dda72ed11dedca9914a192":["983d2e48d6584570adcbdabb7bac1fecdf5fca0d"],"8c21acb733efcbefbc1a81e1152ae1bec1725a3a":["816521ebaad5add9cb96bb88c577394e2938c40b"],"816521ebaad5add9cb96bb88c577394e2938c40b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}