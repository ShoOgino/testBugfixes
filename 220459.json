{"path":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","commits":[{"id":"ca70fffb953aae4d27efbfc28758033a317f39b1","date":1396371342,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","pathOld":"/dev/null","sourceNew":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    UpdateRequestProcessorFactory[] factories = chain.getFactories();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.length);\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories[1].getClass(),\n               factories[1] instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories[1];\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","pathOld":"/dev/null","sourceNew":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    UpdateRequestProcessorFactory[] factories = chain.getFactories();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.length);\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories[1].getClass(),\n               factories[1] instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories[1];\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"733eaf468f18297b1bcc51031353bdfdd1913bdf","date":1456928540,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","sourceNew":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    List<UpdateRequestProcessorFactory> factories = chain.getProcessors();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.size());\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories.get(1).getClass(),\n               factories.get(1) instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories.get(1);\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","sourceOld":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    UpdateRequestProcessorFactory[] factories = chain.getFactories();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.length);\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories[1].getClass(),\n               factories[1] instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories[1];\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactoryTest#testAutomaticDeletes().mjava","sourceNew":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    List<UpdateRequestProcessorFactory> factories = chain.getProcessors();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.size());\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories.get(1).getClass(),\n               factories.get(1) instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories.get(1);\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","sourceOld":"  public void testAutomaticDeletes() throws Exception {\n\n    // get a handle on our recorder\n\n    UpdateRequestProcessorChain chain = \n      h.getCore().getUpdateProcessingChain(\"scheduled-delete\");\n\n    assertNotNull(chain);\n\n    UpdateRequestProcessorFactory[] factories = chain.getFactories();\n    assertEquals(\"did number of processors configured in chain get changed?\", \n                 5, factories.length);\n    assertTrue(\"Expected [1] RecordingUpdateProcessorFactory: \" + factories[1].getClass(),\n               factories[1] instanceof RecordingUpdateProcessorFactory);\n    RecordingUpdateProcessorFactory recorder = \n      (RecordingUpdateProcessorFactory) factories[1];\n\n    // now start recording, and monitor for the expected commands\n\n    try {\n      recorder.startRecording();\n      \n      // more then one iter to verify it's recurring\n      final int numItersToCheck = 1 + RANDOM_MULTIPLIER;\n      \n      for (int i = 0; i < numItersToCheck; i++) { \n        UpdateCommand tmp;\n        \n        // be generous in how long we wait, some jenkins machines are slooooow\n        tmp = recorder.commandQueue.poll(30, TimeUnit.SECONDS);\n        \n        // we can be confident in the order because DocExpirationUpdateProcessorFactory\n        // uses the same request for both the delete & the commit -- and both \n        // RecordingUpdateProcessorFactory's getInstance & startRecording methods are \n        // synchronized.  So it should not be possible to start recording in the \n        // middle of the two commands\n        assertTrue(\"expected DeleteUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof DeleteUpdateCommand);\n        \n        DeleteUpdateCommand delete = (DeleteUpdateCommand) tmp;\n        assertFalse(delete.isDeleteById());\n        assertNotNull(delete.getQuery());\n        assertTrue(delete.getQuery(), \n                   delete.getQuery().startsWith(\"{!cache=false}eXpField_tdt:[* TO \"));\n        \n        // commit should be immediately after the delete\n        tmp = recorder.commandQueue.poll(5, TimeUnit.SECONDS);\n        assertTrue(\"expected CommitUpdateCommand: \" + tmp.getClass(),\n                   tmp instanceof CommitUpdateCommand);\n        \n        CommitUpdateCommand commit = (CommitUpdateCommand) tmp;\n        assertTrue(commit.softCommit);\n        assertTrue(commit.openSearcher);\n      } \n    } finally {\n      recorder.stopRecording();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ca70fffb953aae4d27efbfc28758033a317f39b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca70fffb953aae4d27efbfc28758033a317f39b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["ca70fffb953aae4d27efbfc28758033a317f39b1","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["5eb2511ababf862ea11e10761c70ee560cd84510","cf1a614098b46c9c22afebd7b898ae4d1d2fc273","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}