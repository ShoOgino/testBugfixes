{"path":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","commits":[{"id":"65a70ca4e6df183f7a8f69687b55379fea0ddac2","date":1225224829,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"/dev/null","sourceNew":"  private void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e029dc5b4b1416143733a687133a9bdb55b5fe1","date":1225344931,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'minSize' config parameter.\n   */\n  public void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65c929c1b194a96c1990d03c2d8797f8ba426446","date":1225382798,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'minSize' config parameter.\n   */\n  public void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      isCleaning = true;\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      isCleaning = false;\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'minSize' config parameter.\n   */\n  public void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b","date":1225722778,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'minSize' config parameter.\n   */\n  public void markAndSweep() {\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      isCleaning = true;\n      int size = stats.size.get();\n      long currentLatestAccessed = stats.accessCounter.get();\n      int itemsToBeRemoved = size - lowerWaterMark;\n      int itemsRemoved = 0;\n      if (itemsToBeRemoved < 1) return;\n      // currentLatestAccessed is the counter value of the item accessed most recently\n      // therefore remove all items whose last accessed counter is less than (currentLatestAccessed - lowerWaterMark)\n      long removeOlderThan = currentLatestAccessed - lowerWaterMark;\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        if (entry.getValue().lastAccessed <= removeOlderThan && itemsRemoved < itemsToBeRemoved) {\n          evictEntry(entry.getKey());\n        }\n      }\n\n      // Since the removal of items in the above loop depends on the value of the lastAccessed variable,\n      // between the time we recorded the number of items to be removed and the actual removal process,\n      // some items may graduate above the removeOlderThan value and escape eviction.\n      // Therefore, we again check if the size less than acceptableWaterMark, if not we remove items forcefully\n      // using a method which does not depend on the value of lastAccessed but can be more costly to run\n\n      size = stats.size.get();\n      // In the first attempt, try to use a simple algorithm to remove old entries\n      // If the size of the cache is <= acceptableWatermark then return\n      if (size <= acceptableWaterMark) return;\n      // Remove items until size becomes lower than acceptableWaterMark\n      itemsToBeRemoved = size - acceptableWaterMark;\n      TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();\n      // This loop may remove a few newer items because we try to forcefully fill a\n      // bucket of fixed size and remove them even if they have become newer in the meantime\n      // The caveat is that this may lead to more cache misses because we may have removed\n      // an item which was used very recently (against the philosophy of LRU)\n      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {\n        CacheEntry v = entry.getValue();\n        v.lastAccessedCopy = v.lastAccessed;\n        if (tree.size() < itemsToBeRemoved) {\n          tree.add(v);\n        } else {\n          if (v.lastAccessedCopy < tree.first().lastAccessedCopy) {\n            tree.remove(tree.first());\n            tree.add(v);\n          }\n        }\n      }\n      for (CacheEntry sortCacheEntry : tree)\n        evictEntry(sortCacheEntry.key);\n    } finally {\n      isCleaning = false;\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":["46c2e69e24fdb80c38cccc44674ea27a8d993f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eaa3b356f379bef56d6457517e0158dac118e99e","date":1227476542,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3602d5eab954caecc726ab136ad580ac1ceb917","date":1228676831,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/common/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Integer.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Integer.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue queue = new PQueue(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (Object o : queue.getValues()) {\n          if (o==null) continue;\n          CacheEntry<K,V> ce = (CacheEntry)o;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"65c929c1b194a96c1990d03c2d8797f8ba426446":["2e029dc5b4b1416143733a687133a9bdb55b5fe1"],"e3602d5eab954caecc726ab136ad580ac1ceb917":["eaa3b356f379bef56d6457517e0158dac118e99e"],"eaa3b356f379bef56d6457517e0158dac118e99e":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"65a70ca4e6df183f7a8f69687b55379fea0ddac2":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b":["65c929c1b194a96c1990d03c2d8797f8ba426446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e029dc5b4b1416143733a687133a9bdb55b5fe1":["65a70ca4e6df183f7a8f69687b55379fea0ddac2"]},"commit2Childs":{"65c929c1b194a96c1990d03c2d8797f8ba426446":["516bcb3c0d409157f56056e1ecd5e5361ca4ae0b"],"e3602d5eab954caecc726ab136ad580ac1ceb917":[],"eaa3b356f379bef56d6457517e0158dac118e99e":["e3602d5eab954caecc726ab136ad580ac1ceb917"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["65a70ca4e6df183f7a8f69687b55379fea0ddac2"],"65a70ca4e6df183f7a8f69687b55379fea0ddac2":["2e029dc5b4b1416143733a687133a9bdb55b5fe1"],"516bcb3c0d409157f56056e1ecd5e5361ca4ae0b":["eaa3b356f379bef56d6457517e0158dac118e99e"],"2e029dc5b4b1416143733a687133a9bdb55b5fe1":["65c929c1b194a96c1990d03c2d8797f8ba426446"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e3602d5eab954caecc726ab136ad580ac1ceb917","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}