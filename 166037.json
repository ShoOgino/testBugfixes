{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","commits":[{"id":"f93c27491251c14ea21df71ebbf6feb9f891e6cb","date":1358211079,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","pathOld":"/dev/null","sourceNew":"  /** Expert: like {@link Util#getByOutput(FST, long)} except reusing */\n  // nocommit\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e13bf6998389e201ae22c6e84079b9d6b5da0af","date":1358809420,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** Expert: like {@link Util#getByOutput(FST, long)} except reusing */\n  // nocommit\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1e13bf6998389e201ae22c6e84079b9d6b5da0af"],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e13bf6998389e201ae22c6e84079b9d6b5da0af":["f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["1e13bf6998389e201ae22c6e84079b9d6b5da0af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4d69c535930b5cce125cff868d40f6373dc27d4","f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"1e13bf6998389e201ae22c6e84079b9d6b5da0af":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}