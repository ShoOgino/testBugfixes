{"path":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","commits":[{"id":"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb","date":1233863590,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean).mjava","sourceNew":"    public void build(List<String> paths, String fieldName,\n                      boolean multiValued, boolean record, int flags) {\n      String name = paths.remove(0);\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1);\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          if (record) {\n            n.isRecord = true;\n            n.forEachPath = fieldName;\n          } else {\n            n.hasText = true;\n            n.fieldName = fieldName;\n            n.multiValued = multiValued;\n            n.flatten = flags == FLATTEN;\n          }\n        } else {\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    public void build(List<String> paths, String fieldName,\n                      boolean multiValued, boolean record) {\n      String name = paths.remove(0);\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1);\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          if (record) {\n            n.isRecord = true;\n            n.forEachPath = fieldName;\n          } else {\n            n.hasText = true;\n            n.fieldName = fieldName;\n            n.multiValued = multiValued;\n          }\n        } else {\n          n.build(paths, fieldName, multiValued, record);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5bb8a93dd58a4cde932f3e3ee4e13dc6832949","date":1252931993,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**Build the node structure from the xpath\n     * @param paths the xpaths split by '/'\n     * @param fieldName name of the field\n     * @param multiValued . is multiValued or not\n     * @param record is this xpath a record or a field\n     * @param flags extra flags\n     */\n    private void build(List<String> paths, String fieldName,\n                      boolean multiValued, boolean record, int flags) {\n      String name = paths.remove(0);\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1);\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          if (record) {\n            n.isRecord = true;\n            n.forEachPath = fieldName;\n          } else {\n            n.hasText = true;\n            n.fieldName = fieldName;\n            n.multiValued = multiValued;\n            n.flatten = flags == FLATTEN;\n          }\n        } else {\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    public void build(List<String> paths, String fieldName,\n                      boolean multiValued, boolean record, int flags) {\n      String name = paths.remove(0);\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1);\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          if (record) {\n            n.isRecord = true;\n            n.forEachPath = fieldName;\n          } else {\n            n.hasText = true;\n            n.fieldName = fieldName;\n            n.multiValued = multiValued;\n            n.flatten = flags == FLATTEN;\n          }\n        } else {\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b14ccda0bdb398cf86bc3804e1c136a615dbd89b","date":1253269935,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     *\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String name = paths.remove(0); // shift out next Xpath segment\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1); // strip the '@'\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          // We have reached the end of paths. When parsing the actual\n          // input we have traversed to a position where we actutally have to\n          // do something. getOrAddChildNode() will have created and returned\n          // a new minimal Node with name and xpathName already populated. We\n          // need to add more information\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**Build the node structure from the xpath\n     * @param paths the xpaths split by '/'\n     * @param fieldName name of the field\n     * @param multiValued . is multiValued or not\n     * @param record is this xpath a record or a field\n     * @param flags extra flags\n     */\n    private void build(List<String> paths, String fieldName,\n                      boolean multiValued, boolean record, int flags) {\n      String name = paths.remove(0);\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1);\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          if (record) {\n            n.isRecord = true;\n            n.forEachPath = fieldName;\n          } else {\n            n.hasText = true;\n            n.fieldName = fieldName;\n            n.multiValued = multiValued;\n            n.flatten = flags == FLATTEN;\n          }\n        } else {\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f2a93a28913071a0b713be1d4b8a1181388d550","date":1254814948,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     *\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String name = paths.remove(0); // shift out next Xpath segment\n      if (paths.isEmpty() && name.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        name = name.substring(1); // strip the '@'\n        attributes.add(new Node(name, fieldName, multiValued));\n\n      } else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddChildNode(name);\n        if (paths.isEmpty()) {\n          // We have reached the end of paths. When parsing the actual\n          // input we have traversed to a position where we actutally have to\n          // do something. getOrAddChildNode() will have created and returned\n          // a new minimal Node with name and xpathName already populated. We\n          // need to add more information\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cb5bb8a93dd58a4cde932f3e3ee4e13dc6832949":["d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["7f2a93a28913071a0b713be1d4b8a1181388d550"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f2a93a28913071a0b713be1d4b8a1181388d550":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["cb5bb8a93dd58a4cde932f3e3ee4e13dc6832949"],"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"]},"commit2Childs":{"cb5bb8a93dd58a4cde932f3e3ee4e13dc6832949":["b14ccda0bdb398cf86bc3804e1c136a615dbd89b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"d6a43d4d79c846f6b9308b9adc72dd8de0ab6bdb":["cb5bb8a93dd58a4cde932f3e3ee4e13dc6832949"],"7f2a93a28913071a0b713be1d4b8a1181388d550":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b14ccda0bdb398cf86bc3804e1c136a615dbd89b":["7f2a93a28913071a0b713be1d4b8a1181388d550"]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}