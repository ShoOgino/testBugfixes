{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      if (packed) {\n        emptyOutput = outputs.read(getBytesReader(0));\n      } else {\n        emptyOutput = outputs.read(getBytesReader(numBytes-1));\n      }\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      final int nodeRefCount = in.readVInt();\n      nodeRefToAddress = new int[nodeRefCount];\n      for(int idx=0;idx<nodeRefCount;idx++) {\n        nodeRefToAddress[idx] = in.readVInt();\n      }\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      if (packed) {\n        emptyOutput = outputs.read(getBytesReader(0));\n      } else {\n        emptyOutput = outputs.read(getBytesReader(numBytes-1));\n      }\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      final int nodeRefCount = in.readVInt();\n      nodeRefToAddress = new int[nodeRefCount];\n      for(int idx=0;idx<nodeRefCount;idx++) {\n        nodeRefToAddress[idx] = in.readVInt();\n      }\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      if (packed) {\n        emptyOutput = outputs.read(getBytesReader(0));\n      } else {\n        emptyOutput = outputs.read(getBytesReader(numBytes-1));\n      }\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      if (packed) {\n        emptyOutput = outputs.read(getBytesReader(0));\n      } else {\n        emptyOutput = outputs.read(getBytesReader(numBytes-1));\n      }\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      final int nodeRefCount = in.readVInt();\n      nodeRefToAddress = new int[nodeRefCount];\n      for(int idx=0;idx<nodeRefCount;idx++) {\n        nodeRefToAddress[idx] = in.readVInt();\n      }\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      BytesReader reader;\n      if (packed) {\n        reader = getBytesReader(0);\n      } else {\n        reader = getBytesReader(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      if (packed) {\n        emptyOutput = outputs.read(getBytesReader(0));\n      } else {\n        emptyOutput = outputs.read(getBytesReader(numBytes-1));\n      }\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09827d0d9c0291b55c1258295b29a4fe7f0a1f40","date":1357659901,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      BytesReader reader;\n      if (packed) {\n        reader = getBytesReader(0);\n      } else {\n        reader = getBytesReader(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb8af2aec0a8574cf50cad6939d4475179595eca","date":1357675799,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      // messy\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      BytesReader reader;\n      if (packed) {\n        reader = getBytesReader(0);\n      } else {\n        reader = getBytesReader(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"556c8202987f72dd8458e25e21a82d98fc274979","date":1358008288,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":null,"bugIntro":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    writer = null;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_PACKED);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      int numBytes = in.readVInt();\n      bytes = new byte[numBytes];\n      in.readBytes(bytes, 0, numBytes);\n      \n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = new ForwardBytesReader(bytes, 0);\n      } else {\n        reader = new ReverseBytesReader(bytes, bytes.length-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVInt();\n    arcCount = in.readVInt();\n    arcWithOutputCount = in.readVInt();\n\n    bytes = new byte[in.readVInt()];\n    in.readBytes(bytes, 0, bytes.length);\n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"651a27b35167c2ea81f87f4749722e52b7d5b750","date":1359669118,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this(in, outputs, DEFAULT_MAX_BLOCK_BITS);\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":["556c8202987f72dd8458e25e21a82d98fc274979","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","fb8af2aec0a8574cf50cad6939d4475179595eca","8b3d500d9caea2bb55ac8d2399642dc13b88d739","87e78f3c129251e74ecc2ff73a32de0f27cf09d5","b3be20ca1091c0b7cdb2308b9023606a5e451cec","09827d0d9c0291b55c1258295b29a4fe7f0a1f40","d4769bdea5a853f1841c485bc1fd9d79cb7022fc","44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","5ebe14aae60589c9bb6423f3cce02d5f599e1540","edb74c83fff94196b864e08ca033d92823252cb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","date":1359670147,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this(in, outputs, DEFAULT_MAX_BLOCK_BITS);\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this.outputs = outputs;\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVInt();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    int numBytes = in.readVInt();\n    bytes = new BytesStore(in, numBytes, Integer.MAX_VALUE);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","date":1550598742,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this(in, outputs, new OnHeapFSTStore(DEFAULT_MAX_BLOCK_BITS));\n  }\n\n","sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this(in, outputs, DEFAULT_MAX_BLOCK_BITS);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T]).mjava","sourceNew":null,"sourceOld":"  /** Load a previously saved FST. */\n  public FST(DataInput in, Outputs<T> outputs) throws IOException {\n    this(in, outputs, new OnHeapFSTStore(DEFAULT_MAX_BLOCK_BITS));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["556c8202987f72dd8458e25e21a82d98fc274979"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"556c8202987f72dd8458e25e21a82d98fc274979":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"fb8af2aec0a8574cf50cad6939d4475179595eca":["09827d0d9c0291b55c1258295b29a4fe7f0a1f40"],"09827d0d9c0291b55c1258295b29a4fe7f0a1f40":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["fb8af2aec0a8574cf50cad6939d4475179595eca"],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":["8917bfede3b4ca30f4305c1e391e9218959cd723","651a27b35167c2ea81f87f4749722e52b7d5b750"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edb74c83fff94196b864e08ca033d92823252cb7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["edb74c83fff94196b864e08ca033d92823252cb7"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["5ebe14aae60589c9bb6423f3cce02d5f599e1540","fb8af2aec0a8574cf50cad6939d4475179595eca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"]},"commit2Childs":{"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","651a27b35167c2ea81f87f4749722e52b7d5b750"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["edb74c83fff94196b864e08ca033d92823252cb7"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86"],"556c8202987f72dd8458e25e21a82d98fc274979":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb8af2aec0a8574cf50cad6939d4475179595eca":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"09827d0d9c0291b55c1258295b29a4fe7f0a1f40":["fb8af2aec0a8574cf50cad6939d4475179595eca"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["556c8202987f72dd8458e25e21a82d98fc274979"],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["99f06f5dd087b1829e7b4139e4d014c786b92572"],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"edb74c83fff94196b864e08ca033d92823252cb7":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["09827d0d9c0291b55c1258295b29a4fe7f0a1f40","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}