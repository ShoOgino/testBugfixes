{"path":"solr/contrib/solr-mr/src/test/org/apache/solr/hadoop/hack/MiniYARNCluster#MiniYARNCluster(String,int,int,int,File).mjava","commits":[{"id":"d6e604e9030fb0cabf0c5a85ae6039921a81419c","date":1386009743,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/solr-mr/src/test/org/apache/solr/hadoop/hack/MiniYARNCluster#MiniYARNCluster(String,int,int,int,File).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param testName name of the test\n   * @param noOfNodeManagers the number of node managers in the cluster\n   * @param numLocalDirs the number of nm-local-dirs per nodemanager\n   * @param numLogDirs the number of nm-log-dirs per nodemanager\n   */\n  public MiniYARNCluster(String testName, int noOfNodeManagers,\n                         int numLocalDirs, int numLogDirs, File testWorkDir) {\n    super(testName.replace(\"$\", \"\"));\n    this.numLocalDirs = numLocalDirs;\n    this.numLogDirs = numLogDirs;\n    String testSubDir = testName.replace(\"$\", \"\");\n    File targetWorkDir = new File(testWorkDir, testSubDir);\n    try {\n      FileContext.getLocalFSFileContext().delete(\n          new Path(targetWorkDir.getAbsolutePath()), true);\n    } catch (Exception e) {\n      LOG.warn(\"COULD NOT CLEANUP\", e);\n      throw new YarnRuntimeException(\"could not cleanup test dir: \"+ e, e);\n    } \n\n    if (Shell.WINDOWS) {\n      // The test working directory can exceed the maximum path length supported\n      // by some Windows APIs and cmd.exe (260 characters).  To work around this,\n      // create a symlink in temporary storage with a much shorter path,\n      // targeting the full path to the test working directory.  Then, use the\n      // symlink as the test working directory.\n      String targetPath = targetWorkDir.getAbsolutePath();\n      File link = new File(System.getProperty(\"java.io.tmpdir\"),\n        String.valueOf(System.currentTimeMillis()));\n      String linkPath = link.getAbsolutePath();\n\n      try {\n        FileContext.getLocalFSFileContext().delete(new Path(linkPath), true);\n      } catch (IOException e) {\n        throw new YarnRuntimeException(\"could not cleanup symlink: \" + linkPath, e);\n      }\n\n      // Guarantee target exists before creating symlink.\n      targetWorkDir.mkdirs();\n\n      ShellCommandExecutor shexec = new ShellCommandExecutor(\n        Shell.getSymlinkCommand(targetPath, linkPath));\n      try {\n        shexec.execute();\n      } catch (IOException e) {\n        throw new YarnRuntimeException(String.format(Locale.ENGLISH,\n          \"failed to create symlink from %s to %s, shell output: %s\", linkPath,\n          targetPath, shexec.getOutput()), e);\n      }\n\n      this.testWorkDir = link;\n    } else {\n      this.testWorkDir = targetWorkDir;\n    }\n\n    resourceManagerWrapper = new ResourceManagerWrapper();\n    addService(resourceManagerWrapper);\n    nodeManagers = new CustomNodeManager[noOfNodeManagers];\n    for(int index = 0; index < noOfNodeManagers; index++) {\n      addService(new NodeManagerWrapper(index));\n      nodeManagers[index] = new CustomNodeManager();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70f91c8322fbffe3a3a897ef20ea19119cac10cd","date":1386170124,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/map-reduce/src/test/org/apache/solr/hadoop/hack/MiniYARNCluster#MiniYARNCluster(String,int,int,int,File).mjava","pathOld":"solr/contrib/solr-mr/src/test/org/apache/solr/hadoop/hack/MiniYARNCluster#MiniYARNCluster(String,int,int,int,File).mjava","sourceNew":"  /**\n   * @param testName name of the test\n   * @param noOfNodeManagers the number of node managers in the cluster\n   * @param numLocalDirs the number of nm-local-dirs per nodemanager\n   * @param numLogDirs the number of nm-log-dirs per nodemanager\n   */\n  public MiniYARNCluster(String testName, int noOfNodeManagers,\n                         int numLocalDirs, int numLogDirs, File testWorkDir) {\n    super(testName.replace(\"$\", \"\"));\n    this.numLocalDirs = numLocalDirs;\n    this.numLogDirs = numLogDirs;\n    String testSubDir = testName.replace(\"$\", \"\");\n    File targetWorkDir = new File(testWorkDir, testSubDir);\n    try {\n      FileContext.getLocalFSFileContext().delete(\n          new Path(targetWorkDir.getAbsolutePath()), true);\n    } catch (Exception e) {\n      LOG.warn(\"COULD NOT CLEANUP\", e);\n      throw new YarnRuntimeException(\"could not cleanup test dir: \"+ e, e);\n    } \n\n    if (Shell.WINDOWS) {\n      // The test working directory can exceed the maximum path length supported\n      // by some Windows APIs and cmd.exe (260 characters).  To work around this,\n      // create a symlink in temporary storage with a much shorter path,\n      // targeting the full path to the test working directory.  Then, use the\n      // symlink as the test working directory.\n      String targetPath = targetWorkDir.getAbsolutePath();\n      File link = new File(System.getProperty(\"java.io.tmpdir\"),\n        String.valueOf(System.currentTimeMillis()));\n      String linkPath = link.getAbsolutePath();\n\n      try {\n        FileContext.getLocalFSFileContext().delete(new Path(linkPath), true);\n      } catch (IOException e) {\n        throw new YarnRuntimeException(\"could not cleanup symlink: \" + linkPath, e);\n      }\n\n      // Guarantee target exists before creating symlink.\n      targetWorkDir.mkdirs();\n\n      ShellCommandExecutor shexec = new ShellCommandExecutor(\n        Shell.getSymlinkCommand(targetPath, linkPath));\n      try {\n        shexec.execute();\n      } catch (IOException e) {\n        throw new YarnRuntimeException(String.format(Locale.ENGLISH,\n          \"failed to create symlink from %s to %s, shell output: %s\", linkPath,\n          targetPath, shexec.getOutput()), e);\n      }\n\n      this.testWorkDir = link;\n    } else {\n      this.testWorkDir = targetWorkDir;\n    }\n\n    resourceManagerWrapper = new ResourceManagerWrapper();\n    addService(resourceManagerWrapper);\n    nodeManagers = new CustomNodeManager[noOfNodeManagers];\n    for(int index = 0; index < noOfNodeManagers; index++) {\n      addService(new NodeManagerWrapper(index));\n      nodeManagers[index] = new CustomNodeManager();\n    }\n  }\n\n","sourceOld":"  /**\n   * @param testName name of the test\n   * @param noOfNodeManagers the number of node managers in the cluster\n   * @param numLocalDirs the number of nm-local-dirs per nodemanager\n   * @param numLogDirs the number of nm-log-dirs per nodemanager\n   */\n  public MiniYARNCluster(String testName, int noOfNodeManagers,\n                         int numLocalDirs, int numLogDirs, File testWorkDir) {\n    super(testName.replace(\"$\", \"\"));\n    this.numLocalDirs = numLocalDirs;\n    this.numLogDirs = numLogDirs;\n    String testSubDir = testName.replace(\"$\", \"\");\n    File targetWorkDir = new File(testWorkDir, testSubDir);\n    try {\n      FileContext.getLocalFSFileContext().delete(\n          new Path(targetWorkDir.getAbsolutePath()), true);\n    } catch (Exception e) {\n      LOG.warn(\"COULD NOT CLEANUP\", e);\n      throw new YarnRuntimeException(\"could not cleanup test dir: \"+ e, e);\n    } \n\n    if (Shell.WINDOWS) {\n      // The test working directory can exceed the maximum path length supported\n      // by some Windows APIs and cmd.exe (260 characters).  To work around this,\n      // create a symlink in temporary storage with a much shorter path,\n      // targeting the full path to the test working directory.  Then, use the\n      // symlink as the test working directory.\n      String targetPath = targetWorkDir.getAbsolutePath();\n      File link = new File(System.getProperty(\"java.io.tmpdir\"),\n        String.valueOf(System.currentTimeMillis()));\n      String linkPath = link.getAbsolutePath();\n\n      try {\n        FileContext.getLocalFSFileContext().delete(new Path(linkPath), true);\n      } catch (IOException e) {\n        throw new YarnRuntimeException(\"could not cleanup symlink: \" + linkPath, e);\n      }\n\n      // Guarantee target exists before creating symlink.\n      targetWorkDir.mkdirs();\n\n      ShellCommandExecutor shexec = new ShellCommandExecutor(\n        Shell.getSymlinkCommand(targetPath, linkPath));\n      try {\n        shexec.execute();\n      } catch (IOException e) {\n        throw new YarnRuntimeException(String.format(Locale.ENGLISH,\n          \"failed to create symlink from %s to %s, shell output: %s\", linkPath,\n          targetPath, shexec.getOutput()), e);\n      }\n\n      this.testWorkDir = link;\n    } else {\n      this.testWorkDir = targetWorkDir;\n    }\n\n    resourceManagerWrapper = new ResourceManagerWrapper();\n    addService(resourceManagerWrapper);\n    nodeManagers = new CustomNodeManager[noOfNodeManagers];\n    for(int index = 0; index < noOfNodeManagers; index++) {\n      addService(new NodeManagerWrapper(index));\n      nodeManagers[index] = new CustomNodeManager();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70f91c8322fbffe3a3a897ef20ea19119cac10cd":["d6e604e9030fb0cabf0c5a85ae6039921a81419c"],"d6e604e9030fb0cabf0c5a85ae6039921a81419c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["70f91c8322fbffe3a3a897ef20ea19119cac10cd"]},"commit2Childs":{"70f91c8322fbffe3a3a897ef20ea19119cac10cd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d6e604e9030fb0cabf0c5a85ae6039921a81419c":["70f91c8322fbffe3a3a897ef20ea19119cac10cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d6e604e9030fb0cabf0c5a85ae6039921a81419c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}