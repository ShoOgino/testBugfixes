{"path":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","commits":[{"id":"dd745d580729e528151b58aeda87ef82f1b95c9b","date":1248369082,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b5756469957918cac40a831acec9cf01c8c2bb3","date":1249167152,"type":5,"author":"Michael Busch","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#incrementToken().mjava","pathOld":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/cjk/CJKTokenizer#next(Token).mjava","sourceNew":"    /**\n     * Returns true for the next token in the stream, or false at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @return false for end of stream, true otherwise\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public boolean incrementToken() throws IOException {\n        /** how many character(s) has been stored in buffer */\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return false;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n          termAtt.setTermBuffer(buffer, 0, length);\n          offsetAtt.setOffset(input.correctOffset(start), input.correctOffset(start+length));\n          typeAtt.setType(TOKEN_TYPE_NAMES[tokenType]);\n          return true;\n        } else if (dataLen == -1) {\n          return false;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns the next token in the stream, or null at EOS.\n     * See http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.html\n     * for detail.\n     *\n     * @param reusableToken a reusable token\n     * @return Token\n     *\n     * @throws java.io.IOException - throw IOException when read error <br>\n     *         happened in the InputStream\n     *\n     */\n    public final Token next(final Token reusableToken) throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        assert reusableToken != null;\n\n        while(true) { // loop until we find a non-empty token\n\n          int length = 0;\n\n          /** the position used to create Token */\n          int start = offset;\n\n          while (true) { // loop until we've found a full token\n            /** current character */\n            char c;\n\n            /** unicode block of current character for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) {\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {\n                  int i = (int) c;\n                  if (i >= 65281 && i <= 65374) {\n                    // convert certain HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN\n                    i = i - 65248;\n                    c = (char) i;\n                  }\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the ASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == DOUBLE_TOKEN_TYPE) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = SINGLE_TOKEN_TYPE;\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, e.g.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = DOUBLE_TOKEN_TYPE;\n                    } else {\n                      if (tokenType == SINGLE_TOKEN_TYPE) {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = DOUBLE_TOKEN_TYPE;\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n      \n        if (length > 0) {\n            return reusableToken.reinit\n                (buffer, 0, length, input.correctOffset(start), input.correctOffset(start+length), TOKEN_TYPE_NAMES[tokenType]);\n        } else if (dataLen == -1) {\n          return null;\n        }\n\n        // Cycle back and try for the next token (don't\n        // return an empty string)\n      }\n    }\n\n","bugFix":null,"bugIntro":["a82fda1447250ff156ff3b862d94a99bf0a3c23c"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"dd745d580729e528151b58aeda87ef82f1b95c9b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9b5756469957918cac40a831acec9cf01c8c2bb3":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9b5756469957918cac40a831acec9cf01c8c2bb3"]},"commit2Childs":{"dd745d580729e528151b58aeda87ef82f1b95c9b":["9b5756469957918cac40a831acec9cf01c8c2bb3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"9b5756469957918cac40a831acec9cf01c8c2bb3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}