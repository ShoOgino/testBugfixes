{"path":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","commits":[{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    if (willRewrite && fst != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now rewrite\");\n      }\n      final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now verify packed FST\");\n      }\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, packed);\n      } else {\n        verifyPruned(inputMode, packed, prune1, prune2);\n      }\n    }\n\n    return fst;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["187781bf2255d5f4f26af103a22628b72461d937"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"49f4d9c4e29f2345e789073801e7945431a23ca3","date":1355344131,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    if (willRewrite && fst != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now rewrite\");\n      }\n      final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now verify packed FST\");\n      }\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, packed);\n      } else {\n        verifyPruned(inputMode, packed, prune1, prune2);\n      }\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    if (willRewrite && fst != null) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now rewrite\");\n      }\n      final FST<T> packed = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: now verify packed FST\");\n      }\n      if (prune1 == 0 && prune2 == 0) {\n        verifyUnPruned(inputMode, packed);\n      } else {\n        verifyPruned(inputMode, packed, prune1, prune2);\n      }\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb8af2aec0a8574cf50cad6939d4475179595eca","date":1357675799,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556c8202987f72dd8458e25e21a82d98fc274979","date":1358008288,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? _TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<T>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d3d365762604952e436b51980101dfc84cc1b3e","date":1396298116,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              null,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = Files.newBufferedWriter(Paths.get(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":["187781bf2255d5f4f26af103a22628b72461d937"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"187781bf2255d5f4f26af103a22628b72461d937","date":1435614848,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      Writer w = Files.newBufferedWriter(Paths.get(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(fst, w, false, false);\n      w.close();\n      System.out.println(\"SAVED out.dot\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":["5ebe14aae60589c9bb6423f3cce02d5f599e1540","f4abec28b874149a7223e32cc7a01704c27790de"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fst.getNodeCount() + \" nodes and \" + fst.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFiles(Collections.singleton(\"fst.bin\"));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFiles(Collections.singleton(\"fst.bin\"));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final boolean willRewrite = random.nextBoolean();\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              willRewrite,\n                                              PackedInts.DEFAULT,\n                                              true,\n                                              15);\n    if (LuceneTestCase.VERBOSE) {\n      if (willRewrite) {\n        System.out.println(\"TEST: packed FST\");\n      } else {\n        System.out.println(\"TEST: non-packed FST\");\n      }\n    }\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null && !willRewrite) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15, true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15, true);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final FSTCompiler<T> fstCompiler = new FSTCompiler.Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4, outputs)\n        .minSuffixCount1(prune1)\n        .minSuffixCount2(prune2)\n        .shouldShareSuffix(prune1==0 && prune2==0)\n        .shouldShareNonSingletonNodes(allowRandomSuffixSharing ? random.nextBoolean() : true)\n        .shareMaxTailLength(allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE)\n        .build();\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final FSTCompiler<Object> fstCompilerObject = (FSTCompiler<Object>) fstCompiler;\n        for(Long value : longValues) {\n          fstCompilerObject.add(pair.input, value);\n        }\n      } else {\n        fstCompiler.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = fstCompiler.compile();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fstCompiler.getNodeCount() + \" nodes and \" + fstCompiler.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = fstCompiler.getNodeCount();\n    arcCount = fstCompiler.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final FSTCompiler<T> fstCompiler = new FSTCompiler.Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4, outputs)\n        .minSuffixCount1(prune1)\n        .minSuffixCount2(prune2)\n        .shouldShareSuffix(prune1==0 && prune2==0)\n        .shouldShareNonSingletonNodes(allowRandomSuffixSharing ? random.nextBoolean() : true)\n        .shareMaxTailLength(allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE)\n        .build();\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final FSTCompiler<Object> fstCompilerObject = (FSTCompiler<Object>) fstCompiler;\n        for(Long value : longValues) {\n          fstCompilerObject.add(pair.input, value);\n        }\n      } else {\n        fstCompiler.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = fstCompiler.compile();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fstCompiler.getNodeCount() + \" nodes and \" + fstCompiler.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = fstCompiler.getNodeCount();\n    arcCount = fstCompiler.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final Builder<T> builder = new Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4,\n                                              prune1, prune2,\n                                              prune1==0 && prune2==0,\n                                              allowRandomSuffixSharing ? random.nextBoolean() : true,\n                                              allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE,\n                                              outputs,\n                                              true,\n                                              15);\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final Builder<Object> builderObject = (Builder<Object>) builder;\n        for(Long value : longValues) {\n          builderObject.add(pair.input, value);\n        }\n      } else {\n        builder.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = builder.finish();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + builder.getNodeCount() + \" nodes and \" + builder.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = builder.getNodeCount();\n    arcCount = builder.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#doTest(int,int,boolean).mjava","sourceNew":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final FSTCompiler<T> fstCompiler = new FSTCompiler.Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4, outputs)\n        .minSuffixCount1(prune1)\n        .minSuffixCount2(prune2)\n        .shouldShareSuffix(prune1==0 && prune2==0)\n        .shouldShareNonSingletonNodes(allowRandomSuffixSharing ? random.nextBoolean() : true)\n        .shareMaxTailLength(allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE)\n        .build();\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final FSTCompiler<Object> fstCompilerObject = (FSTCompiler<Object>) fstCompiler;\n        for(Long value : longValues) {\n          fstCompilerObject.add(pair.input, value);\n        }\n      } else {\n        fstCompiler.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = fstCompiler.compile();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out, out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fstCompiler.getNodeCount() + \" nodes and \" + fstCompiler.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = fstCompiler.getNodeCount();\n    arcCount = fstCompiler.getArcCount();\n\n    return fst;\n  }\n\n","sourceOld":"  FST<T> doTest(int prune1, int prune2, boolean allowRandomSuffixSharing) throws IOException {\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"\\nTEST: prune1=\" + prune1 + \" prune2=\" + prune2);\n    }\n\n    final FSTCompiler<T> fstCompiler = new FSTCompiler.Builder<>(inputMode == 0 ? FST.INPUT_TYPE.BYTE1 : FST.INPUT_TYPE.BYTE4, outputs)\n        .minSuffixCount1(prune1)\n        .minSuffixCount2(prune2)\n        .shouldShareSuffix(prune1==0 && prune2==0)\n        .shouldShareNonSingletonNodes(allowRandomSuffixSharing ? random.nextBoolean() : true)\n        .shareMaxTailLength(allowRandomSuffixSharing ? TestUtil.nextInt(random, 1, 10) : Integer.MAX_VALUE)\n        .build();\n\n    for(InputOutput<T> pair : pairs) {\n      if (pair.output instanceof List) {\n        @SuppressWarnings(\"unchecked\") List<Long> longValues = (List<Long>) pair.output;\n        @SuppressWarnings(\"unchecked\") final FSTCompiler<Object> fstCompilerObject = (FSTCompiler<Object>) fstCompiler;\n        for(Long value : longValues) {\n          fstCompilerObject.add(pair.input, value);\n        }\n      } else {\n        fstCompiler.add(pair.input, pair.output);\n      }\n    }\n    FST<T> fst = fstCompiler.compile();\n\n    if (random.nextBoolean() && fst != null) {\n      IOContext context = LuceneTestCase.newIOContext(random);\n      IndexOutput out = dir.createOutput(\"fst.bin\", context);\n      fst.save(out);\n      out.close();\n      IndexInput in = dir.openInput(\"fst.bin\", context);\n      try {\n        fst = new FST<T>(in, outputs);\n      } finally {\n        in.close();\n        dir.deleteFile(\"fst.bin\");\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE && pairs.size() <= 20 && fst != null) {\n      System.out.println(\"Printing FST as dot file to stdout:\");\n      final Writer w = new OutputStreamWriter(System.out, Charset.defaultCharset());\n      Util.toDot(fst, w, false, false);\n      w.flush();\n      System.out.println(\"END dot file\");\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      if (fst == null) {\n        System.out.println(\"  fst has 0 nodes (fully pruned)\");\n      } else {\n        System.out.println(\"  fst has \" + fstCompiler.getNodeCount() + \" nodes and \" + fstCompiler.getArcCount() + \" arcs\");\n      }\n    }\n\n    if (prune1 == 0 && prune2 == 0) {\n      verifyUnPruned(inputMode, fst);\n    } else {\n      verifyPruned(inputMode, fst, prune1, prune2);\n    }\n\n    nodeCount = fstCompiler.getNodeCount();\n    arcCount = fstCompiler.getArcCount();\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["187781bf2255d5f4f26af103a22628b72461d937"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["5ebe14aae60589c9bb6423f3cce02d5f599e1540","49f4d9c4e29f2345e789073801e7945431a23ca3"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"fb8af2aec0a8574cf50cad6939d4475179595eca":["49f4d9c4e29f2345e789073801e7945431a23ca3"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"187781bf2255d5f4f26af103a22628b72461d937":["f4abec28b874149a7223e32cc7a01704c27790de"],"9d3d365762604952e436b51980101dfc84cc1b3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["59a1204a92958bea883656169000a87a6c55c2d0","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fb8af2aec0a8574cf50cad6939d4475179595eca"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9d3d365762604952e436b51980101dfc84cc1b3e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["556c8202987f72dd8458e25e21a82d98fc274979"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"556c8202987f72dd8458e25e21a82d98fc274979":["fb8af2aec0a8574cf50cad6939d4475179595eca"],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["6244579a467d5f2673ac98265d74bddbea1a8114"],"f4abec28b874149a7223e32cc7a01704c27790de":["f838187609fee3a1afa5f162f93c796046242c84"],"f838187609fee3a1afa5f162f93c796046242c84":["9d3d365762604952e436b51980101dfc84cc1b3e"],"59a1204a92958bea883656169000a87a6c55c2d0":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["59a1204a92958bea883656169000a87a6c55c2d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["199dfa410f1fdbfd3294106b04096cce5ed34b21","6bfe104fc023fadc9e709f8d17403d2cc61133fe","6244579a467d5f2673ac98265d74bddbea1a8114"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb8af2aec0a8574cf50cad6939d4475179595eca":["4e6354dd7c71fe122926fc53d7d29f715b1283db","556c8202987f72dd8458e25e21a82d98fc274979"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"187781bf2255d5f4f26af103a22628b72461d937":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"9d3d365762604952e436b51980101dfc84cc1b3e":["5eb2511ababf862ea11e10761c70ee560cd84510","f838187609fee3a1afa5f162f93c796046242c84"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","49f4d9c4e29f2345e789073801e7945431a23ca3"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fb8af2aec0a8574cf50cad6939d4475179595eca"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["9d3d365762604952e436b51980101dfc84cc1b3e","5eb2511ababf862ea11e10761c70ee560cd84510"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"556c8202987f72dd8458e25e21a82d98fc274979":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","ae67e1f82a53594208ca929f382ee861dad3d7a8"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["59a1204a92958bea883656169000a87a6c55c2d0"],"f4abec28b874149a7223e32cc7a01704c27790de":["187781bf2255d5f4f26af103a22628b72461d937"],"f838187609fee3a1afa5f162f93c796046242c84":["f4abec28b874149a7223e32cc7a01704c27790de"],"59a1204a92958bea883656169000a87a6c55c2d0":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["99f06f5dd087b1829e7b4139e4d014c786b92572","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","199dfa410f1fdbfd3294106b04096cce5ed34b21","8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}