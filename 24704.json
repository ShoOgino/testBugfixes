{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","commits":[{"id":"2fe4b12f0dcf02b1690143f2ad02d8f89625eb36","date":1349174553,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxIndexOptions=\" + maxIndexOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    Bits liveDocs;\n    Map<String,Map<BytesRef,List<Posting>>> fieldsToUse;\n    if (options.contains(Option.LIVE_DOCS) && random().nextBoolean()) {\n      liveDocs = globalLiveDocs;\n      fieldsToUse = fieldsLive;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      fieldsToUse = fields;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    assertEquals(fields.get(field).get(term).size(), termsEnum.docFreq());\n\n    // NOTE: can be empty list if we are using liveDocs:\n    List<Posting> expected = fieldsToUse.get(field).get(term);\n    \n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxIndexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.size() > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.size()-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.size() + \")\");\n      }\n    } else {\n      stopAt = expected.size();\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.size() < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.size()/3));\n    int skipInc = expected.size()/numSkips;\n    int skipDocInc = (1+maxDocID)/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    int nextPosting = 0;\n    while (nextPosting <= stopAt) {\n      if (nextPosting == stopAt) {\n        if (stopAt == expected.size()) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      Posting posting;\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (nextPosting < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          nextPosting = _TestUtil.nextInt(random(), nextPosting, nextPosting+skipInc);\n        } else {\n          // Pick random target (might not exist):\n          Posting target = new Posting();\n          target.docID = _TestUtil.nextInt(random(), expected.get(nextPosting).docID, expected.get(nextPosting).docID+skipDocInc);\n          targetDocID = target.docID;\n          int loc = Collections.binarySearch(expected.subList(nextPosting, expected.size()), target);\n          if (loc < 0) {\n            loc = -loc-1;\n          }\n          nextPosting = nextPosting + loc;\n        }\n\n        if (nextPosting >= stopAt) {\n          int target = random().nextBoolean() ? (maxDocID+1) : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          posting = expected.get(nextPosting++);\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : posting.docID);\n          assertEquals(\"docID is wrong\", posting.docID, docID);\n        }\n      } else {\n        posting = expected.get(nextPosting++);\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + posting.docID + \" (\" + nextPosting + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", posting.docID, docID);\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + posting.positions.size());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", posting.positions.size(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          Position position = posting.positions.get(i);\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + position.position);\n          }\n          assertEquals(\"position is wrong\", position.position, docsAndPositionsEnum.nextPosition());\n\n          // TODO sometimes don't pull the payload even\n          // though we pulled the position\n\n          if (doCheckPayloads) {\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n              if (position.payload == null || position.payload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", position.payload.length, payload.length);\n                for(int byteUpto=0;byteUpto<position.payload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               position.payload[byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (position.payload == null ? 0 : position.payload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + position.startOffset + \" endOffset=\" + position.endOffset);\n              }\n              assertEquals(\"startOffset is wrong\", position.startOffset, docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", position.endOffset, docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : 0);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af527d067afb6ca5bd58afc7b9a5fbc0f80979af","date":1366034882,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertTrue(\"inital docID should be -1 or NO_MORE_DOCS: \" + docsEnum, initialDocID == -1 || initialDocID == DocsEnum.NO_MORE_DOCS);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1744e62c7bb40f7a950b360af6371e5d89a1c112","date":1375122209,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : _TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq/3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = _TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = _TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cdf9cc6702d60334a616bd7db3ae91501d1dce7","date":1405858112,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term),\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.FLAG_POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FLAG_FREQS : PostingsEnum.FLAG_NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.FLAG_POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    DocsEnum prevDocsEnum = null;\n\n    DocsEnum docsEnum;\n    DocsAndPositionsEnum docsAndPositionsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n        }\n\n        int flags = 0;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsAndPositionsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n        docsEnum = threadState.reuseDocsAndPositionsEnum;\n        docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevDocsEnum = threadState.reuseDocsEnum;\n        }\n        threadState.reuseDocsEnum = termsEnum.docs(liveDocs, prevDocsEnum, doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);\n        docsEnum = threadState.reuseDocsEnum;\n        docsAndPositionsEnum = null;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevDocsEnum = threadState.reuseDocsAndPositionsEnum;\n      }\n\n      int flags = 0;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= DocsAndPositionsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsAndPositionsEnum flags=\" + flags);\n      }\n\n      threadState.reuseDocsAndPositionsEnum = termsEnum.docsAndPositions(liveDocs, (DocsAndPositionsEnum) prevDocsEnum, flags);\n      docsEnum = threadState.reuseDocsAndPositionsEnum;\n      docsAndPositionsEnum = threadState.reuseDocsAndPositionsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", docsEnum);\n    int initialDocID = docsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + docsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevDocsEnum == null) {\n        System.out.println(\"  got enum=\" + docsEnum);\n      } else if (prevDocsEnum == docsEnum) {\n        System.out.println(\"  got reuse enum=\" + docsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + docsEnum + \" (reuse of \" + prevDocsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", DocsEnum.NO_MORE_DOCS, docsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + docsEnum.docID());\n            }\n          }\n          int docID = docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = docsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == DocsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = docsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = docsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, docsAndPositionsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", docsAndPositionsEnum.getPayload());\n              } else {\n                BytesRef payload = docsAndPositionsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, docsAndPositionsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), docsAndPositionsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), docsAndPositionsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, docsAndPositionsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, docsAndPositionsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.FLAG_POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.FLAG_OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.FLAG_PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FLAG_FREQS : PostingsEnum.FLAG_NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.FLAG_POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.FLAG_OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.FLAG_PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random.nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  use liveDocs: \" + globalLiveDocs.length());\n      }\n    } else {\n      liveDocs = null;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            globalLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomPostingsTester#verifyEnum(Random,ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase#verifyEnum(ThreadState,String,BytesRef,TermsEnum,IndexOptions,IndexOptions,EnumSet[Option],boolean).mjava","sourceNew":"  private void verifyEnum(Random random,\n                          ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random.nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  use liveDocs: \" + globalLiveDocs.length());\n      }\n    } else {\n      liveDocs = null;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            globalLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random.nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random.nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random.nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random.nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random.nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random.nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (LuceneTestCase.VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random.nextInt(10) == 7) {\n      stopAt = random.nextInt(expected.docFreq-1);\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random.nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random, 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random.nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random.nextDouble();\n\n    if (LuceneTestCase.VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random.nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random.nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random, 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random, 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random.nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random.nextDouble() <= freqAskChance) {\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random.nextInt(5) == 1) {\n          numPosToConsume = random.nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random.nextDouble() <= payloadCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random.nextDouble() <= offsetCheckChance) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verifyEnum(ThreadState threadState,\n                          String field,\n                          BytesRef term,\n                          TermsEnum termsEnum,\n\n                          // Maximum options (docs/freqs/positions/offsets) to test:\n                          IndexOptions maxTestOptions,\n\n                          IndexOptions maxIndexOptions,\n\n                          EnumSet<Option> options,\n                          boolean alwaysTestMax) throws IOException {\n        \n    if (VERBOSE) {\n      System.out.println(\"  verifyEnum: options=\" + options + \" maxTestOptions=\" + maxTestOptions);\n    }\n\n    // Make sure TermsEnum really is positioned on the\n    // expected term:\n    assertEquals(term, termsEnum.term());\n\n    // 50% of the time time pass liveDocs:\n    boolean useLiveDocs = options.contains(Option.LIVE_DOCS) && random().nextBoolean();\n    Bits liveDocs;\n    if (useLiveDocs) {\n      liveDocs = globalLiveDocs;\n      if (VERBOSE) {\n        System.out.println(\"  use liveDocs\");\n      }\n    } else {\n      liveDocs = null;\n      if (VERBOSE) {\n        System.out.println(\"  no liveDocs\");\n      }\n    }\n\n    FieldInfo fieldInfo = currentFieldInfos.fieldInfo(field);\n\n    // NOTE: can be empty list if we are using liveDocs:\n    SeedPostings expected = getSeedPostings(term.utf8ToString(), \n                                            fields.get(field).get(term).seed,\n                                            useLiveDocs,\n                                            maxIndexOptions,\n                                            true);\n    assertEquals(expected.docFreq, termsEnum.docFreq());\n\n    boolean allowFreqs = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;\n    boolean doCheckFreqs = allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;\n    boolean doCheckPositions = allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean allowOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 &&\n      maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;\n    boolean doCheckOffsets = allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    boolean doCheckPayloads = options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads() && (alwaysTestMax || random().nextInt(3) <= 2);\n\n    PostingsEnum prevPostingsEnum = null;\n\n    PostingsEnum postingsEnum;\n\n    if (!doCheckPositions) {\n      if (allowPositions && random().nextInt(10) == 7) {\n        // 10% of the time, even though we will not check positions, pull a DocsAndPositions enum\n        \n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n\n        int flags = PostingsEnum.POSITIONS;\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.OFFSETS;\n        }\n        if (alwaysTestMax || random().nextBoolean()) {\n          flags |= PostingsEnum.PAYLOADS;\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum (but we won't check positions) flags=\" + flags);\n        }\n\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n        postingsEnum = threadState.reusePostingsEnum;\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  get DocsEnum\");\n        }\n        if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n          prevPostingsEnum = threadState.reusePostingsEnum;\n        }\n        threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, doCheckFreqs ? PostingsEnum.FREQS : PostingsEnum.NONE);\n        postingsEnum = threadState.reusePostingsEnum;\n      }\n    } else {\n      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {\n        prevPostingsEnum = threadState.reusePostingsEnum;\n      }\n\n      int flags = PostingsEnum.POSITIONS;\n      if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {\n        flags |= PostingsEnum.OFFSETS;\n      }\n      if (alwaysTestMax || doCheckPayloads|| random().nextInt(3) == 1) {\n        flags |= PostingsEnum.PAYLOADS;\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  get DocsEnum flags=\" + flags);\n      }\n\n      threadState.reusePostingsEnum = termsEnum.postings(liveDocs, prevPostingsEnum, flags);\n      postingsEnum = threadState.reusePostingsEnum;\n    }\n\n    assertNotNull(\"null DocsEnum\", postingsEnum);\n    int initialDocID = postingsEnum.docID();\n    assertEquals(\"inital docID should be -1\" + postingsEnum, -1, initialDocID);\n\n    if (VERBOSE) {\n      if (prevPostingsEnum == null) {\n        System.out.println(\"  got enum=\" + postingsEnum);\n      } else if (prevPostingsEnum == postingsEnum) {\n        System.out.println(\"  got reuse enum=\" + postingsEnum);\n      } else {\n        System.out.println(\"  got enum=\" + postingsEnum + \" (reuse of \" + prevPostingsEnum + \" failed)\");\n      }\n    }\n\n    // 10% of the time don't consume all docs:\n    int stopAt;\n    if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {\n      stopAt = random().nextInt(expected.docFreq-1);\n      if (VERBOSE) {\n        System.out.println(\"  will not consume all docs (\" + stopAt + \" vs \" + expected.docFreq + \")\");\n      }\n    } else {\n      stopAt = expected.docFreq;\n      if (VERBOSE) {\n        System.out.println(\"  consume all docs\");\n      }\n    }\n\n    double skipChance = alwaysTestMax ? 0.5 : random().nextDouble();\n    int numSkips = expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(), 1, Math.min(20, expected.docFreq / 3));\n    int skipInc = expected.docFreq/numSkips;\n    int skipDocInc = maxDoc/numSkips;\n\n    // Sometimes do 100% skipping:\n    boolean doAllSkipping = options.contains(Option.SKIPPING) && random().nextInt(7) == 1;\n\n    double freqAskChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double payloadCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n    double offsetCheckChance = alwaysTestMax ? 1.0 : random().nextDouble();\n\n    if (VERBOSE) {\n      if (options.contains(Option.SKIPPING)) {\n        System.out.println(\"  skipChance=\" + skipChance + \" numSkips=\" + numSkips);\n      } else {\n        System.out.println(\"  no skipping\");\n      }\n      if (doCheckFreqs) {\n        System.out.println(\"  freqAskChance=\" + freqAskChance);\n      }\n      if (doCheckPayloads) {\n        System.out.println(\"  payloadCheckChance=\" + payloadCheckChance);\n      }\n      if (doCheckOffsets) {\n        System.out.println(\"  offsetCheckChance=\" + offsetCheckChance);\n      }\n    }\n\n    while (expected.upto <= stopAt) {\n      if (expected.upto == stopAt) {\n        if (stopAt == expected.docFreq) {\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.nextDoc());\n\n          // Common bug is to forget to set this.doc=NO_MORE_DOCS in the enum!:\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.docID());\n        }\n        break;\n      }\n\n      if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {\n        int targetDocID = -1;\n        if (expected.upto < stopAt && random().nextBoolean()) {\n          // Pick target we know exists:\n          final int skipCount = TestUtil.nextInt(random(), 1, skipInc);\n          for(int skip=0;skip<skipCount;skip++) {\n            if (expected.nextDoc() == PostingsEnum.NO_MORE_DOCS) {\n              break;\n            }\n          }\n        } else {\n          // Pick random target (might not exist):\n          final int skipDocIDs = TestUtil.nextInt(random(), 1, skipDocInc);\n          if (skipDocIDs > 0) {\n            targetDocID = expected.docID() + skipDocIDs;\n            expected.advance(targetDocID);\n          }\n        }\n\n        if (expected.upto >= stopAt) {\n          int target = random().nextBoolean() ? maxDoc : PostingsEnum.NO_MORE_DOCS;\n          if (VERBOSE) {\n            System.out.println(\"  now advance to end (target=\" + target + \")\");\n          }\n          assertEquals(\"DocsEnum should have ended but didn't\", PostingsEnum.NO_MORE_DOCS, postingsEnum.advance(target));\n          break;\n        } else {\n          if (VERBOSE) {\n            if (targetDocID != -1) {\n              System.out.println(\"  now advance to random target=\" + targetDocID + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            } else {\n              System.out.println(\"  now advance to known-exists target=\" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \") current=\" + postingsEnum.docID());\n            }\n          }\n          int docID = postingsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());\n          assertEquals(\"docID is wrong\", expected.docID(), docID);\n        }\n      } else {\n        expected.nextDoc();\n        if (VERBOSE) {\n          System.out.println(\"  now nextDoc to \" + expected.docID() + \" (\" + expected.upto + \" of \" + stopAt + \")\");\n        }\n        int docID = postingsEnum.nextDoc();\n        assertEquals(\"docID is wrong\", expected.docID(), docID);\n        if (docID == PostingsEnum.NO_MORE_DOCS) {\n          break;\n        }\n      }\n\n      if (doCheckFreqs && random().nextDouble() <= freqAskChance) {\n        if (VERBOSE) {\n          System.out.println(\"    now freq()=\" + expected.freq());\n        }\n        int freq = postingsEnum.freq();\n        assertEquals(\"freq is wrong\", expected.freq(), freq);\n      }\n\n      if (doCheckPositions) {\n        int freq = postingsEnum.freq();\n        int numPosToConsume;\n        if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {\n          numPosToConsume = random().nextInt(freq);\n        } else {\n          numPosToConsume = freq;\n        }\n\n        for(int i=0;i<numPosToConsume;i++) {\n          int pos = expected.nextPosition();\n          if (VERBOSE) {\n            System.out.println(\"    now nextPosition to \" + pos);\n          }\n          assertEquals(\"position is wrong\", pos, postingsEnum.nextPosition());\n\n          if (doCheckPayloads) {\n            BytesRef expectedPayload = expected.getPayload();\n            if (random().nextDouble() <= payloadCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check expectedPayload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n              if (expectedPayload == null || expectedPayload.length == 0) {\n                assertNull(\"should not have payload\", postingsEnum.getPayload());\n              } else {\n                BytesRef payload = postingsEnum.getPayload();\n                assertNotNull(\"should have payload but doesn't\", payload);\n\n                assertEquals(\"payload length is wrong\", expectedPayload.length, payload.length);\n                for(int byteUpto=0;byteUpto<expectedPayload.length;byteUpto++) {\n                  assertEquals(\"payload bytes are wrong\",\n                               expectedPayload.bytes[expectedPayload.offset + byteUpto],\n                               payload.bytes[payload.offset+byteUpto]);\n                }\n                \n                // make a deep copy\n                payload = BytesRef.deepCopyOf(payload);\n                assertEquals(\"2nd call to getPayload returns something different!\", payload, postingsEnum.getPayload());\n              }\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check payload length=\" + (expectedPayload == null ? 0 : expectedPayload.length));\n              }\n            }\n          }\n\n          if (doCheckOffsets) {\n            if (random().nextDouble() <= offsetCheckChance) {\n              if (VERBOSE) {\n                System.out.println(\"      now check offsets: startOff=\" + expected.startOffset() + \" endOffset=\" + expected.endOffset());\n              }\n              assertEquals(\"startOffset is wrong\", expected.startOffset(), postingsEnum.startOffset());\n              assertEquals(\"endOffset is wrong\", expected.endOffset(), postingsEnum.endOffset());\n            } else {\n              if (VERBOSE) {\n                System.out.println(\"      skip check offsets\");\n              }\n            }\n          } else if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {\n            if (VERBOSE) {\n              System.out.println(\"      now check offsets are -1\");\n            }\n            assertEquals(\"startOffset isn't -1\", -1, postingsEnum.startOffset());\n            assertEquals(\"endOffset isn't -1\", -1, postingsEnum.endOffset());\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["2fe4b12f0dcf02b1690143f2ad02d8f89625eb36","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"af527d067afb6ca5bd58afc7b9a5fbc0f80979af":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"1744e62c7bb40f7a950b360af6371e5d89a1c112":["af527d067afb6ca5bd58afc7b9a5fbc0f80979af"],"6613659748fe4411a7dcf85266e55db1f95f7315":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"51f5280f31484820499077f41fcdfe92d527d9dc":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["2fe4b12f0dcf02b1690143f2ad02d8f89625eb36"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["1744e62c7bb40f7a950b360af6371e5d89a1c112"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","3e8715d826e588419327562287d5d6a8040d63d6"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["af527d067afb6ca5bd58afc7b9a5fbc0f80979af"],"3e8715d826e588419327562287d5d6a8040d63d6":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3e8715d826e588419327562287d5d6a8040d63d6"],"2fe4b12f0dcf02b1690143f2ad02d8f89625eb36":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0cdf9cc6702d60334a616bd7db3ae91501d1dce7":["51f5280f31484820499077f41fcdfe92d527d9dc"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"af527d067afb6ca5bd58afc7b9a5fbc0f80979af":["1744e62c7bb40f7a950b360af6371e5d89a1c112","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"1744e62c7bb40f7a950b360af6371e5d89a1c112":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"6613659748fe4411a7dcf85266e55db1f95f7315":["0cdf9cc6702d60334a616bd7db3ae91501d1dce7"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","af527d067afb6ca5bd58afc7b9a5fbc0f80979af"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2fe4b12f0dcf02b1690143f2ad02d8f89625eb36"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2fe4b12f0dcf02b1690143f2ad02d8f89625eb36":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d2638f781be724518ff6c2263d14a48cf6e68017","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}