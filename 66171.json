{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","commits":[{"id":"6f26f74e4969851a019d28f10315cb1c77786f22","date":1400539241,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbf528c0e702c5cbd1339b2da1cdc823fd44a925","date":1427230904,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(\"name\");\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n      Map previousMDCContext = MDC.getCopyOfContextMap();\n      MDCUtils.setCollection(collectionName);\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n        MDCUtils.cleanupMDC(previousMDCContext);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b34744cdee27b92844fd3b14211ae16ea1d50413","date":1434566770,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, null);\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, null);\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31","date":1435517625,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    public void run() {\n      String statsName = messageHandler.getTimerName(operation);\n      final TimerContext timerContext = stats.time(statsName);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String taskKey = messageHandler.getTaskKey(message);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = messageHandler.processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats(statsName);\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(messageHandler, head.getId(), asyncId, taskKey);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(messageHandler.getName() + \": Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["f222f4f2bda21ffd6b39b3362b2412e98e4d5e31"],"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31":["b34744cdee27b92844fd3b14211ae16ea1d50413"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6f26f74e4969851a019d28f10315cb1c77786f22","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"b34744cdee27b92844fd3b14211ae16ea1d50413":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6f26f74e4969851a019d28f10315cb1c77786f22"],"6f26f74e4969851a019d28f10315cb1c77786f22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["6f26f74e4969851a019d28f10315cb1c77786f22"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f222f4f2bda21ffd6b39b3362b2412e98e4d5e31":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"b34744cdee27b92844fd3b14211ae16ea1d50413":["f222f4f2bda21ffd6b39b3362b2412e98e4d5e31"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7605579001505896d48b07160075a5c8b8e128e","6f26f74e4969851a019d28f10315cb1c77786f22"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"b7605579001505896d48b07160075a5c8b8e128e":[],"6f26f74e4969851a019d28f10315cb1c77786f22":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b7605579001505896d48b07160075a5c8b8e128e","dbf528c0e702c5cbd1339b2da1cdc823fd44a925"],"dbf528c0e702c5cbd1339b2da1cdc823fd44a925":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b34744cdee27b92844fd3b14211ae16ea1d50413"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","b7605579001505896d48b07160075a5c8b8e128e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}