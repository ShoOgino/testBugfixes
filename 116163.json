{"path":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","commits":[{"id":"1833c624d42634c14299628650e0a70626349a71","date":1204207883,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @return\n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or <!v=value> forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b7074ac9bb3423ad148c7269a478bf1f7ef14030","efff98a8632f3c2f5b05f961e22a67f122db81e0","efff98a8632f3c2f5b05f961e22a67f122db81e0","efff98a8632f3c2f5b05f961e22a67f122db81e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ed9977f1cdec244969bc4f5054a6041028238bf","date":1209503245,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @return\n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @return\n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or <!v=value> forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"750ae94a53c48546afa6bcf9b172428e09933da0","date":1216334670,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @return\n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7074ac9bb3423ad148c7269a478bf1f7ef14030","date":1236285231,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      sp.pos += param.length();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).parse();\n    }\n    else {\n      int start = sp.pos;\n      int end = sp.pos;\n      String v = sp.val; \n  \n      String qs = v.substring(start);\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(0, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":["1833c624d42634c14299628650e0a70626349a71"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","pathOld":"src/java/org/apache/solr/search/FunctionQParser#parseNestedQuery().mjava","sourceNew":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","sourceOld":"  /**\n   * TODO: Doc\n   * \n   * @throws ParseException\n   */\n  public Query parseNestedQuery() throws ParseException {\n    Query nestedQuery;\n    \n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n  \n      String qs = v;\n      HashMap nestedLocalParams = new HashMap<String,String>();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n  \n      QParser sub;\n  \n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          // value specified directly in local params... so the end of the\n          // query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          // value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          // int subEnd = sub.findEnd(')');\n          // TODO.. implement functions to find the end of a nested query\n          throw new ParseException(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new ParseException(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n  \n      sp.pos += end-start;  // advance past nested query\n      nestedQuery = sub.getQuery();\n    }\n    consumeArgumentDelimiter();\n    \n    return nestedQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b7074ac9bb3423ad148c7269a478bf1f7ef14030":["750ae94a53c48546afa6bcf9b172428e09933da0"],"750ae94a53c48546afa6bcf9b172428e09933da0":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"0ed9977f1cdec244969bc4f5054a6041028238bf":["1833c624d42634c14299628650e0a70626349a71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["b7074ac9bb3423ad148c7269a478bf1f7ef14030"],"1833c624d42634c14299628650e0a70626349a71":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b7074ac9bb3423ad148c7269a478bf1f7ef14030":["ad94625fb8d088209f46650c8097196fec67f00c"],"750ae94a53c48546afa6bcf9b172428e09933da0":["b7074ac9bb3423ad148c7269a478bf1f7ef14030"],"0ed9977f1cdec244969bc4f5054a6041028238bf":["750ae94a53c48546afa6bcf9b172428e09933da0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["1833c624d42634c14299628650e0a70626349a71"],"1833c624d42634c14299628650e0a70626349a71":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}