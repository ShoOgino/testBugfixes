{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testUpdateProcessorsRunOnlyOnce(String).mjava","commits":[{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testUpdateProcessorsRunOnlyOnce(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expects a RegexReplaceProcessorFactories in the chain which will\n   * \"double up\" the values in two (stored) string fields.\n   * <p>\n   * If the values are \"double-doubled\" or \"not-doubled\" then we know \n   * the processor was not run the appropriate number of times\n   * </p>\n   */\n  private void testUpdateProcessorsRunOnlyOnce(final String chain) throws Exception {\n\n    final String fieldA = \"regex_dup_A_s\";\n    final String fieldB = \"regex_dup_B_s\";\n    final String val = \"x\";\n    final String expected = \"x_x\";\n    final ModifiableSolrParams updateParams = new ModifiableSolrParams();\n    updateParams.add(UpdateParams.UPDATE_CHAIN, chain);\n    \n    final int numLoops = atLeast(50);\n    \n    for (int i = 1; i < numLoops; i++) {\n      // add doc to random client\n      SolrServer updateClient = clients.get(random().nextInt(clients.size()));\n      SolrInputDocument doc = new SolrInputDocument();\n      addFields(doc, id, i, fieldA, val, fieldB, val);\n      UpdateResponse ures = add(updateClient, updateParams, doc);\n      assertEquals(chain + \": update failed\", 0, ures.getStatus());\n      ures = updateClient.commit();\n      assertEquals(chain + \": commit failed\", 0, ures.getStatus());\n    }\n\n    // query for each doc, and check both fields to ensure the value is correct\n    for (int i = 1; i < numLoops; i++) {\n      final String query = id + \":\" + i;\n      QueryResponse qres = queryServer(new SolrQuery(query));\n      assertEquals(chain + \": query failed: \" + query, \n                   0, qres.getStatus());\n      assertEquals(chain + \": didn't find correct # docs with query: \" + query,\n                   1, qres.getResults().getNumFound());\n      SolrDocument doc = qres.getResults().get(0);\n\n      for (String field : new String[] {fieldA, fieldB}) { \n        assertEquals(chain + \": doc#\" + i+ \" has wrong value for \" + field,\n                     expected, doc.getFirstValue(field));\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testUpdateProcessorsRunOnlyOnce(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testUpdateProcessorsRunOnlyOnce(String).mjava","sourceNew":"  /**\n   * Expects a RegexReplaceProcessorFactories in the chain which will\n   * \"double up\" the values in two (stored) string fields.\n   * <p>\n   * If the values are \"double-doubled\" or \"not-doubled\" then we know \n   * the processor was not run the appropriate number of times\n   * </p>\n   */\n  private void testUpdateProcessorsRunOnlyOnce(final String chain) throws Exception {\n\n    final String fieldA = \"regex_dup_A_s\";\n    final String fieldB = \"regex_dup_B_s\";\n    final String val = \"x\";\n    final String expected = \"x_x\";\n    final ModifiableSolrParams updateParams = new ModifiableSolrParams();\n    updateParams.add(UpdateParams.UPDATE_CHAIN, chain);\n    \n    final int numLoops = atLeast(50);\n    \n    for (int i = 1; i < numLoops; i++) {\n      // add doc to random client\n      SolrClient updateClient = clients.get(random().nextInt(clients.size()));\n      SolrInputDocument doc = new SolrInputDocument();\n      addFields(doc, id, i, fieldA, val, fieldB, val);\n      UpdateResponse ures = add(updateClient, updateParams, doc);\n      assertEquals(chain + \": update failed\", 0, ures.getStatus());\n      ures = updateClient.commit();\n      assertEquals(chain + \": commit failed\", 0, ures.getStatus());\n    }\n\n    // query for each doc, and check both fields to ensure the value is correct\n    for (int i = 1; i < numLoops; i++) {\n      final String query = id + \":\" + i;\n      QueryResponse qres = queryServer(new SolrQuery(query));\n      assertEquals(chain + \": query failed: \" + query, \n                   0, qres.getStatus());\n      assertEquals(chain + \": didn't find correct # docs with query: \" + query,\n                   1, qres.getResults().getNumFound());\n      SolrDocument doc = qres.getResults().get(0);\n\n      for (String field : new String[] {fieldA, fieldB}) { \n        assertEquals(chain + \": doc#\" + i+ \" has wrong value for \" + field,\n                     expected, doc.getFirstValue(field));\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Expects a RegexReplaceProcessorFactories in the chain which will\n   * \"double up\" the values in two (stored) string fields.\n   * <p>\n   * If the values are \"double-doubled\" or \"not-doubled\" then we know \n   * the processor was not run the appropriate number of times\n   * </p>\n   */\n  private void testUpdateProcessorsRunOnlyOnce(final String chain) throws Exception {\n\n    final String fieldA = \"regex_dup_A_s\";\n    final String fieldB = \"regex_dup_B_s\";\n    final String val = \"x\";\n    final String expected = \"x_x\";\n    final ModifiableSolrParams updateParams = new ModifiableSolrParams();\n    updateParams.add(UpdateParams.UPDATE_CHAIN, chain);\n    \n    final int numLoops = atLeast(50);\n    \n    for (int i = 1; i < numLoops; i++) {\n      // add doc to random client\n      SolrServer updateClient = clients.get(random().nextInt(clients.size()));\n      SolrInputDocument doc = new SolrInputDocument();\n      addFields(doc, id, i, fieldA, val, fieldB, val);\n      UpdateResponse ures = add(updateClient, updateParams, doc);\n      assertEquals(chain + \": update failed\", 0, ures.getStatus());\n      ures = updateClient.commit();\n      assertEquals(chain + \": commit failed\", 0, ures.getStatus());\n    }\n\n    // query for each doc, and check both fields to ensure the value is correct\n    for (int i = 1; i < numLoops; i++) {\n      final String query = id + \":\" + i;\n      QueryResponse qres = queryServer(new SolrQuery(query));\n      assertEquals(chain + \": query failed: \" + query, \n                   0, qres.getStatus());\n      assertEquals(chain + \": didn't find correct # docs with query: \" + query,\n                   1, qres.getResults().getNumFound());\n      SolrDocument doc = qres.getResults().get(0);\n\n      for (String field : new String[] {fieldA, fieldB}) { \n        assertEquals(chain + \": doc#\" + i+ \" has wrong value for \" + field,\n                     expected, doc.getFirstValue(field));\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}