{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\" + c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 73; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(73, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":["9f100e4a037a938ee4b027674f1ca80fc208badf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1778938cb7fb298e6e07a43e2d5acaf552d61518","date":1559609435,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    Path zkDir = createTempDir(\"zkData\");\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\" + c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 73; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(73, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\" + c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 73; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(73, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    Path zkDir = createTempDir(\"zkData\");\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\" + c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 73; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(73, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"3f504512a03d978990cbff30db0522b354e846db":["1778938cb7fb298e6e07a43e2d5acaf552d61518"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["1778938cb7fb298e6e07a43e2d5acaf552d61518"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["3f504512a03d978990cbff30db0522b354e846db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}