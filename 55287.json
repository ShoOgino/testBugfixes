{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","commits":[{"id":"3dc71a6ca063b508a28bf5b68fedf25a945572a0","date":1462433813,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Convert travel plane to a sided plane\n      final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n      // Convert testPoint plane to a sided plane\n      final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n      assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n      // Figure out which of the above/below planes are inside vs. outside.  To do this,\n      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n      // borders.\n      final Plane travelAbovePlane = new Plane(travelPlane, true);\n      final Plane travelBelowPlane = new Plane(travelPlane, false);\n      \n      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert aboveAbove != null : \"Above + above should not be coplanar\";\n      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert aboveBelow != null : \"Above + below should not be coplanar\";\n      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n      assert belowBelow != null : \"Below + below should not be coplanar\";\n      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n      assert belowAbove != null : \"Below + above should not be coplanar\";\n\n      assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n      \n      final GeoPoint insideIntersection;\n      if (aboveAbove.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = aboveAbove[0];\n      } else if (aboveBelow.length > 0) {\n        travelInsidePlane = travelAbovePlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelBelowPlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = aboveBelow[0];\n      } else if (belowBelow.length > 0) {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointBelowPlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointAbovePlane;\n        insideIntersection = belowBelow[0];\n      } else {\n        travelInsidePlane = travelBelowPlane;\n        testPointInsidePlane = testPointAbovePlane;\n        travelOutsidePlane = travelAbovePlane;\n        testPointOutsidePlane = testPointBelowPlane;\n        insideIntersection = belowAbove[0];\n      }\n      \n      insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n      insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,double,double,double,GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","sourceNew":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final double thePointX, final double thePointY, final double thePointZ, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePointX = thePointX;\n      this.thePointY = thePointY;\n      this.thePointZ = thePointZ;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !intersectionPoint.isNumericallyIdentical(thePointX, thePointY, thePointZ) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePointX, thePointY, thePointZ);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#DualCrossingEdgeIterator(Plane,Plane,Plane,Plane,Vector,GeoPoint).mjava","sourceNew":null,"sourceOld":"    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,\n      final Plane travelPlane, final Vector thePoint, final GeoPoint intersectionPoint) {\n      this.testPointPlane = testPointPlane;\n      this.testPointAbovePlane = testPointAbovePlane;\n      this.testPointBelowPlane = testPointBelowPlane;\n      this.travelPlane = travelPlane;\n      this.thePoint = thePoint;\n      this.intersectionPoint = intersectionPoint;\n      \n      //System.err.println(\"Intersection point = \"+intersectionPoint);\n        \n      assert travelPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on travel plane\";\n      assert testPointPlane.evaluateIsZero(intersectionPoint) : \"intersection point must be on test point plane\";\n        \n      assert !testPoint.isNumericallyIdentical(intersectionPoint) : \"test point is the same as intersection point\";\n      assert !thePoint.isNumericallyIdentical(intersectionPoint) : \"check point is same is intersection point\";\n\n      this.testPointCutoffPlane = new SidedPlane(intersectionPoint, testPointPlane, testPoint);\n      this.checkPointCutoffPlane = new SidedPlane(intersectionPoint, travelPlane, thePoint);\n      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointPlane, intersectionPoint);\n      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoint);\n\n      // Sanity check\n      assert testPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointCutoffPlane\";\n      assert testPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within testPointOtherCutoffPlane\";\n      assert checkPointCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointCutoffPlane\";\n      assert checkPointOtherCutoffPlane.isWithin(intersectionPoint) : \"intersection must be within checkPointOtherCutoffPlane\";\n      \n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7fe41964e49958f662028ea7ed8c224e0955edae":["3dc71a6ca063b508a28bf5b68fedf25a945572a0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7fe41964e49958f662028ea7ed8c224e0955edae"]},"commit2Childs":{"3dc71a6ca063b508a28bf5b68fedf25a945572a0":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3dc71a6ca063b508a28bf5b68fedf25a945572a0","7dc08f02757dd10637b16a5c65eaaef839a91a9a"],"7fe41964e49958f662028ea7ed8c224e0955edae":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}