{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) throws IOException {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Throwable e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab499d210c848577f67d42fc12866e1e95273ebe","date":1394719295,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24792720c893049d53a1807bd0ae9b64d1cd7be5","date":1527536585,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(logid+\"Registered new searcher \" + newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher=null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n        // a searcher may have been warming asynchronously while the core was being closed.\n        // if this happens, just close the searcher.\n        if (isClosed()) {\n          // NOTE: this should not happen now - see close() for details.\n          // *BUT* if we left it enabled, this could still happen before\n          // close() stopped the executor - so disable this test for now.\n          log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n          _searcher.decref();\n        }\n        ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:\" + newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0dfcb99e767e8eafdede3faac6831984ac849fc","date":1589042999,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n\n        if (log.isInfoEnabled()) {\n          log.info(\"{} Registered new searcher autowarm time: {} ms\", logid, newSearcher.getWarmupTime());\n        }\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n        log.info(\"{}Registered new searcher {}\", logid, newSearcher);\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33a4c9aeba0e37a47951b51b4efa17de1948ff4f","date":1589387685,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n\n        if (log.isInfoEnabled()) {\n          log.info(\"{} Registered new searcher autowarm time: {} ms: Collection: '{}'\"\n              , logid, newSearcher.getWarmupTime()\n              , newSearcher.getCore().getCoreDescriptor().getCollectionName());\n        }\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n\n        if (log.isInfoEnabled()) {\n          log.info(\"{} Registered new searcher autowarm time: {} ms\", logid, newSearcher.getWarmupTime());\n        }\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2b1a3449c51f21b82870a18f761cab543d9dddf","date":1590679871,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#registerSearcher(RefCounted[SolrIndexSearcher]).mjava","sourceNew":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n\n        if (log.isInfoEnabled()) {\n          log.info(\"{} Registered new searcher autowarm time: {} ms\", logid, newSearcher.getWarmupTime());\n        }\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","sourceOld":"  // Take control of newSearcherHolder (which should have a reference count of at\n  // least 1 already.  If the caller wishes to use the newSearcherHolder directly\n  // after registering it, then they should increment the reference count *before*\n  // calling this method.\n  //\n  // onDeckSearchers will also be decremented (it should have been incremented\n  // as a result of opening a new searcher).\n  private void registerSearcher(RefCounted<SolrIndexSearcher> newSearcherHolder) {\n    synchronized (searcherLock) {\n      try {\n        if (_searcher == newSearcherHolder) {\n          // trying to re-register the same searcher... this can now happen when a commit has been done but\n          // there were no changes to the index.\n          newSearcherHolder.decref();  // decref since the caller should have still incref'd (since they didn't know the searcher was the same)\n          return;  // still execute the finally block to notify anyone waiting.\n        }\n\n        if (_searcher != null) {\n          _searcher.decref();   // dec refcount for this._searcher\n          _searcher = null;\n        }\n\n        _searcher = newSearcherHolder;\n        SolrIndexSearcher newSearcher = newSearcherHolder.get();\n\n        /***\n         // a searcher may have been warming asynchronously while the core was being closed.\n         // if this happens, just close the searcher.\n         if (isClosed()) {\n         // NOTE: this should not happen now - see close() for details.\n         // *BUT* if we left it enabled, this could still happen before\n         // close() stopped the executor - so disable this test for now.\n         log.error(\"Ignoring searcher register on closed core:{}\", newSearcher);\n         _searcher.decref();\n         }\n         ***/\n\n        newSearcher.register(); // register subitems (caches)\n\n        if (log.isInfoEnabled()) {\n          log.info(\"{} Registered new searcher autowarm time: {} ms: Collection: '{}'\"\n              , logid, newSearcher.getWarmupTime()\n              , newSearcher.getCore().getCoreDescriptor().getCollectionName());\n        }\n\n      } catch (Exception e) {\n        // an exception in register() shouldn't be fatal.\n        log(e);\n      } finally {\n        // wake up anyone waiting for a searcher\n        // even in the face of errors.\n        onDeckSearchers--;\n        searcherLock.notifyAll();\n        assert TestInjection.injectSearcherHooks(getCoreDescriptor() != null && getCoreDescriptor().getCloudDescriptor() != null ? getCoreDescriptor().getCloudDescriptor().getCollectionName() : null);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0dfcb99e767e8eafdede3faac6831984ac849fc":["140be51d03394488536f4aacedace29f9b318347"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["ab499d210c848577f67d42fc12866e1e95273ebe"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"33a4c9aeba0e37a47951b51b4efa17de1948ff4f":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"140be51d03394488536f4aacedace29f9b318347":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"ab499d210c848577f67d42fc12866e1e95273ebe":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b2b1a3449c51f21b82870a18f761cab543d9dddf":["33a4c9aeba0e37a47951b51b4efa17de1948ff4f"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2b1a3449c51f21b82870a18f761cab543d9dddf"]},"commit2Childs":{"b0dfcb99e767e8eafdede3faac6831984ac849fc":["33a4c9aeba0e37a47951b51b4efa17de1948ff4f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["140be51d03394488536f4aacedace29f9b318347"],"33a4c9aeba0e37a47951b51b4efa17de1948ff4f":["b2b1a3449c51f21b82870a18f761cab543d9dddf"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"140be51d03394488536f4aacedace29f9b318347":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"ab499d210c848577f67d42fc12866e1e95273ebe":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["ab499d210c848577f67d42fc12866e1e95273ebe"],"b2b1a3449c51f21b82870a18f761cab543d9dddf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}