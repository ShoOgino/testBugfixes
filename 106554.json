{"path":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","commits":[{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b","date":1496237185,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoSalingJson = cc.getZkController().getZkStateReader().getZkClient().getJson(SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoSalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader());\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4328dc3f7309b4c82d12f9e9420a487a1b9945dd","date":1496650286,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader());\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoSalingJson = cc.getZkController().getZkStateReader().getZkClient().getJson(SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoSalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader());\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25e4a4cddd699db6cce60282e747c7705897e821","date":1496721158,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader());\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"969718c368b28ed1b2335ea2deb275c696cddb4f","date":1498803580,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d92226151c91fb4bebcca6d18782d1c84aee2cd","date":1498804792,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    Map<ReplicaAssigner.Position, String> positions = null;\n    if (l != null) {\n      positions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      positions= Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(positions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (String s : positions.values()) {\n        repCounts.add(new ReplicaCount(s));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1735d662b62f98976dc6cccfe9d327c5e7b22dff","date":1498984143,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0806aac02ecbbdc6b5d9705ae15da193219c7af4","date":1499930856,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25","date":1499961129,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,ClusterDataProvider,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, ClusterDataProvider cdp, CoreContainer cc) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO nocommit: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cdp.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cdp, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,ClusterDataProvider,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, ClusterDataProvider cdp, CoreContainer cc) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO nocommit: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cdp.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cdp, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    Map autoScalingJson = Utils.getJson(cc.getZkController().getZkClient(), SOLR_AUTOSCALING_CONF_PATH, true);\n    if (policyName != null || autoScalingJson.get(Policy.CLUSTER_POLICY) != null) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), numberOfNodes,\n          policyName, cc.getZkController().getZkStateReader(), createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,SolrCloudManager,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, SolrCloudManager cloudManager, CoreContainer cc) throws IOException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      // TODO: make it so that this method doesn't require access to CC\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cloudManager, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int nrtReplicas,\n                                                          Object createNodeSet, CoreContainer cc) throws KeeperException, InterruptedException {\n    log.debug(\"getNodesForNewReplicas() shard: {} , replicas : {} , createNodeSet {}\", shard, nrtReplicas, createNodeSet );\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getMaxShardsPerNode();\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < nrtReplicas) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                nrtReplicas, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    List<ReplicaPosition> replicaPositions = null;\n    if (l != null) {\n      replicaPositions = getNodesViaRules(clusterState, shard, nrtReplicas, cc, coll, createNodeList, l);\n    }\n    String policyName = coll.getStr(POLICY);\n    AutoScalingConfig autoScalingConfig = cc.getZkController().zkStateReader.getAutoScalingConfig();\n    if (policyName != null || !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) {\n      replicaPositions = Assign.getPositionsUsingPolicy(collectionName, Collections.singletonList(shard), nrtReplicas, 0, 0,\n          policyName, cc.getZkController().zkStateReader, createNodeList);\n    }\n\n    if(replicaPositions != null){\n      List<ReplicaCount> repCounts = new ArrayList<>();\n      for (ReplicaPosition p : replicaPositions) {\n        repCounts.add(new ReplicaCount(p.node));\n      }\n      return repCounts;\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"25e4a4cddd699db6cce60282e747c7705897e821":["4328dc3f7309b4c82d12f9e9420a487a1b9945dd"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["969718c368b28ed1b2335ea2deb275c696cddb4f","b869898f50ca80263bac2e3ae0949f7700e5c977"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["560c18d71dad43d675158783c3840f8c80d6d39c"],"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["0806aac02ecbbdc6b5d9705ae15da193219c7af4"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["1735d662b62f98976dc6cccfe9d327c5e7b22dff"],"28288370235ed02234a64753cdbf0c6ec096304a":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"4328dc3f7309b4c82d12f9e9420a487a1b9945dd":["d118ef896fa37a21d831f7e8ffcb8c44b9afc13b"],"1735d662b62f98976dc6cccfe9d327c5e7b22dff":["0d92226151c91fb4bebcca6d18782d1c84aee2cd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","25e4a4cddd699db6cce60282e747c7705897e821"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["28288370235ed02234a64753cdbf0c6ec096304a"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["969718c368b28ed1b2335ea2deb275c696cddb4f","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"]},"commit2Childs":{"25e4a4cddd699db6cce60282e747c7705897e821":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","d118ef896fa37a21d831f7e8ffcb8c44b9afc13b","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d118ef896fa37a21d831f7e8ffcb8c44b9afc13b":["4328dc3f7309b4c82d12f9e9420a487a1b9945dd"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"28288370235ed02234a64753cdbf0c6ec096304a":["969718c368b28ed1b2335ea2deb275c696cddb4f"],"4328dc3f7309b4c82d12f9e9420a487a1b9945dd":["25e4a4cddd699db6cce60282e747c7705897e821"],"1735d662b62f98976dc6cccfe9d327c5e7b22dff":["0806aac02ecbbdc6b5d9705ae15da193219c7af4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["0d92226151c91fb4bebcca6d18782d1c84aee2cd"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":["1735d662b62f98976dc6cccfe9d327c5e7b22dff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"560c18d71dad43d675158783c3840f8c80d6d39c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}