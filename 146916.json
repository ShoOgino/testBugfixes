{"path":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","commits":[{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(Slice.STATE, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(Slice.STATE, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(Slice.STATE, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replicaProps);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c8df3f10a676c3de5dbf390f17a2de2d45cacd","date":1461615626,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(prevState, message);\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collectionName, prevState);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(prevState, coreNodeName, message);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = prevState.getCollection(collectionName).getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collectionName, prevState, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = prevState.getSlice(collectionName, sliceName);\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (slice != null) {\n      collection = prevState.getCollection(collectionName);\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.info(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.info(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f100e4a037a938ee4b027674f1ca80fc208badf","date":1500526196,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection.getName());\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"651c3ddf5bc1266d9de0a972ec05e59d77099a4c","date":1500969855,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection.getName());\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection.getName());\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(zkStateReader.getZkClient(), collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignNode(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29252e837df815b8d01fd6dff973126cced351c5","date":1521709907,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>();\n\n    replicaProps.putAll(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps, collectionName, sliceName);\n\n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps, collectionName);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps, collectionName, sliceName);\n\n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps, collectionName);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps);\n    \n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#updateState(ClusterState,ZkNodeProps,String,Integer,boolean).mjava","sourceNew":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node={} is already registered\", coreNodeName);\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard={} is already registered\", sliceName);\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with {} = {}\", ZkStateReader.NUM_SHARDS_PROP, numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard={}\", sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps, collectionName, sliceName);\n\n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps, collectionName);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","sourceOld":"  private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps message, String collectionName, Integer numShards, boolean collectionExists) {\n    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    boolean forceSetState = message.getBool(ZkStateReader.FORCE_SET_STATE_PROP, true);\n\n    DocCollection collection = prevState.getCollectionOrNull(collectionName);\n    if (!forceSetState && !CloudUtil.replicaExists(prevState, collectionName, sliceName, coreNodeName)) {\n      log.info(\"Failed to update state because the replica does not exist, {}\", message);\n      return ZkStateWriter.NO_OP;\n    }\n\n    if (coreNodeName == null) {\n      coreNodeName = ClusterStateMutator.getAssignedCoreNodeName(collection,\n          message.getStr(ZkStateReader.NODE_NAME_PROP), message.getStr(ZkStateReader.CORE_NAME_PROP));\n      if (coreNodeName != null) {\n        log.debug(\"node=\" + coreNodeName + \" is already registered\");\n      } else {\n        if (!forceSetState) {\n          log.info(\"Failed to update state because the replica does not exist, {}\", message);\n          return ZkStateWriter.NO_OP;\n        }\n        // if coreNodeName is null, auto assign one\n        coreNodeName = Assign.assignCoreNodeName(stateManager, collection);\n      }\n      message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n          coreNodeName);\n    }\n\n    // use the provided non null shardId\n    if (sliceName == null) {\n      //get shardId from ClusterState\n      sliceName = ClusterStateMutator.getAssignedId(collection, coreNodeName);\n      if (sliceName != null) {\n        log.debug(\"shard=\" + sliceName + \" is already registered\");\n      }\n    }\n    if (sliceName == null) {\n      //request new shardId\n      if (collectionExists) {\n        // use existing numShards\n        numShards = collection.getSlices().size();\n        log.debug(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n      }\n      sliceName = Assign.assignShard(collection, numShards);\n      log.info(\"Assigning new node to shard shard=\" + sliceName);\n    }\n\n    Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n\n    Map<String, Object> replicaProps = new LinkedHashMap<>(message.getProperties());\n    if (slice != null) {\n      Replica oldReplica = slice.getReplica(coreNodeName);\n      if (oldReplica != null) {\n        if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n          replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n        }\n        replicaProps.put(ZkStateReader.REPLICA_TYPE, oldReplica.getType().toString());\n        // Move custom props over.\n        for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n          if (ent.getKey().startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n            replicaProps.put(ent.getKey(), ent.getValue());\n          }\n        }\n      }\n    }\n\n    // we don't put these in the clusterstate\n    replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n    replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n    replicaProps.remove(Overseer.QUEUE_OPERATION);\n\n    // remove any props with null values\n    Set<Map.Entry<String, Object>> entrySet = replicaProps.entrySet();\n    List<String> removeKeys = new ArrayList<>();\n    for (Map.Entry<String, Object> entry : entrySet) {\n      if (entry.getValue() == null) {\n        removeKeys.add(entry.getKey());\n      }\n    }\n    for (String removeKey : removeKeys) {\n      replicaProps.remove(removeKey);\n    }\n    replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n    // remove shard specific properties\n    String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n    String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n    String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n    Replica replica = new Replica(coreNodeName, replicaProps, collectionName, sliceName);\n\n    log.debug(\"Will update state for replica: {}\", replica);\n\n    Map<String, Object> sliceProps = null;\n    Map<String, Replica> replicas;\n\n    if (slice != null) {\n      collection = checkAndCompleteShardSplit(prevState, collection, coreNodeName, sliceName, replica);\n      // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n      slice = collection.getSlice(sliceName);\n      sliceProps = slice.getProperties();\n      replicas = slice.getReplicasCopy();\n    } else {\n      replicas = new HashMap<>(1);\n      sliceProps = new HashMap<>();\n      sliceProps.put(Slice.RANGE, shardRange);\n      sliceProps.put(ZkStateReader.STATE_PROP, shardState);\n      sliceProps.put(Slice.PARENT, shardParent);\n    }\n    replicas.put(replica.getName(), replica);\n    slice = new Slice(sliceName, replicas, sliceProps, collectionName);\n\n    DocCollection newCollection = CollectionMutator.updateSlice(collectionName, collection, slice);\n    log.debug(\"Collection is now: {}\", newCollection);\n    return new ZkWriteCommand(collectionName, newCollection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","6681d02f2302c363be938426e68f8dfd090cc1bf"],"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["b94236357aaa22b76c10629851fe4e376e0cea82","29252e837df815b8d01fd6dff973126cced351c5"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"9f100e4a037a938ee4b027674f1ca80fc208badf":["61c45e99cf6676da48f19d7511c73712ad39402b"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["a219f1dcad1700e84807666bdbd2b573e8de7021","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"0c924d4069ef5a5bc479a493befe0121aada6896":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","61c45e99cf6676da48f19d7511c73712ad39402b"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","962cd4f5e313777f35da8f521265323e84184929"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"962cd4f5e313777f35da8f521265323e84184929":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["9f100e4a037a938ee4b027674f1ca80fc208badf"],"61c45e99cf6676da48f19d7511c73712ad39402b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["a52341299179de5479672f7cf518bf4b173f34b3"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["e9017cf144952056066919f1ebc7897ff9bd71b1","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4abf821a41a2fdca2a1dea148999931d22e20529":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"a52341299179de5479672f7cf518bf4b173f34b3":["9f100e4a037a938ee4b027674f1ca80fc208badf","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"29252e837df815b8d01fd6dff973126cced351c5":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4abf821a41a2fdca2a1dea148999931d22e20529"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"b94236357aaa22b76c10629851fe4e376e0cea82":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","29252e837df815b8d01fd6dff973126cced351c5"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0c924d4069ef5a5bc479a493befe0121aada6896","a219f1dcad1700e84807666bdbd2b573e8de7021"],"9f100e4a037a938ee4b027674f1ca80fc208badf":["651c3ddf5bc1266d9de0a972ec05e59d77099a4c","a52341299179de5479672f7cf518bf4b173f34b3"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","4abf821a41a2fdca2a1dea148999931d22e20529"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","04c8df3f10a676c3de5dbf390f17a2de2d45cacd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["936cdd5882761db3b844afd6f84ab81cbb011a75"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"61c45e99cf6676da48f19d7511c73712ad39402b":["9f100e4a037a938ee4b027674f1ca80fc208badf","e9017cf144952056066919f1ebc7897ff9bd71b1"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"04c8df3f10a676c3de5dbf390f17a2de2d45cacd":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a52341299179de5479672f7cf518bf4b173f34b3":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"4abf821a41a2fdca2a1dea148999931d22e20529":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29252e837df815b8d01fd6dff973126cced351c5":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","0c924d4069ef5a5bc479a493befe0121aada6896","936cdd5882761db3b844afd6f84ab81cbb011a75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}