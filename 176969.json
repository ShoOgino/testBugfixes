{"path":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","commits":[{"id":"cbcbc6c6114d6e02f478dc15249bd5708eea06eb","date":1394118481,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(2, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(2, i);\n    }\n        \n    // NOTE: not quite right i guess, really our sort \"value\" is more complex...\n    // but at the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          // nocommit: should not be needed?\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          // nocommit: should not be needed?\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(0, docID1);\n          comparators[i].copy(1, docID2);\n          int comp = reverseMul[i] * comparators[i].compare(0, 1);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"143fbe495c6fa7e253618182fcf5342b12029f0a","date":1394120958,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: not quite right i guess, really our sort \"value\" is more complex...\n    // but at the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          // nocommit: should not be needed?\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          // nocommit: should not be needed?\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(2, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(2, i);\n    }\n        \n    // NOTE: not quite right i guess, really our sort \"value\" is more complex...\n    // but at the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          // nocommit: should not be needed?\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          // nocommit: should not be needed?\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          comparators[i].copy(0, docID1);\n          comparators[i].copy(1, docID2);\n          int comp = reverseMul[i] * comparators[i].compare(0, 1);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2e62f353f033b88592e01e103f1c6650f47347e","date":1394125436,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: not quite right i guess, really our sort \"value\" is more complex...\n    // but at the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          // nocommit: should not be needed?\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          // nocommit: should not be needed?\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6eaa7a97036f30284a494de83425b80a5b8c2d3f","date":1394132680,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException();\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4637747f71df783fc2014ef1f1e0418466e3bed6","date":1394196311,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9644a32526f2e2ae87543b00e8be543aa25f29c","date":1411548458,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"AtomicReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents;\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof FixedBitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e","date":1419346542,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/search/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) throws IOException {\n    // we keep parallel slots: the parent ids and the child ids\n    final int parentSlots[] = new int[numHits];\n    final int childSlots[] = new int[numHits];\n    \n    SortField parentFields[] = parentSort.getSort();\n    final int parentReverseMul[] = new int[parentFields.length];\n    final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];\n    for (int i = 0; i < parentFields.length; i++) {\n      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;\n      parentComparators[i] = parentFields[i].getComparator(1, i);\n    }\n    \n    SortField childFields[] = childSort.getSort();\n    final int childReverseMul[] = new int[childFields.length];\n    final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];\n    for (int i = 0; i < childFields.length; i++) {\n      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;\n      childComparators[i] = childFields[i].getComparator(1, i);\n    }\n        \n    // NOTE: we could return parent ID as value but really our sort \"value\" is more complex...\n    // So we throw UOE for now. At the moment you really should only use this at indexing time.\n    return new FieldComparator<Integer>() {\n      int bottomParent;\n      int bottomChild;\n      FixedBitSet parentBits;\n      \n      @Override\n      public int compare(int slot1, int slot2) {\n        try {\n          return compare(childSlots[slot1], parentSlots[slot1], childSlots[slot2], parentSlots[slot2]);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setBottom(int slot) {\n        bottomParent = parentSlots[slot];\n        bottomChild = childSlots[slot];\n      }\n\n      @Override\n      public void setTopValue(Integer value) {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public int compareBottom(int doc) throws IOException {\n        return compare(bottomChild, bottomParent, doc, parent(doc));\n      }\n\n      @Override\n      public int compareTop(int doc) throws IOException {\n        // we dont have enough information (the docid is needed)\n        throw new UnsupportedOperationException(\"this comparator cannot be used with deep paging\");\n      }\n\n      @Override\n      public void copy(int slot, int doc) throws IOException {\n        childSlots[slot] = doc;\n        parentSlots[slot] = parent(doc);\n      }\n\n      @Override\n      public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n        final DocIdSet parents = parentsFilter.getDocIdSet(context, null);\n        if (parents == null) {\n          throw new IllegalStateException(\"LeafReader \" + context.reader() + \" contains no parents!\");\n        }\n        if (!(parents instanceof BitDocIdSet)) {\n          throw new IllegalStateException(\"parentFilter must return FixedBitSet; got \" + parents);\n        }\n        parentBits = (FixedBitSet) parents.bits();\n        for (int i = 0; i < parentComparators.length; i++) {\n          parentComparators[i] = parentComparators[i].setNextReader(context);\n        }\n        for (int i = 0; i < childComparators.length; i++) {\n          childComparators[i] = childComparators[i].setNextReader(context);\n        }\n        return this;\n      }\n\n      @Override\n      public Integer value(int slot) {\n        // really our sort \"value\" is more complex...\n        throw new UnsupportedOperationException(\"filling sort field values is not yet supported\");\n      }\n      \n      @Override\n      public void setScorer(Scorer scorer) {\n        super.setScorer(scorer);\n        for (FieldComparator<?> comp : parentComparators) {\n          comp.setScorer(scorer);\n        }\n        for (FieldComparator<?> comp : childComparators) {\n          comp.setScorer(scorer);\n        }\n      }\n\n      int parent(int doc) {\n        return parentBits.nextSetBit(doc);\n      }\n      \n      int compare(int docID1, int parent1, int docID2, int parent2) throws IOException {\n        if (parent1 == parent2) { // both are in the same block\n          if (docID1 == parent1 || docID2 == parent2) {\n            // keep parents at the end of blocks\n            return docID1 - docID2;\n          } else {\n            return compare(docID1, docID2, childComparators, childReverseMul);\n          }\n        } else {\n          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);\n          if (cmp == 0) {\n            return parent1 - parent2;\n          } else {\n            return cmp;\n          }\n        }\n      }\n      \n      int compare(int docID1, int docID2, FieldComparator<?> comparators[], int reverseMul[]) throws IOException {\n        for (int i = 0; i < comparators.length; i++) {\n          // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n          // the segments are always the same here...\n          comparators[i].copy(0, docID1);\n          comparators[i].setBottom(0);\n          int comp = reverseMul[i] * comparators[i].compareBottom(docID2);\n          if (comp != 0) {\n            return comp;\n          }\n        }\n        return 0; // no need to docid tiebreak\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4637747f71df783fc2014ef1f1e0418466e3bed6"],"c9644a32526f2e2ae87543b00e8be543aa25f29c":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"6eaa7a97036f30284a494de83425b80a5b8c2d3f":["c2e62f353f033b88592e01e103f1c6650f47347e"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"c2e62f353f033b88592e01e103f1c6650f47347e":["143fbe495c6fa7e253618182fcf5342b12029f0a"],"cbcbc6c6114d6e02f478dc15249bd5708eea06eb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"143fbe495c6fa7e253618182fcf5342b12029f0a":["cbcbc6c6114d6e02f478dc15249bd5708eea06eb"],"80c55596a764e2d397e982828e75fcac5ce430a0":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6eaa7a97036f30284a494de83425b80a5b8c2d3f"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"]},"commit2Childs":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"c9644a32526f2e2ae87543b00e8be543aa25f29c":["80c55596a764e2d397e982828e75fcac5ce430a0"],"6eaa7a97036f30284a494de83425b80a5b8c2d3f":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2e62f353f033b88592e01e103f1c6650f47347e":["6eaa7a97036f30284a494de83425b80a5b8c2d3f"],"cbcbc6c6114d6e02f478dc15249bd5708eea06eb":["143fbe495c6fa7e253618182fcf5342b12029f0a"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["96ea64d994d340044e0d57aeb6a5871539d10ca5","cbcbc6c6114d6e02f478dc15249bd5708eea06eb","4637747f71df783fc2014ef1f1e0418466e3bed6"],"143fbe495c6fa7e253618182fcf5342b12029f0a":["c2e62f353f033b88592e01e103f1c6650f47347e"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["96ea64d994d340044e0d57aeb6a5871539d10ca5","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}