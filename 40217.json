{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0f42e0639920b2e917c9ece35fb68ad83021e38","date":1337629438,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"129c6e8ac0c0d9a110ba29e4b5f1889374f30076","date":1337725510,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00f06a4178989089b29a77d6dce7c86dfb8b6931","date":1337729247,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, segment, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cadbbc3b8df99c8c7acd19da62f6b35eb126c85","date":1337798576,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"16cbef32b882ec68df422af3f08845ec82620335","date":1337802266,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    // nocommit: can we nuke this count too?\n    mergeState.mergedDocCount = setDocMaps();\n    mergeState.segmentInfo.setDocCount(mergeState.mergedDocCount);\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, mergeState.mergedDocCount,\n                                                                      termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff82b51516e4a8d24bb6182e5235be1c88b8ac2e","date":1337803615,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    // nocommit: can we nuke this count too?\n    mergeState.mergedDocCount = setDocMaps();\n    mergeState.segmentInfo.setDocCount(mergeState.mergedDocCount);\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":["0859dec0aa7a485aa0081147f533c5987b4b47ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.mergedDocCount = setDocMaps();\n\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.mergedDocCount;\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, segment, mergeState.fieldInfos, mergeState.mergedDocCount, termIndexInterval, codec, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.mergedDocCount;\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":["06584e6e98d592b34e1329b384182f368d2025e8"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws CorruptIndexException, IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3538d7872902c19ad619052fb3130f652f35e35","date":1353005395,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n      consumer.merge(mergeState);\n      consumer.close();\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f45457a742a53533c348c4b990b1c579ff364467","date":1353197071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      if (codec.simpleDocValuesFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n        consumer.merge(mergeState);\n        consumer.close();\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n      consumer.merge(mergeState);\n      consumer.close();\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55eeb2534cd53d2a985669829df942468ebf5314","date":1354409119,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n      if (codec.simpleNormsFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleNormsFormat().normsConsumer(segmentWriteState);\n        boolean success = false;\n        try {\n          consumer.merge(mergeState, true);\n        } finally {\n          if (success) {\n            IOUtils.close(consumer);\n          } else {\n            IOUtils.closeWhileHandlingException(consumer);            \n          }\n        }\n      }\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      if (codec.simpleDocValuesFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n        boolean success = false;\n        try {\n          consumer.merge(mergeState, false);\n        } finally {\n          if (success) {\n            IOUtils.close(consumer);\n          } else {\n            IOUtils.closeWhileHandlingException(consumer);            \n          }\n        }\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      if (codec.simpleDocValuesFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n        consumer.merge(mergeState);\n        consumer.close();\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b53a9a930ee01857178a1b512fbab24642f3fa8","date":1354471097,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n      mergeSimpleNorms(segmentWriteState);\n    }\n\n    // Merge simple doc values:\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      mergeSimpleDocValues(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n      if (codec.simpleNormsFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleNormsFormat().normsConsumer(segmentWriteState);\n        boolean success = false;\n        try {\n          consumer.merge(mergeState, true);\n        } finally {\n          if (success) {\n            IOUtils.close(consumer);\n          } else {\n            IOUtils.closeWhileHandlingException(consumer);            \n          }\n        }\n      }\n    }\n\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      if (codec.simpleDocValuesFormat() != null) {\n        SimpleDVConsumer consumer = codec.simpleDocValuesFormat().fieldsConsumer(segmentWriteState);\n        boolean success = false;\n        try {\n          consumer.merge(mergeState, false);\n        } finally {\n          if (success) {\n            IOUtils.close(consumer);\n          } else {\n            IOUtils.closeWhileHandlingException(consumer);            \n          }\n        }\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aaaffc439e5ab10d23bed4448c0da2f2055ab552","date":1357315674,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = System.nanoTime();\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    t0 = System.nanoTime();\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    t0 = System.nanoTime();\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      t0 = System.nanoTime();\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      t0 = System.nanoTime();\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf","date":1357317637,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = System.nanoTime();\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    t0 = System.nanoTime();\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    t0 = System.nanoTime();\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      t0 = System.nanoTime();\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      t0 = System.nanoTime();\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      mergeSimpleNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    // Merge simple doc values:\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      mergeSimpleDocValues(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    int numMerged = mergeFields();\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    mergeTerms(segmentWriteState);\n    mergePerDoc(segmentWriteState);\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      mergeNorms(segmentWriteState);\n      mergeSimpleNorms(segmentWriteState);\n    }\n\n    // Merge simple doc values:\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      mergeSimpleDocValues(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      numMerged = mergeVectors();\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeSimpleDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeSimpleNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      mergeSimpleNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    // Merge simple doc values:\n    if (mergeState.fieldInfos.hasDocValues()) {\n      // nocommit shouldn't need null check:\n      mergeSimpleDocValues(segmentWriteState);\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b57ad184373369f2ee65828cd86b30da949653f6","date":1360243980,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeSimpleDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeSimpleNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  final MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeDocValuesAndNormsFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergePerDoc(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":["129c6e8ac0c0d9a110ba29e4b5f1889374f30076","06584e6e98d592b34e1329b384182f368d2025e8","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad252c98ff183bc59bd0617be14fa46f9696d6fc","date":1363962178,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers specified by the {@link #add} method into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a45bec74b98f6fc05f52770cfb425739e6563960","date":1375119292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, termIndexInterval, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0859dec0aa7a485aa0081147f533c5987b4b47ac","date":1376498602,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":["06584e6e98d592b34e1329b384182f368d2025e8","ff82b51516e4a8d24bb6182e5235be1c88b8ac2e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    \n    mergeState.segmentInfo.setDocCount(setDocMaps());\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8435160e9702b19398118ddf76b61c846612b6a4","date":1380349140,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"22a2e66dfda83847e80095b8693c660742ab3e9c","date":1408628796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    setMatchingSegmentReaders();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c65d2864d936ccf22dc7ec14dd48b4dff7bacceb","date":1411653326,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":["8435160e9702b19398118ddf76b61c846612b6a4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2131047ecceac64b54ba70feec3d26bbd7e483d7","date":1411862069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.fieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.fieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.fieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.fieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.fieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe60a17a7a0cfd101b1169acf089221bc6c166","date":1412767493,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();\n    fieldInfosWriter.write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    // NOTE: it's important to add calls to\n    // checkAbort.work(...) if you make any changes to this\n    // method that will spend alot of time.  The frequency\n    // of this check impacts how long\n    // IndexWriter.close(false) takes to actually stop the\n    // background merge threads.\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69b552dd76da1e39260a920b58a839522218fcba","date":1426364569,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.getDocCount(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.getDocCount()=\" + mergeState.segmentInfo.getDocCount();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.getDocCount();\n    }\n    \n    // write the merged infos\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDimensionalValues()) {\n      mergeDimensionalValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge dimensional values values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e3325135ee02db2d0563d1c50238d0020e9fef8","date":1447240618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDimensionalValues()) {\n      mergeDimensionalValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge dimensional values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDimensionalValues()) {\n      mergeDimensionalValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge dimensional values values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDimensionalValues()) {\n      mergeDimensionalValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge dimensional values [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n                                                                   IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    mergeTerms(segmentWriteState);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n    \n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"790693f23f4e88a59fbb25e47cc25f6d493b03cb","date":1553077690,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n                                                                   IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"763da4a9605e47013078edc323b9d4b608f0f9e0","date":1555353576,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix, Collections.emptyMap());\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4e83191a3e02851a0b67e5335e6922f3e9ea86d","date":1583489709,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix, Collections.emptyMap());\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec68e7c41fed133827595747d853cad504e481e","date":1583501052,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#merge().mjava","sourceNew":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","sourceOld":"  /**\n   * Merges the readers into the directory passed to the constructor\n   * @return The number of documents that were merged\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  MergeState merge() throws IOException {\n    if (!shouldMerge()) {\n      throw new IllegalStateException(\"Merge would result in 0 document segment\");\n    }\n    mergeFieldInfos();\n    long t0 = 0;\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    int numMerged = mergeFields();\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge stored fields [\" + numMerged + \" docs]\");\n    }\n    assert numMerged == mergeState.segmentInfo.maxDoc(): \"numMerged=\" + numMerged + \" vs mergeState.segmentInfo.maxDoc()=\" + mergeState.segmentInfo.maxDoc();\n\n    final SegmentWriteState segmentWriteState = new SegmentWriteState(mergeState.infoStream, directory, mergeState.segmentInfo,\n                                                                      mergeState.mergeFieldInfos, null, context);\n    final SegmentReadState segmentReadState = new SegmentReadState(directory, mergeState.segmentInfo, mergeState.mergeFieldInfos,\n        true, IOContext.READ, segmentWriteState.segmentSuffix);\n\n    if (mergeState.mergeFieldInfos.hasNorms()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      mergeNorms(segmentWriteState);\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge norms [\" + numMerged + \" docs]\");\n      }\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    try (NormsProducer norms = mergeState.mergeFieldInfos.hasNorms()\n        ? codec.normsFormat().normsProducer(segmentReadState)\n        : null) {\n      NormsProducer normsMergeInstance = null;\n      if (norms != null) {\n        // Use the merge instance in order to reuse the same IndexInput for all terms\n        normsMergeInstance = norms.getMergeInstance();\n      }\n      mergeTerms(segmentWriteState, normsMergeInstance);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge postings [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasDocValues()) {\n      mergeDocValues(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge doc values [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    if (mergeState.mergeFieldInfos.hasPointValues()) {\n      mergePoints(segmentWriteState);\n    }\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge points [\" + numMerged + \" docs]\");\n    }\n\n    if (mergeState.mergeFieldInfos.hasVectors()) {\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        t0 = System.nanoTime();\n      }\n      numMerged = mergeVectors();\n      if (mergeState.infoStream.isEnabled(\"SM\")) {\n        long t1 = System.nanoTime();\n        mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to merge vectors [\" + numMerged + \" docs]\");\n      }\n      assert numMerged == mergeState.segmentInfo.maxDoc();\n    }\n    \n    // write the merged infos\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      t0 = System.nanoTime();\n    }\n    codec.fieldInfosFormat().write(directory, mergeState.segmentInfo, \"\", mergeState.mergeFieldInfos, context);\n    if (mergeState.infoStream.isEnabled(\"SM\")) {\n      long t1 = System.nanoTime();\n      mergeState.infoStream.message(\"SM\", ((t1-t0)/1000000) + \" msec to write field infos [\" + numMerged + \" docs]\");\n    }\n\n    return mergeState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4b53a9a930ee01857178a1b512fbab24642f3fa8","854c907ba21cf5682ecb9b18bf1188a38d0cbbaf"],"00f06a4178989089b29a77d6dce7c86dfb8b6931":["129c6e8ac0c0d9a110ba29e4b5f1889374f30076"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"16cbef32b882ec68df422af3f08845ec82620335":["0cadbbc3b8df99c8c7acd19da62f6b35eb126c85"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["22a2e66dfda83847e80095b8693c660742ab3e9c","c65d2864d936ccf22dc7ec14dd48b4dff7bacceb"],"ff82b51516e4a8d24bb6182e5235be1c88b8ac2e":["16cbef32b882ec68df422af3f08845ec82620335"],"a0f42e0639920b2e917c9ece35fb68ad83021e38":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b57ad184373369f2ee65828cd86b30da949653f6":["0837ab0472feecb3a54260729d845f839e1cbd72"],"f45457a742a53533c348c4b990b1c579ff364467":["e3538d7872902c19ad619052fb3130f652f35e35"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"ad252c98ff183bc59bd0617be14fa46f9696d6fc":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["5faf65b6692f15cca0f87bf8666c87899afc619f","69b552dd76da1e39260a920b58a839522218fcba"],"e3538d7872902c19ad619052fb3130f652f35e35":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"129c6e8ac0c0d9a110ba29e4b5f1889374f30076":["a0f42e0639920b2e917c9ece35fb68ad83021e38"],"b06445ae1731e049327712db0454e5643ca9b7fe":["5faf65b6692f15cca0f87bf8666c87899afc619f","b0267c69e2456a3477a1ad785723f2135da3117e"],"9bb9a29a5e71a90295f175df8919802993142c9a":["5f6bd27530a2846413fe2d00030493c0e2d3a072","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"622a708571e534680618b3c5e0c28ac539a47776":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["ad252c98ff183bc59bd0617be14fa46f9696d6fc"],"5e3325135ee02db2d0563d1c50238d0020e9fef8":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"69b552dd76da1e39260a920b58a839522218fcba":["b0267c69e2456a3477a1ad785723f2135da3117e"],"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["622a708571e534680618b3c5e0c28ac539a47776"],"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["9bb9a29a5e71a90295f175df8919802993142c9a"],"55980207f1977bd1463465de1659b821347e2fa8":["2131047ecceac64b54ba70feec3d26bbd7e483d7","e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["5e3325135ee02db2d0563d1c50238d0020e9fef8"],"0859dec0aa7a485aa0081147f533c5987b4b47ac":["a45bec74b98f6fc05f52770cfb425739e6563960"],"a45bec74b98f6fc05f52770cfb425739e6563960":["ad252c98ff183bc59bd0617be14fa46f9696d6fc"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","0859dec0aa7a485aa0081147f533c5987b4b47ac"],"b0267c69e2456a3477a1ad785723f2135da3117e":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"8435160e9702b19398118ddf76b61c846612b6a4":["0859dec0aa7a485aa0081147f533c5987b4b47ac"],"bec68e7c41fed133827595747d853cad504e481e":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["55eeb2534cd53d2a985669829df942468ebf5314"],"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf":["aaaffc439e5ab10d23bed4448c0da2f2055ab552"],"55eeb2534cd53d2a985669829df942468ebf5314":["f45457a742a53533c348c4b990b1c579ff364467"],"aaaffc439e5ab10d23bed4448c0da2f2055ab552":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ff82b51516e4a8d24bb6182e5235be1c88b8ac2e"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["854c907ba21cf5682ecb9b18bf1188a38d0cbbaf","b57ad184373369f2ee65828cd86b30da949653f6"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["69b552dd76da1e39260a920b58a839522218fcba"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["c65d2864d936ccf22dc7ec14dd48b4dff7bacceb"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["8435160e9702b19398118ddf76b61c846612b6a4"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"0cadbbc3b8df99c8c7acd19da62f6b35eb126c85":["00f06a4178989089b29a77d6dce7c86dfb8b6931"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bec68e7c41fed133827595747d853cad504e481e"],"c65d2864d936ccf22dc7ec14dd48b4dff7bacceb":["22a2e66dfda83847e80095b8693c660742ab3e9c"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["0837ab0472feecb3a54260729d845f839e1cbd72"],"00f06a4178989089b29a77d6dce7c86dfb8b6931":["0cadbbc3b8df99c8c7acd19da62f6b35eb126c85"],"763da4a9605e47013078edc323b9d4b608f0f9e0":["a4e83191a3e02851a0b67e5335e6922f3e9ea86d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0f42e0639920b2e917c9ece35fb68ad83021e38","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"16cbef32b882ec68df422af3f08845ec82620335":["ff82b51516e4a8d24bb6182e5235be1c88b8ac2e"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["9bb9a29a5e71a90295f175df8919802993142c9a"],"ff82b51516e4a8d24bb6182e5235be1c88b8ac2e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0f42e0639920b2e917c9ece35fb68ad83021e38":["129c6e8ac0c0d9a110ba29e4b5f1889374f30076"],"b57ad184373369f2ee65828cd86b30da949653f6":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"f45457a742a53533c348c4b990b1c579ff364467":["55eeb2534cd53d2a985669829df942468ebf5314"],"a4e83191a3e02851a0b67e5335e6922f3e9ea86d":["bec68e7c41fed133827595747d853cad504e481e"],"ad252c98ff183bc59bd0617be14fa46f9696d6fc":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","a45bec74b98f6fc05f52770cfb425739e6563960"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"e3538d7872902c19ad619052fb3130f652f35e35":["f45457a742a53533c348c4b990b1c579ff364467"],"129c6e8ac0c0d9a110ba29e4b5f1889374f30076":["00f06a4178989089b29a77d6dce7c86dfb8b6931"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"9bb9a29a5e71a90295f175df8919802993142c9a":["e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"622a708571e534680618b3c5e0c28ac539a47776":["790693f23f4e88a59fbb25e47cc25f6d493b03cb"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"0837ab0472feecb3a54260729d845f839e1cbd72":["b57ad184373369f2ee65828cd86b30da949653f6"],"5e3325135ee02db2d0563d1c50238d0020e9fef8":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["e3538d7872902c19ad619052fb3130f652f35e35","aaaffc439e5ab10d23bed4448c0da2f2055ab552","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"69b552dd76da1e39260a920b58a839522218fcba":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"790693f23f4e88a59fbb25e47cc25f6d493b03cb":["763da4a9605e47013078edc323b9d4b608f0f9e0"],"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["55980207f1977bd1463465de1659b821347e2fa8","5faf65b6692f15cca0f87bf8666c87899afc619f"],"55980207f1977bd1463465de1659b821347e2fa8":[],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["622a708571e534680618b3c5e0c28ac539a47776"],"0859dec0aa7a485aa0081147f533c5987b4b47ac":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","8435160e9702b19398118ddf76b61c846612b6a4"],"a45bec74b98f6fc05f52770cfb425739e6563960":["0859dec0aa7a485aa0081147f533c5987b4b47ac"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"b0267c69e2456a3477a1ad785723f2135da3117e":["b06445ae1731e049327712db0454e5643ca9b7fe","69b552dd76da1e39260a920b58a839522218fcba"],"8435160e9702b19398118ddf76b61c846612b6a4":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"bec68e7c41fed133827595747d853cad504e481e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"854c907ba21cf5682ecb9b18bf1188a38d0cbbaf":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d4d69c535930b5cce125cff868d40f6373dc27d4"],"55eeb2534cd53d2a985669829df942468ebf5314":["4b53a9a930ee01857178a1b512fbab24642f3fa8"],"aaaffc439e5ab10d23bed4448c0da2f2055ab552":["854c907ba21cf5682ecb9b18bf1188a38d0cbbaf"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ad252c98ff183bc59bd0617be14fa46f9696d6fc"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["5e3325135ee02db2d0563d1c50238d0020e9fef8"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["9bb9a29a5e71a90295f175df8919802993142c9a","55980207f1977bd1463465de1659b821347e2fa8"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["5f6bd27530a2846413fe2d00030493c0e2d3a072","c65d2864d936ccf22dc7ec14dd48b4dff7bacceb"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","b0267c69e2456a3477a1ad785723f2135da3117e"],"0cadbbc3b8df99c8c7acd19da62f6b35eb126c85":["16cbef32b882ec68df422af3f08845ec82620335"],"c65d2864d936ccf22dc7ec14dd48b4dff7bacceb":["5f6bd27530a2846413fe2d00030493c0e2d3a072","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","55980207f1977bd1463465de1659b821347e2fa8","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}