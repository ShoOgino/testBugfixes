{"path":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long).mjava","commits":[{"id":"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1","date":1448389841,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Read the entries from the given tlog file and replay them as buffered updates.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      tlogReader.close();\n      src.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfa6bab72dc1ef7209657e6685f9204e2e49bac8","date":1448391014,"type":4,"author":"Erick Erickson","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * Read the entries from the given tlog file and replay them as buffered updates.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      tlogReader.close();\n      src.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cfa6bab72dc1ef7209657e6685f9204e2e49bac8":["6776c9bdacef00ce712b87d1c8e999ae61c1c6a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfa6bab72dc1ef7209657e6685f9204e2e49bac8"]},"commit2Childs":{"cfa6bab72dc1ef7209657e6685f9204e2e49bac8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6776c9bdacef00ce712b87d1c8e999ae61c1c6a1"],"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1":["cfa6bab72dc1ef7209657e6685f9204e2e49bac8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}