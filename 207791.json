{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication.SearchThread#run().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication.SearchThread#run().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication.SearchThread#run().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication.SearchThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // Maps version to number of hits for silly 'the' TermQuery:\n      Query theQuery = new TermQuery(new Term(\"body\", \"the\"));\n\n      // Persists connections\n      Map<Integer,Connection> connections = new HashMap<>();\n\n      while (stop.get() == false) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node == null || node.isOpen == false) {\n          continue;\n        }\n\n        if (node.lock.tryLock() == false) {\n          // Node is in the process of closing or crashing or something\n          continue;\n        }\n\n        try {\n\n          Thread.currentThread().setName(\"Searcher node=\" + node);\n\n          //System.out.println(\"S: cycle; conns=\" + connections);\n\n          Connection c = connections.get(node.id);\n\n          long version;\n          try {\n            if (c == null) {\n              //System.out.println(\"S: new connection \" + node.id + \" \" + Thread.currentThread().getName());\n              c = new Connection(node.tcpPort);\n              connections.put(node.id, c);\n            } else {\n              //System.out.println(\"S: reuse connection \" + node.id + \" \" + Thread.currentThread().getName());\n            }\n\n            c.out.writeByte(SimplePrimaryNode.CMD_SEARCH);\n            c.flush();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            version = c.in.readVLong();\n\n            while (c.sockIn.available() == 0) {\n              if (stop.get()) {\n                break;\n              }\n              if (node.isOpen == false) {\n                throw new IOException(\"node closed\");\n              }\n              Thread.sleep(1);\n            }\n            int hitCount = c.in.readVInt();\n\n            Integer oldHitCount = hitCounts.get(version);\n\n            // TODO: we never prune this map...\n            if (oldHitCount == null) {\n              hitCounts.put(version, hitCount);\n              message(\"top: searcher: record search hitCount version=\" + version + \" hitCount=\" + hitCount + \" node=\" + node);\n            } else {\n              // Just ensure that all nodes show the same hit count for\n              // the same version, i.e. they really are replicas of one another:\n              if (oldHitCount.intValue() != hitCount) {\n                failed.set(true);\n                stop.set(true);\n                message(\"top: searcher: wrong version hitCount: version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n                fail(\"version=\" + version + \" oldHitCount=\" + oldHitCount.intValue() + \" hitCount=\" + hitCount);\n              }\n            }\n          } catch (IOException ioe) {\n            //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n            //ioe.printStackTrace(System.out);\n            IOUtils.closeWhileHandlingException(c);\n            connections.remove(node.id);\n            continue;\n          }\n\n          // This can be null if we got the new primary after crash and that primary is still catching up (replaying xlog):\n          Integer expectedAtLeastHitCount = versionToMarker.get(version);\n\n          if (expectedAtLeastHitCount != null && expectedAtLeastHitCount > 0 && random().nextInt(10) == 7) {\n            try {\n              c.out.writeByte(SimplePrimaryNode.CMD_MARKER_SEARCH);\n              c.flush();\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              version = c.in.readVLong();\n\n              while (c.sockIn.available() == 0) {\n                if (stop.get()) {\n                  break;\n                }\n                if (node.isOpen == false) {\n                  throw new IOException(\"node died\");\n                }\n                Thread.sleep(1);\n              }\n\n              int hitCount = c.in.readVInt();\n\n              // Look for data loss: make sure all marker docs are visible:\n            \n              if (hitCount < expectedAtLeastHitCount) {\n\n                String failMessage = \"node=\" + node + \": documents were lost version=\" + version + \" hitCount=\" + hitCount + \" vs expectedAtLeastHitCount=\" + expectedAtLeastHitCount;\n                message(failMessage);\n                failed.set(true);\n                stop.set(true);\n                fail(failMessage);\n              }\n            } catch (IOException ioe) {\n              //message(\"top: searcher: ignore exc talking to node \" + node + \": \" + ioe);\n              //throw new RuntimeException(ioe);\n              //ioe.printStackTrace(System.out);\n              IOUtils.closeWhileHandlingException(c);\n              connections.remove(node.id);\n              continue;\n            }\n          }\n\n          Thread.sleep(10);\n\n        } catch (Throwable t) {\n          failed.set(true);\n          stop.set(true);\n          throw new RuntimeException(t);\n        } finally {\n          node.lock.unlock();\n        }\n      }\n      System.out.println(\"Searcher: now stop\");\n      IOUtils.closeWhileHandlingException(connections.values());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}