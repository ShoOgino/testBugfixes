{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","commits":[{"id":"dca67e06c96e95a8d9ef07418b6299bfd981523b","date":1484639518,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (state.index.isLeafNode()) {\n      // Assume all points match and there are no dups\n      return maxPointsInLeafNode;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15fe6782474c00ec2ccc636052a025f8fe0bdb8b","date":1484743707,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (state.index.isLeafNode()) {\n      if (r == Relation.CELL_INSIDE_QUERY) {\n        return maxPointsInLeafNode;\n      } else {\n        // Assume half the points matched\n        return (maxPointsInLeafNode + 1) / 2;\n      }\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (state.index.isLeafNode()) {\n      // Assume all points match and there are no dups\n      return maxPointsInLeafNode;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"069d686c3ab4d51d0d217cff30aad53b2b70ece0","date":1484748426,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (state.index.isLeafNode()) {\n      if (r == Relation.CELL_INSIDE_QUERY) {\n        return maxPointsInLeafNode;\n      } else {\n        // Assume half the points matched\n        return (maxPointsInLeafNode + 1) / 2;\n      }\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#estimatePointCount(IntersectState,byte[],byte[]).mjava","sourceNew":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*config.bytesPerDim, config.bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*config.bytesPerDim, config.bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) config.maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (config.maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", config.numIndexDims=\" + config.numIndexDims;\n      assert splitDim < config.numIndexDims: \"splitDim=\" + splitDim + \", config.numIndexDims=\" + config.numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == config.bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * config.bytesPerDim, splitDim * config.bytesPerDim + config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + config.bytesPerDim) <= 0: \"config.bytesPerDim=\" + config.bytesPerDim + \" splitDim=\" + splitDim + \" config.numIndexDims=\" + config.numIndexDims + \" config.numDims=\" + config.numDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * config.bytesPerDim, splitDim * config.bytesPerDim + config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + config.bytesPerDim) >= 0: \"config.bytesPerDim=\" + config.bytesPerDim + \" splitDim=\" + splitDim + \" config.numIndexDims=\" + config.numIndexDims + \" config.numDims=\" + config.numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*config.bytesPerDim, config.bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, config.bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*config.bytesPerDim, config.bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","sourceOld":"  private long estimatePointCount(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n      return 0L;\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      return (long) maxPointsInLeafNode * state.index.getNumLeaves();\n    } else if (state.index.isLeafNode()) {\n      // Assume half the points matched\n      return (maxPointsInLeafNode + 1) / 2;\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      final long leftCost = estimatePointCount(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      final long rightCost = estimatePointCount(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n      return leftCost + rightCost;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["f6652c943595e92c187ee904c382863013eae28f"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["15fe6782474c00ec2ccc636052a025f8fe0bdb8b"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15fe6782474c00ec2ccc636052a025f8fe0bdb8b":["dca67e06c96e95a8d9ef07418b6299bfd981523b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"302d34f2c66e8d489ee13078305c330cbf67b226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","069d686c3ab4d51d0d217cff30aad53b2b70ece0"]},"commit2Childs":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"f6652c943595e92c187ee904c382863013eae28f":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"069d686c3ab4d51d0d217cff30aad53b2b70ece0":["41f60ea1802fda42d3c91d023406066d00ddb5f8","302d34f2c66e8d489ee13078305c330cbf67b226"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["15fe6782474c00ec2ccc636052a025f8fe0bdb8b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dca67e06c96e95a8d9ef07418b6299bfd981523b","302d34f2c66e8d489ee13078305c330cbf67b226"],"15fe6782474c00ec2ccc636052a025f8fe0bdb8b":["069d686c3ab4d51d0d217cff30aad53b2b70ece0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"302d34f2c66e8d489ee13078305c330cbf67b226":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}