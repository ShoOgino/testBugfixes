{"path":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      Field field1 = (Field) f;\n      \n      Field field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      Field field1 = (Field) f;\n      \n      Field field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86365ce8db75e42ebe10805e99e92c463fef63b6","date":1330370408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      if (field1 instanceof DocValuesField) {\n        final DocValues.Type dvType = field1.fieldType().docValueType();\n        switch (dvType) {\n        case VAR_INTS:\n        case FIXED_INTS_8:\n        case FIXED_INTS_16:\n        case FIXED_INTS_32:\n        case FIXED_INTS_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().intValue(), dvType);\n          break;\n        case BYTES_FIXED_DEREF:\n        case BYTES_FIXED_STRAIGHT:\n        case BYTES_VAR_DEREF:\n        case BYTES_VAR_STRAIGHT: \n        case BYTES_FIXED_SORTED:\n        case BYTES_VAR_SORTED:\n          field2 = new DocValuesField(field1.name(), BytesRef.deepCopyOf(field1.binaryValue()), dvType);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().doubleValue(), dvType);\n          break;\n        default:\n          throw new IllegalArgumentException(\"don't know how to clone DV field=\" + field1);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      Field field1 = (Field) f;\n      \n      Field field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      if (field1 instanceof DocValuesField) {\n        final DocValues.Type dvType = field1.fieldType().docValueType();\n        switch (dvType) {\n        case VAR_INTS:\n        case FIXED_INTS_8:\n        case FIXED_INTS_16:\n        case FIXED_INTS_32:\n        case FIXED_INTS_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().intValue(), dvType);\n          break;\n        case BYTES_FIXED_DEREF:\n        case BYTES_FIXED_STRAIGHT:\n        case BYTES_VAR_DEREF:\n        case BYTES_VAR_STRAIGHT: \n        case BYTES_FIXED_SORTED:\n        case BYTES_VAR_SORTED:\n          field2 = new DocValuesField(field1.name(), BytesRef.deepCopyOf(field1.binaryValue()), dvType);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().doubleValue(), dvType);\n          break;\n        default:\n          throw new IllegalArgumentException(\"don't know how to clone DV field=\" + field1);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      Field field1 = (Field) f;\n      \n      Field field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      if (field1 instanceof DocValuesField) {\n        final DocValues.Type dvType = field1.fieldType().docValueType();\n        switch (dvType) {\n        case VAR_INTS:\n        case FIXED_INTS_8:\n        case FIXED_INTS_16:\n        case FIXED_INTS_32:\n        case FIXED_INTS_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().intValue(), dvType);\n          break;\n        case BYTES_FIXED_DEREF:\n        case BYTES_FIXED_STRAIGHT:\n        case BYTES_VAR_DEREF:\n        case BYTES_VAR_STRAIGHT: \n        case BYTES_FIXED_SORTED:\n        case BYTES_VAR_SORTED:\n          field2 = new DocValuesField(field1.name(), BytesRef.deepCopyOf(field1.binaryValue()), dvType);\n          break;\n        case FLOAT_32:\n        case FLOAT_64:\n          field2 = new DocValuesField(field1.name(), field1.numericValue().doubleValue(), dvType);\n          break;\n        default:\n          throw new IllegalArgumentException(\"don't know how to clone DV field=\" + field1);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":["86365ce8db75e42ebe10805e99e92c463fef63b6"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","date":1341839195,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04c9e68e2d2795065221b48a81227b65faf0a166","date":1358285913,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          // nocommit: not quite right!\n        case NUMERIC:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case BINARY:\n          field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        case SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          // nocommit: not quite right!\n        case NUMERIC:\n          field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case BINARY:\n          field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        case SORTED:\n          field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          // nocommit: not quite right!\n        case NUMERIC:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case BINARY:\n          field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        case SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"498626195354975ac543d575087c90185d80c813","date":1359301262,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          // nocommit: not quite right!\n        case NUMERIC:\n          field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case BINARY:\n          field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        case SORTED:\n          field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValues.Type dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n        case VAR_INTS:\n          field2 = new PackedLongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FIXED_INTS_8:\n          field2 = new ByteDocValuesField(field1.name(), field1.numericValue().byteValue());\n          break;\n        case FIXED_INTS_16:\n          field2 = new ShortDocValuesField(field1.name(), field1.numericValue().shortValue());\n          break;\n        case FIXED_INTS_32:\n          field2 = new IntDocValuesField(field1.name(), field1.numericValue().intValue());\n          break;\n        case FIXED_INTS_64:\n          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());\n          break;\n        case FLOAT_32:\n          field2 = new FloatDocValuesField(field1.name(), field1.numericValue().floatValue());\n          break;\n        case FLOAT_64:\n          field2 = new DoubleDocValuesField(field1.name(), field1.numericValue().doubleValue());\n          break;\n        case BYTES_FIXED_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_STRAIGHT:\n          field2 = new StraightBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_DEREF:\n          field2 = new DerefBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        case BYTES_FIXED_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), true);\n          break;\n        case BYTES_VAR_SORTED:\n          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue(), false);\n          break;\n        default:\n          throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","86365ce8db75e42ebe10805e99e92c463fef63b6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      final NumericType numType = field1.fieldType().numericType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else if (numType != null) {\n        switch (numType) {\n          case INT:\n            field2 = new IntField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case FLOAT:\n            field2 = new FloatField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case LONG:\n            field2 = new LongField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case DOUBLE:\n            field2 = new DoubleField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + numType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      final NumericType numType = field1.fieldType().numericType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else if (numType != null) {\n        switch (numType) {\n          case INT:\n            field2 = new IntField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case FLOAT:\n            field2 = new FloatField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case LONG:\n            field2 = new LongField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case DOUBLE:\n            field2 = new DoubleField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + numType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":5,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#cloneDocument(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#cloneDocument(Document).mjava","sourceNew":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      final NumericType numType = field1.fieldType().numericType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else if (numType != null) {\n        switch (numType) {\n          case INT:\n            field2 = new IntField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case FLOAT:\n            field2 = new FloatField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case LONG:\n            field2 = new LongField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case DOUBLE:\n            field2 = new DoubleField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + numType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","sourceOld":"  // TODO: is there a pre-existing way to do this!!!\n  public static Document cloneDocument(Document doc1) {\n    final Document doc2 = new Document();\n    for(IndexableField f : doc1.getFields()) {\n      final Field field1 = (Field) f;\n      final Field field2;\n      final DocValuesType dvType = field1.fieldType().docValueType();\n      final NumericType numType = field1.fieldType().numericType();\n      if (dvType != null) {\n        switch(dvType) {\n          case NUMERIC:\n            field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());\n            break;\n          case BINARY:\n            field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());\n          break;\n          case SORTED:\n            field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + dvType);\n        }\n      } else if (numType != null) {\n        switch (numType) {\n          case INT:\n            field2 = new IntField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case FLOAT:\n            field2 = new FloatField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case LONG:\n            field2 = new LongField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          case DOUBLE:\n            field2 = new DoubleField(field1.name(), field1.numericValue().intValue(), field1.fieldType());\n            break;\n          default:\n            throw new IllegalStateException(\"unknown Type: \" + numType);\n        }\n      } else {\n        field2 = new Field(field1.name(), field1.stringValue(), field1.fieldType());\n      }\n      doc2.add(field2);\n    }\n\n    return doc2;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["d4d69c535930b5cce125cff868d40f6373dc27d4","59a0020b413d44dd79d85d7a66ed5004265fb453"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","86365ce8db75e42ebe10805e99e92c463fef63b6"],"6613659748fe4411a7dcf85266e55db1f95f7315":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1d028314cced5858683a1bb4741423d0f934257b":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["1d028314cced5858683a1bb4741423d0f934257b","498626195354975ac543d575087c90185d80c813"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"59a0020b413d44dd79d85d7a66ed5004265fb453":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"498626195354975ac543d575087c90185d80c813":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["04c9e68e2d2795065221b48a81227b65faf0a166"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["86365ce8db75e42ebe10805e99e92c463fef63b6"],"04c9e68e2d2795065221b48a81227b65faf0a166":["1d028314cced5858683a1bb4741423d0f934257b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["1d028314cced5858683a1bb4741423d0f934257b"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","86365ce8db75e42ebe10805e99e92c463fef63b6"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"1d028314cced5858683a1bb4741423d0f934257b":["d4d69c535930b5cce125cff868d40f6373dc27d4","04c9e68e2d2795065221b48a81227b65faf0a166"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["37a0f60745e53927c4c876cfe5b5a58170f0646c","59a0020b413d44dd79d85d7a66ed5004265fb453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6613659748fe4411a7dcf85266e55db1f95f7315"],"498626195354975ac543d575087c90185d80c813":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["498626195354975ac543d575087c90185d80c813"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","1d028314cced5858683a1bb4741423d0f934257b"],"04c9e68e2d2795065221b48a81227b65faf0a166":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}