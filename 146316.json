{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.Runner#sendUpdateStream().mjava","commits":[{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.Runner#sendUpdateStream().mjava","pathOld":"/dev/null","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n\n      try {\n        while (!queue.isEmpty()) {\n          InputStream rspBody = null;\n          try {\n            Update update;\n            notifyQueueAndRunnersIfEmptyQueue();\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n\n            if (update == null) {\n              break;\n            }\n\n            InputStreamResponseListener responseListener = null;\n            try (Http2SolrClient.OutStream out = client.initOutStream(basePath, update.getRequest(),\n                update.getCollection())) {\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                if (!out.belongToThisStream(req, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n                client.send(out, upd.getRequest(), upd.getCollection());\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n              }\n              responseListener = out.getResponseListener();\n            }\n\n            Response response = responseListener.get(client.getIdleTimeout(), TimeUnit.MILLISECONDS);\n            rspBody = responseListener.getInputStream();\n\n            int statusCode = response.getStatus();\n            if (statusCode != HttpStatus.OK_200) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getReason());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(basePath);\n\n              SolrException solrExc;\n              NamedList<String> metadata = null;\n              // parse out the metadata from the SolrException\n              try {\n                String encoding = \"UTF-8\"; // default\n                NamedList<Object> resp = client.getParser().processResponse(rspBody, encoding);\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null) {\n                  metadata = (NamedList<String>) error.get(\"metadata\");\n                  String remoteMsg = (String) error.get(\"msg\");\n                  if (remoteMsg != null) {\n                    msg.append(\"\\nRemote error message: \");\n                    msg.append(remoteMsg);\n                  }\n                }\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \" + basePath + \" due to: \" + exc);\n              } finally {\n                solrExc = new HttpSolrClient.RemoteSolrException(basePath , statusCode, msg.toString(), null);\n                if (metadata != null) {\n                  solrExc.setMetadata(metadata);\n                }\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response, rspBody);\n            }\n\n          } finally {\n            try {\n              if (rspBody != null) {\n                while (rspBody.read() != -1) {}\n              }\n            } catch (Exception e) {\n              log.error(\"Error consuming and closing http response stream.\", e);\n            }\n            notifyQueueAndRunnersIfEmptyQueue();\n          }\n        }\n      } catch (InterruptedException e) {\n        log.error(\"Interrupted on polling from queue\", e);\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fd332226a93e244bd33f35c03128eb09cbf3c88","date":1570651010,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.Runner#sendUpdateStream().mjava","sourceNew":null,"sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n\n      try {\n        while (!queue.isEmpty()) {\n          InputStream rspBody = null;\n          try {\n            Update update;\n            notifyQueueAndRunnersIfEmptyQueue();\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n\n            if (update == null) {\n              break;\n            }\n\n            InputStreamResponseListener responseListener = null;\n            try (Http2SolrClient.OutStream out = client.initOutStream(basePath, update.getRequest(),\n                update.getCollection())) {\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                if (!out.belongToThisStream(req, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n                client.send(out, upd.getRequest(), upd.getCollection());\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n              }\n              responseListener = out.getResponseListener();\n            }\n\n            Response response = responseListener.get(client.getIdleTimeout(), TimeUnit.MILLISECONDS);\n            rspBody = responseListener.getInputStream();\n\n            int statusCode = response.getStatus();\n            if (statusCode != HttpStatus.OK_200) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getReason());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(basePath);\n\n              SolrException solrExc;\n              NamedList<String> metadata = null;\n              // parse out the metadata from the SolrException\n              try {\n                String encoding = \"UTF-8\"; // default\n                NamedList<Object> resp = client.getParser().processResponse(rspBody, encoding);\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null) {\n                  metadata = (NamedList<String>) error.get(\"metadata\");\n                  String remoteMsg = (String) error.get(\"msg\");\n                  if (remoteMsg != null) {\n                    msg.append(\"\\nRemote error message: \");\n                    msg.append(remoteMsg);\n                  }\n                }\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \" + basePath + \" due to: \" + exc);\n              } finally {\n                solrExc = new HttpSolrClient.RemoteSolrException(basePath , statusCode, msg.toString(), null);\n                if (metadata != null) {\n                  solrExc.setMetadata(metadata);\n                }\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response, rspBody);\n            }\n\n          } finally {\n            try {\n              if (rspBody != null) {\n                while (rspBody.read() != -1) {}\n              }\n            } catch (Exception e) {\n              log.error(\"Error consuming and closing http response stream.\", e);\n            }\n            notifyQueueAndRunnersIfEmptyQueue();\n          }\n        }\n      } catch (InterruptedException e) {\n        log.error(\"Interrupted on polling from queue\", e);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":4,"author":"jimczi","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateHttp2SolrClient.Runner#sendUpdateStream().mjava","sourceNew":null,"sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n\n      try {\n        while (!queue.isEmpty()) {\n          InputStream rspBody = null;\n          try {\n            Update update;\n            notifyQueueAndRunnersIfEmptyQueue();\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n\n            if (update == null) {\n              break;\n            }\n\n            InputStreamResponseListener responseListener = null;\n            try (Http2SolrClient.OutStream out = client.initOutStream(basePath, update.getRequest(),\n                update.getCollection())) {\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                if (!out.belongToThisStream(req, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n                client.send(out, upd.getRequest(), upd.getCollection());\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n              }\n              responseListener = out.getResponseListener();\n            }\n\n            Response response = responseListener.get(client.getIdleTimeout(), TimeUnit.MILLISECONDS);\n            rspBody = responseListener.getInputStream();\n\n            int statusCode = response.getStatus();\n            if (statusCode != HttpStatus.OK_200) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getReason());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(basePath);\n\n              SolrException solrExc;\n              NamedList<String> metadata = null;\n              // parse out the metadata from the SolrException\n              try {\n                String encoding = \"UTF-8\"; // default\n                NamedList<Object> resp = client.getParser().processResponse(rspBody, encoding);\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null) {\n                  metadata = (NamedList<String>) error.get(\"metadata\");\n                  String remoteMsg = (String) error.get(\"msg\");\n                  if (remoteMsg != null) {\n                    msg.append(\"\\nRemote error message: \");\n                    msg.append(remoteMsg);\n                  }\n                }\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \" + basePath + \" due to: \" + exc);\n              } finally {\n                solrExc = new HttpSolrClient.RemoteSolrException(basePath , statusCode, msg.toString(), null);\n                if (metadata != null) {\n                  solrExc.setMetadata(metadata);\n                }\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response, rspBody);\n            }\n\n          } finally {\n            try {\n              if (rspBody != null) {\n                while (rspBody.read() != -1) {}\n              }\n            } catch (Exception e) {\n              log.error(\"Error consuming and closing http response stream.\", e);\n            }\n            notifyQueueAndRunnersIfEmptyQueue();\n          }\n        }\n      } catch (InterruptedException e) {\n        log.error(\"Interrupted on polling from queue\", e);\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2fd332226a93e244bd33f35c03128eb09cbf3c88":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2fd332226a93e244bd33f35c03128eb09cbf3c88"],"b0b597c65628ca9e73913a07e81691f8229bae35":["1a77e5e21cbd575a8240b0e3926164f15295f4e8","2fd332226a93e244bd33f35c03128eb09cbf3c88"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["2fd332226a93e244bd33f35c03128eb09cbf3c88","b0b597c65628ca9e73913a07e81691f8229bae35"],"2fd332226a93e244bd33f35c03128eb09cbf3c88":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}