{"path":"solr/core/src/test/org/apache/solr/cloud/TestLockTree#testLocks().mjava","commits":[{"id":"781578ca5d3d2194bc55fc3457c62aef623db6f2","date":1464859077,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLockTree#testLocks().mjava","pathOld":"/dev/null","sourceNew":"  public void testLocks() throws Exception {\n    LockTree lockTree = new LockTree();\n    Lock coll1Lock = lockTree.getSession().lock(CollectionAction.CREATE,\n        Arrays.asList(\"coll1\"));\n    assertNotNull(coll1Lock);\n    assertNull(\"Should not be able to lock coll1/shard1\", lockTree.getSession().lock(CollectionAction.BALANCESHARDUNIQUE,\n        Arrays.asList(\"coll1\", \"shard1\")));\n\n    assertNull(lockTree.getSession().lock(ADDREPLICAPROP,\n        Arrays.asList(\"coll1\", \"shard1\", \"core_node2\")));\n    coll1Lock.unlock();\n    Lock shard1Lock = lockTree.getSession().lock(CollectionAction.BALANCESHARDUNIQUE,\n        Arrays.asList(\"coll1\", \"shard1\"));\n    assertNotNull(shard1Lock);\n    shard1Lock.unlock();\n    Lock replica1Lock = lockTree.getSession().lock(ADDREPLICAPROP,\n        Arrays.asList(\"coll1\", \"shard1\", \"core_node2\"));\n    assertNotNull(replica1Lock);\n\n\n    List<Pair<CollectionAction, List<String>>> operations = new ArrayList<>();\n    operations.add(new Pair<>(ADDREPLICAPROP, Arrays.asList(\"coll1\", \"shard1\", \"core_node2\")));\n    operations.add(new Pair<>(MODIFYCOLLECTION, Arrays.asList(\"coll1\")));\n    operations.add(new Pair<>(SPLITSHARD, Arrays.asList(\"coll1\", \"shard1\")));\n    operations.add(new Pair<>(SPLITSHARD, Arrays.asList(\"coll2\", \"shard2\")));\n    operations.add(new Pair<>(MODIFYCOLLECTION, Arrays.asList(\"coll2\")));\n    operations.add(new Pair<>(DELETEREPLICA, Arrays.asList(\"coll2\", \"shard1\")));\n\n    List<Set<String>> orderOfExecution = Arrays.asList(\n        ImmutableSet.of(\"coll1/shard1/core_node2\", \"coll2/shard2\"),\n        ImmutableSet.of(\"coll1\", \"coll2\"),\n        ImmutableSet.of(\"coll1/shard1\", \"coll2/shard1\"));\n    lockTree = new LockTree();\n    for (int counter = 0; counter < orderOfExecution.size(); counter++) {\n      LockTree.Session session = lockTree.getSession();\n      List<Pair<CollectionAction, List<String>>> completedOps = new CopyOnWriteArrayList<>();\n      List<Lock> locks = new CopyOnWriteArrayList<>();\n      List<Thread> threads = new ArrayList<>();\n      for (int i = 0; i < operations.size(); i++) {\n        Pair<CollectionAction, List<String>> operation = operations.get(i);\n        final Lock lock = session.lock(operation.first(), operation.second());\n        if (lock != null) {\n          Thread thread = new Thread(getRunnable(completedOps, operation, locks, lock));\n          threads.add(thread);\n          thread.start();\n        }\n      }\n\n\n      for (Thread thread : threads) thread.join();\n      if (locks.isEmpty())\n        throw new RuntimeException(\"Could not attain lock for anything \" + operations);\n\n      Set<String> expectedOps = orderOfExecution.get(counter);\n      log.info(\"counter : {} , expected : {}, actual : {}\", counter, expectedOps, locks);\n      assertEquals(expectedOps.size(), locks.size());\n      for (Lock lock : locks)\n        assertTrue(\"locks : \" + locks + \" expectedOps : \" + expectedOps, expectedOps.contains(lock.toString()));\n      locks.clear();\n      for (Pair<CollectionAction, List<String>> completedOp : completedOps) {\n        operations.remove(completedOp);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestLockTree#testLocks().mjava","pathOld":"/dev/null","sourceNew":"  public void testLocks() throws Exception {\n    LockTree lockTree = new LockTree();\n    Lock coll1Lock = lockTree.getSession().lock(CollectionAction.CREATE,\n        Arrays.asList(\"coll1\"));\n    assertNotNull(coll1Lock);\n    assertNull(\"Should not be able to lock coll1/shard1\", lockTree.getSession().lock(CollectionAction.BALANCESHARDUNIQUE,\n        Arrays.asList(\"coll1\", \"shard1\")));\n\n    assertNull(lockTree.getSession().lock(ADDREPLICAPROP,\n        Arrays.asList(\"coll1\", \"shard1\", \"core_node2\")));\n    coll1Lock.unlock();\n    Lock shard1Lock = lockTree.getSession().lock(CollectionAction.BALANCESHARDUNIQUE,\n        Arrays.asList(\"coll1\", \"shard1\"));\n    assertNotNull(shard1Lock);\n    shard1Lock.unlock();\n    Lock replica1Lock = lockTree.getSession().lock(ADDREPLICAPROP,\n        Arrays.asList(\"coll1\", \"shard1\", \"core_node2\"));\n    assertNotNull(replica1Lock);\n\n\n    List<Pair<CollectionAction, List<String>>> operations = new ArrayList<>();\n    operations.add(new Pair<>(ADDREPLICAPROP, Arrays.asList(\"coll1\", \"shard1\", \"core_node2\")));\n    operations.add(new Pair<>(MODIFYCOLLECTION, Arrays.asList(\"coll1\")));\n    operations.add(new Pair<>(SPLITSHARD, Arrays.asList(\"coll1\", \"shard1\")));\n    operations.add(new Pair<>(SPLITSHARD, Arrays.asList(\"coll2\", \"shard2\")));\n    operations.add(new Pair<>(MODIFYCOLLECTION, Arrays.asList(\"coll2\")));\n    operations.add(new Pair<>(DELETEREPLICA, Arrays.asList(\"coll2\", \"shard1\")));\n\n    List<Set<String>> orderOfExecution = Arrays.asList(\n        ImmutableSet.of(\"coll1/shard1/core_node2\", \"coll2/shard2\"),\n        ImmutableSet.of(\"coll1\", \"coll2\"),\n        ImmutableSet.of(\"coll1/shard1\", \"coll2/shard1\"));\n    lockTree = new LockTree();\n    for (int counter = 0; counter < orderOfExecution.size(); counter++) {\n      LockTree.Session session = lockTree.getSession();\n      List<Pair<CollectionAction, List<String>>> completedOps = new CopyOnWriteArrayList<>();\n      List<Lock> locks = new CopyOnWriteArrayList<>();\n      List<Thread> threads = new ArrayList<>();\n      for (int i = 0; i < operations.size(); i++) {\n        Pair<CollectionAction, List<String>> operation = operations.get(i);\n        final Lock lock = session.lock(operation.first(), operation.second());\n        if (lock != null) {\n          Thread thread = new Thread(getRunnable(completedOps, operation, locks, lock));\n          threads.add(thread);\n          thread.start();\n        }\n      }\n\n\n      for (Thread thread : threads) thread.join();\n      if (locks.isEmpty())\n        throw new RuntimeException(\"Could not attain lock for anything \" + operations);\n\n      Set<String> expectedOps = orderOfExecution.get(counter);\n      log.info(\"counter : {} , expected : {}, actual : {}\", counter, expectedOps, locks);\n      assertEquals(expectedOps.size(), locks.size());\n      for (Lock lock : locks)\n        assertTrue(\"locks : \" + locks + \" expectedOps : \" + expectedOps, expectedOps.contains(lock.toString()));\n      locks.clear();\n      for (Pair<CollectionAction, List<String>> completedOp : completedOps) {\n        operations.remove(completedOp);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","781578ca5d3d2194bc55fc3457c62aef623db6f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["781578ca5d3d2194bc55fc3457c62aef623db6f2"],"781578ca5d3d2194bc55fc3457c62aef623db6f2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","781578ca5d3d2194bc55fc3457c62aef623db6f2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"781578ca5d3d2194bc55fc3457c62aef623db6f2":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}