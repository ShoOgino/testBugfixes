{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","commits":[{"id":"80cd0f7ec59ba200084712154a4a6fb3460344ca","date":1329830963,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            r = new MultiReader(r);\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9904ce9630c7c91c4c05a2c7c03f1b48ae42c9b4","date":1329834129,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            r = new MultiReader(r);\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e627fc5790f0ca0408c6e01ab51cb5fac2a84948","date":1329857056,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    \n    if (wasOriginallyAtomic) {\n      // TODO: investigate purging etc of tests making top-level fieldcaches,\n      // something is up if they get a crazy hierarchy\n      return r;\n    }\n\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950091930098313d0c12d5743399015cdae35158","date":1329862956,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    \n    if (wasOriginallyAtomic) {\n      // TODO: investigate purging etc of tests making top-level fieldcaches,\n      // something is up if they get a crazy hierarchy\n      return r;\n    }\n\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15d4b52394e4fc1fcf6e6bf2c8cd7126a652f5ca","date":1329909091,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  Fields f = super.fields();\n                  if (f == null) {\n                    return null;\n                  } else {\n                    return new FilterFields(f);\n                  }\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  return new FilterFields(super.fields());\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6c939a28130e1107d4e349d6c10d1a92c489662","date":1330299480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity as Parallel*Reader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: this will create FC insanity, so we patch MultiReader to\n            // return a fake cache key, so insanity checker cannot walk along our reader:\n            r = new MultiReader(r) {\n              private final Object cacheKey = new Object();\n              @Override public Object getCoreCacheKey() { return cacheKey; }\n              @Override public Object getCombinedCoreAndDeletesKey() { return cacheKey; }\n              @Override public String toString() { return \"MultiReader(\" + subReaders[0] + \")\"; }\n            };\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    // TODO: remove this, and fix those tests to wrap before putting slow around:\n    final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n    if (rarely()) {\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)\n              r = new MultiReader(r);\n            }\n            break;\n          case 3:\n            if (r instanceof AtomicReader) {\n              r = new FilterAtomicReader((AtomicReader) r) {\n                @Override\n                public Fields fields() throws IOException {\n                  Fields f = super.fields();\n                  if (f == null) {\n                    return null;\n                  } else {\n                    return new FilterFields(f);\n                  }\n                }\n              };\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n    }\n    //System.out.println(r);\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dfbab3b123144c2bf2fe399c49001108d9c721c","date":1330368339,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity as Parallel*Reader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity as Parallel*Reader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: this will create FC insanity, so we patch MultiReader to\n            // return a fake cache key, so insanity checker cannot walk along our reader:\n            r = new MultiReader(r) {\n              private final Object cacheKey = new Object();\n              @Override public Object getCoreCacheKey() { return cacheKey; }\n              @Override public Object getCombinedCoreAndDeletesKey() { return cacheKey; }\n              @Override public String toString() { return \"MultiReader(\" + subReaders[0] + \")\"; }\n            };\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf817c161e804e45b78652de78fc7ea3603cbaed","date":1330908197,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity as Parallel*Reader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3128e6d07d9fef0d1aa24f58b07133c9293131b2","date":1342190719,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader(new AssertingDirectoryReader((DirectoryReader)r));\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"071e27fa92bf27828bd1778cd4f77ad7fb65e17b","date":1342691284,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader(new AssertingDirectoryReader((DirectoryReader)r));\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b96a0c3719956f163a0a9c02d9ed7342c78a501f","date":1342804524,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new FCInvisibleMultiReader(new AssertingAtomicReader((AtomicReader)r));\n            } else if (r instanceof DirectoryReader) {\n              r = new FCInvisibleMultiReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(4)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<String>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<String>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof AtomicReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof AtomicReader) ?\n              new ParallelAtomicReader((AtomicReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final AtomicReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelAtomicReader(\n              new FieldFilterAtomicReader(ar, fields, false),\n              new FieldFilterAtomicReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof AtomicReader) {\n              r = new AssertingAtomicReader((AtomicReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9644a32526f2e2ae87543b00e8be543aa25f29c","date":1411548458,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelLeafReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelAtomicReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelAtomicReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef658003003b32165df5d5016addcee1da98e4a2","date":1419764948,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(6)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelLeafReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          case 5:\n            if (r instanceof LeafReader) {\n              r = new MismatchedLeafReader((LeafReader)r, random);\n            } else if (r instanceof DirectoryReader) {\n              r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(5)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelLeafReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8af96162d6e24bbd73a74cf381037e6aea675cd8","date":1422142293,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#maybeWrapReader(IndexReader).mjava","sourceNew":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    if (rarely()) {\n      r = wrapReader(r);\n    }\n    return r;\n  }\n\n","sourceOld":"  /**\n   * Sometimes wrap the IndexReader as slow, parallel or filter reader (or\n   * combinations of that)\n   */\n  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {\n    Random random = random();\n    if (rarely()) {\n      // TODO: remove this, and fix those tests to wrap before putting slow around:\n      final boolean wasOriginallyAtomic = r instanceof LeafReader;\n      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {\n        switch(random.nextInt(6)) {\n          case 0:\n            r = SlowCompositeReaderWrapper.wrap(r);\n            break;\n          case 1:\n            // will create no FC insanity in atomic case, as ParallelLeafReader has own cache key:\n            r = (r instanceof LeafReader) ?\n              new ParallelLeafReader((LeafReader) r) :\n              new ParallelCompositeReader((CompositeReader) r);\n            break;\n          case 2:\n            // Häckidy-Hick-Hack: a standard MultiReader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            r = new FCInvisibleMultiReader(r);\n            break;\n          case 3:\n            final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n            final List<String> allFields = new ArrayList<>();\n            for (FieldInfo fi : ar.getFieldInfos()) {\n              allFields.add(fi.name);\n            }\n            Collections.shuffle(allFields, random);\n            final int end = allFields.isEmpty() ? 0 : random.nextInt(allFields.size());\n            final Set<String> fields = new HashSet<>(allFields.subList(0, end));\n            // will create no FC insanity as ParallelLeafReader has own cache key:\n            r = new ParallelLeafReader(\n              new FieldFilterLeafReader(ar, fields, false),\n              new FieldFilterLeafReader(ar, fields, true)\n            );\n            break;\n          case 4:\n            // Häckidy-Hick-Hack: a standard Reader will cause FC insanity, so we use\n            // QueryUtils' reader with a fake cache key, so insanity checker cannot walk\n            // along our reader:\n            if (r instanceof LeafReader) {\n              r = new AssertingLeafReader((LeafReader)r);\n            } else if (r instanceof DirectoryReader) {\n              r = new AssertingDirectoryReader((DirectoryReader)r);\n            }\n            break;\n          case 5:\n            if (r instanceof LeafReader) {\n              r = new MismatchedLeafReader((LeafReader)r, random);\n            } else if (r instanceof DirectoryReader) {\n              r = new MismatchedDirectoryReader((DirectoryReader)r, random);\n            }\n            break;\n          default:\n            fail(\"should not get here\");\n        }\n      }\n      if (wasOriginallyAtomic) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      } else if ((r instanceof CompositeReader) && !(r instanceof FCInvisibleMultiReader)) {\n        // prevent cache insanity caused by e.g. ParallelCompositeReader, to fix we wrap one more time:\n        r = new FCInvisibleMultiReader(r);\n      }\n      if (VERBOSE) {\n        System.out.println(\"maybeWrapReader wrapped: \" +r);\n      }\n    }\n    return r;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b96a0c3719956f163a0a9c02d9ed7342c78a501f"],"c9644a32526f2e2ae87543b00e8be543aa25f29c":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bf817c161e804e45b78652de78fc7ea3603cbaed"],"1dfbab3b123144c2bf2fe399c49001108d9c721c":["d6c939a28130e1107d4e349d6c10d1a92c489662"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bf817c161e804e45b78652de78fc7ea3603cbaed":["1dfbab3b123144c2bf2fe399c49001108d9c721c"],"3128e6d07d9fef0d1aa24f58b07133c9293131b2":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"aba371508186796cc6151d8223a5b4e16d02e26e":["5da0b42730b6b99b31389ef94cb97384e83b9ede","b96a0c3719956f163a0a9c02d9ed7342c78a501f"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"15d4b52394e4fc1fcf6e6bf2c8cd7126a652f5ca":["950091930098313d0c12d5743399015cdae35158"],"b96a0c3719956f163a0a9c02d9ed7342c78a501f":["071e27fa92bf27828bd1778cd4f77ad7fb65e17b"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["5da0b42730b6b99b31389ef94cb97384e83b9ede","071e27fa92bf27828bd1778cd4f77ad7fb65e17b"],"8af96162d6e24bbd73a74cf381037e6aea675cd8":["ef658003003b32165df5d5016addcee1da98e4a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ef658003003b32165df5d5016addcee1da98e4a2":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"950091930098313d0c12d5743399015cdae35158":["e627fc5790f0ca0408c6e01ab51cb5fac2a84948"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","b96a0c3719956f163a0a9c02d9ed7342c78a501f"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["bf817c161e804e45b78652de78fc7ea3603cbaed"],"9904ce9630c7c91c4c05a2c7c03f1b48ae42c9b4":["80cd0f7ec59ba200084712154a4a6fb3460344ca"],"d6c939a28130e1107d4e349d6c10d1a92c489662":["15d4b52394e4fc1fcf6e6bf2c8cd7126a652f5ca"],"80cd0f7ec59ba200084712154a4a6fb3460344ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"071e27fa92bf27828bd1778cd4f77ad7fb65e17b":["3128e6d07d9fef0d1aa24f58b07133c9293131b2"],"e627fc5790f0ca0408c6e01ab51cb5fac2a84948":["9904ce9630c7c91c4c05a2c7c03f1b48ae42c9b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8af96162d6e24bbd73a74cf381037e6aea675cd8"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9644a32526f2e2ae87543b00e8be543aa25f29c":["ef658003003b32165df5d5016addcee1da98e4a2"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"1dfbab3b123144c2bf2fe399c49001108d9c721c":["bf817c161e804e45b78652de78fc7ea3603cbaed"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["c9644a32526f2e2ae87543b00e8be543aa25f29c"],"bf817c161e804e45b78652de78fc7ea3603cbaed":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3128e6d07d9fef0d1aa24f58b07133c9293131b2":["071e27fa92bf27828bd1778cd4f77ad7fb65e17b"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["3128e6d07d9fef0d1aa24f58b07133c9293131b2","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"15d4b52394e4fc1fcf6e6bf2c8cd7126a652f5ca":["d6c939a28130e1107d4e349d6c10d1a92c489662"],"b96a0c3719956f163a0a9c02d9ed7342c78a501f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","80cd0f7ec59ba200084712154a4a6fb3460344ca"],"8af96162d6e24bbd73a74cf381037e6aea675cd8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"950091930098313d0c12d5743399015cdae35158":["15d4b52394e4fc1fcf6e6bf2c8cd7126a652f5ca"],"ef658003003b32165df5d5016addcee1da98e4a2":["8af96162d6e24bbd73a74cf381037e6aea675cd8"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"9904ce9630c7c91c4c05a2c7c03f1b48ae42c9b4":["e627fc5790f0ca0408c6e01ab51cb5fac2a84948"],"d6c939a28130e1107d4e349d6c10d1a92c489662":["1dfbab3b123144c2bf2fe399c49001108d9c721c"],"80cd0f7ec59ba200084712154a4a6fb3460344ca":["9904ce9630c7c91c4c05a2c7c03f1b48ae42c9b4"],"071e27fa92bf27828bd1778cd4f77ad7fb65e17b":["b96a0c3719956f163a0a9c02d9ed7342c78a501f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"e627fc5790f0ca0408c6e01ab51cb5fac2a84948":["950091930098313d0c12d5743399015cdae35158"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}