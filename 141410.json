{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","commits":[{"id":"82235a501cff963da53cb98d86009e33e15cf47f","date":1459788663,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = LatLonPoint.encodeLatitude(box.minLat);\n      int maxLat = LatLonPoint.encodeLatitude(box.maxLat);\n      int minLon = LatLonPoint.encodeLongitude(box.minLon);\n      int maxLon = LatLonPoint.encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(LatLonPoint.decodeLatitude(lat), \n                                            LatLonPoint.decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bc0f1175d994495cbd5763445c91c22f543d8687"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = LatLonPoint.encodeLatitude(box.minLat);\n      int maxLat = LatLonPoint.encodeLatitude(box.maxLat);\n      int minLon = LatLonPoint.encodeLongitude(box.minLon);\n      int maxLon = LatLonPoint.encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(LatLonPoint.decodeLatitude(lat), \n                                            LatLonPoint.decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","date":1460056040,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = LatLonPoint.encodeLatitude(box.minLat);\n      int maxLat = LatLonPoint.encodeLatitude(box.maxLat);\n      int minLon = LatLonPoint.encodeLongitude(box.minLon);\n      int maxLon = LatLonPoint.encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(LatLonPoint.decodeLatitude(lat), \n                                            LatLonPoint.decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09f15823cf5eb6e807005579e875e117d8598f95","date":1460066385,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = LatLonPoint.encodeLatitude(box.minLat);\n      int maxLat = LatLonPoint.encodeLatitude(box.maxLat);\n      int minLon = LatLonPoint.encodeLongitude(box.minLon);\n      int maxLon = LatLonPoint.encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(LatLonPoint.decodeLatitude(lat), \n                                            LatLonPoint.decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b354f9ab8013d7a8ec8c652cef5f86f635c8443b","date":1460558006,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 100; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc0f1175d994495cbd5763445c91c22f543d8687","date":1461352263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, LatLonTree.build(polygon));\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":["82235a501cff963da53cb98d86009e33e15cf47f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":null,"sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, LatLonTree.build(polygon));\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonGrid#testRandom().mjava","sourceNew":null,"sourceOld":"  /** If the grid returns true, then any point in that cell should return true as well */\n  public void testRandom() throws Exception {\n    for (int i = 0; i < 1000; i++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Rectangle box = Rectangle.fromPolygon(new Polygon[] { polygon });\n      int minLat = encodeLatitude(box.minLat);\n      int maxLat = encodeLatitude(box.maxLat);\n      int minLon = encodeLongitude(box.minLon);\n      int maxLon = encodeLongitude(box.maxLon);\n      LatLonGrid grid = new LatLonGrid(minLat, maxLat, minLon, maxLon, polygon);\n      // we are in integer space... but exhaustive testing is slow!\n      for (int j = 0; j < 10000; j++) {\n        int lat = TestUtil.nextInt(random(), minLat, maxLat);\n        int lon = TestUtil.nextInt(random(), minLon, maxLon);\n\n        boolean expected = polygon.contains(decodeLatitude(lat),\n                                            decodeLongitude(lon));\n        boolean actual = grid.contains(lat, lon);\n        assertEquals(expected, actual);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"82235a501cff963da53cb98d86009e33e15cf47f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","82235a501cff963da53cb98d86009e33e15cf47f"],"b354f9ab8013d7a8ec8c652cef5f86f635c8443b":["09f15823cf5eb6e807005579e875e117d8598f95"],"bc0f1175d994495cbd5763445c91c22f543d8687":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["09f15823cf5eb6e807005579e875e117d8598f95","b354f9ab8013d7a8ec8c652cef5f86f635c8443b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","925fce43f3bac029d912b9b7de03c789e258a333"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["82235a501cff963da53cb98d86009e33e15cf47f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"09f15823cf5eb6e807005579e875e117d8598f95":["82235a501cff963da53cb98d86009e33e15cf47f","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"],"925fce43f3bac029d912b9b7de03c789e258a333":["bc0f1175d994495cbd5763445c91c22f543d8687"]},"commit2Childs":{"82235a501cff963da53cb98d86009e33e15cf47f":["09af2c9610ce53a4b25fd99344299b40318a4a1a","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","09f15823cf5eb6e807005579e875e117d8598f95"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"b354f9ab8013d7a8ec8c652cef5f86f635c8443b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"bc0f1175d994495cbd5763445c91c22f543d8687":["925fce43f3bac029d912b9b7de03c789e258a333"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["bc0f1175d994495cbd5763445c91c22f543d8687","f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["82235a501cff963da53cb98d86009e33e15cf47f","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["09f15823cf5eb6e807005579e875e117d8598f95"],"09f15823cf5eb6e807005579e875e117d8598f95":["b354f9ab8013d7a8ec8c652cef5f86f635c8443b","9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"925fce43f3bac029d912b9b7de03c789e258a333":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}