{"path":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","commits":[{"id":"11982a7b6834a8571852448312db4624c32990b5","date":1321300684,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"/dev/null","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    if (null == min) {\n      assert null == max : \"min is null but max isn't ? ==> \" + max;\n      return; // No-Op\n    }\n\n    assert null != max : \"max is null but min isn't ? ==> \" + min;\n\n    // we always use the double value, because that way the response Object class is \n    // consistent regardless of wether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n    double minD = min.doubleValue();\n    double maxD = max.doubleValue();\n\n    this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n    this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    this.min = Math.min(this.min.doubleValue(), min.doubleValue());\n    this.max = Math.max(this.max.doubleValue(), max.doubleValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9","date":1419431639,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    if (null == min) {\n      assert null == max : \"min is null but max isn't ? ==> \" + max;\n      return; // No-Op\n    }\n\n    assert null != max : \"max is null but min isn't ? ==> \" + min;\n\n    // we always use the double value, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n    double minD = min.doubleValue();\n    double maxD = max.doubleValue();\n\n    this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n    this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    if (null == min) {\n      assert null == max : \"min is null but max isn't ? ==> \" + max;\n      return; // No-Op\n    }\n\n    assert null != max : \"max is null but min isn't ? ==> \" + min;\n\n    // we always use the double value, because that way the response Object class is \n    // consistent regardless of wether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n    double minD = min.doubleValue();\n    double maxD = max.doubleValue();\n\n    this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n    this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n      }\n    }\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    if (null == min) {\n      assert null == max : \"min is null but max isn't ? ==> \" + max;\n      return; // No-Op\n    }\n\n    assert null != max : \"max is null but min isn't ? ==> \" + min;\n\n    // we always use the double value, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n    double minD = min.doubleValue();\n    double maxD = max.doubleValue();\n\n    this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n    this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c","date":1426192682,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1002283cfd29923d517db7c33e07bb54aac7acd4","date":1427211199,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"   /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    if (null == min) {\n      assert null == max : \"min is null but max isn't ? ==> \" + max;\n      return; // No-Op\n    }\n\n    assert null != max : \"max is null but min isn't ? ==> \" + min;\n\n    // we always use the double value, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n    double minD = min.doubleValue();\n    double maxD = max.doubleValue();\n\n    this.min = (null == this.min) ? minD : Math.min(this.min.doubleValue(), minD);\n    this.max = (null == this.max) ? maxD : Math.max(this.max.doubleValue(), maxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive doulbe to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a80a37ae73034270b57bfd57a44f8fcadc952fa0","date":1515440719,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":"  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":4,"author":"Mike Drob","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/component/NumericStatsValues[StatsValuesFactory]#updateMinMax(Number,Number).mjava","sourceNew":null,"sourceOld":"  @Override\n  protected void updateMinMax(Number min, Number max) {\n    // we always use the double values, because that way the response Object class is \n    // consistent regardless of whether we only have 1 value or many that we min/max\n    //\n    // TODO: would be nice to have subclasses for each type of Number ... breaks backcompat\n\n    if (computeMin) { // nested if to encourage JIT to optimize aware final var?\n      if (null != min) {\n        double minD = min.doubleValue();\n        if (null == this.min || minD < this.minD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.min = this.minD = minD;\n        }\n      }\n    }\n    if (computeMax) { // nested if to encourage JIT to optimize aware final var?\n      if (null != max) {\n        double maxD = max.doubleValue();\n        if (null == this.max || this.maxD < maxD) {\n          // Double for result & cached primitive double to minimize unboxing in future comparisons\n          this.max = this.maxD = maxD;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["11982a7b6834a8571852448312db4624c32990b5","7530de27b87b961b51f01bd1299b7004d46e8823"],"b94236357aaa22b76c10629851fe4e376e0cea82":["d470c8182e92b264680e34081b75e70a9f2b3c89","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["7530de27b87b961b51f01bd1299b7004d46e8823"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["bcf9173fd8d1b123fb45b0c7d188d0c153fb609c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1002283cfd29923d517db7c33e07bb54aac7acd4","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["1002283cfd29923d517db7c33e07bb54aac7acd4","0158ced21948b6626f733c1c42c1e18d94449789"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9","1002283cfd29923d517db7c33e07bb54aac7acd4"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9"],"7530de27b87b961b51f01bd1299b7004d46e8823":["11982a7b6834a8571852448312db4624c32990b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"11982a7b6834a8571852448312db4624c32990b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0158ced21948b6626f733c1c42c1e18d94449789":["1002283cfd29923d517db7c33e07bb54aac7acd4"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b94236357aaa22b76c10629851fe4e376e0cea82":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9"],"bcf9173fd8d1b123fb45b0c7d188d0c153fb609c":["1002283cfd29923d517db7c33e07bb54aac7acd4"],"1002283cfd29923d517db7c33e07bb54aac7acd4":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0158ced21948b6626f733c1c42c1e18d94449789"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["b94236357aaa22b76c10629851fe4e376e0cea82","a80a37ae73034270b57bfd57a44f8fcadc952fa0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["11982a7b6834a8571852448312db4624c32990b5"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["bcf9173fd8d1b123fb45b0c7d188d0c153fb609c"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"11982a7b6834a8571852448312db4624c32990b5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"60e4efc947592a22b8b79c8b7a18bfb8f1eb89b9":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d12bbc45d641864ffe03291bc30f178eb34e434c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}