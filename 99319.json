{"path":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","commits":[{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileReader(dir, IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), 1024);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), 1024);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67aadace85f701c87a4e0721eedcda25d8415a70","date":1314201925,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = dir.openCompoundInput(IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b1110660886afcc62f57e9af901cd3f5dd294bc","date":1317830374,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n          }\n\n          try {\n            DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n          }\n\n          try {\n            FieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/DefaultSegmentInfosReader#read(Directory,String,CodecProvider,SegmentInfos,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, CodecProvider codecs,\n          SegmentInfos infos, IOContext context) throws IOException {\n    IndexInput input = null;\n    try {\n      input = openInput(directory, segmentsFileName, context);\n      final int format = input.readInt();\n      infos.setFormat(format);\n  \n      // check that it is a format we can understand\n      if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM)\n        throw new IndexFormatTooOldException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n      if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT)\n        throw new IndexFormatTooNewException(segmentsFileName, format,\n          DefaultSegmentInfosWriter.FORMAT_MINIMUM, DefaultSegmentInfosWriter.FORMAT_CURRENT);\n  \n      infos.version = input.readLong(); // read version\n      infos.counter = input.readInt(); // read counter\n      if (infos.getFormat() <= DefaultSegmentInfosWriter.FORMAT_4_0) {\n        infos.setGlobalFieldMapVersion(input.readLong());\n      }\n      for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n        SegmentInfo si = new SegmentInfo(directory, format, input, codecs);\n        if (si.getVersion() == null) {\n          // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n          // 2.x segment, and an IndexFormatTooOldException will be thrown,\n          // which is what we want.\n          Directory dir = directory;\n          if (si.getDocStoreOffset() != -1) {\n            if (si.getDocStoreIsCompoundFile()) {\n              dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                  si.getDocStoreSegment(), \"\",\n                  IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n            }\n          } else if (si.getUseCompoundFile()) {\n            dir = new CompoundFileDirectory(dir,IndexFileNames.segmentFileName(\n                si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n          }\n\n          try {\n            DefaultFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n          } finally {\n            // If we opened the directory, close it\n            if (dir != directory) dir.close();\n          }\n          \n          // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n          // time the segment is read, its version won't be null and we won't\n          // need to open FieldsReader every time for each such segment.\n          si.setVersion(\"3.0\");\n        } else if (si.getVersion().equals(\"2.x\")) {\n          // If it's a 3x index touched by 3.1+ code, then segments record their\n          // version, whether they are 2.x ones or not. We detect that and throw\n          // appropriate exception.\n          throw new IndexFormatTooOldException(si.name, si.getVersion());\n        }\n        infos.add(si);\n      }\n      \n      infos.userData = input.readStringStringMap();\n      finalizeInput(input);\n      \n    } finally {\n      if (input != null) {\n        input.close();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["4b1110660886afcc62f57e9af901cd3f5dd294bc"],"67aadace85f701c87a4e0721eedcda25d8415a70":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b1110660886afcc62f57e9af901cd3f5dd294bc":["67aadace85f701c87a4e0721eedcda25d8415a70"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"67aadace85f701c87a4e0721eedcda25d8415a70":["4b1110660886afcc62f57e9af901cd3f5dd294bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","5d004d0e0b3f65bb40da76d476d659d7888270e8","ddc4c914be86e34b54f70023f45a60fa7f04e929","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"4b1110660886afcc62f57e9af901cd3f5dd294bc":["7b91922b55d15444d554721b352861d028eb8278"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["67aadace85f701c87a4e0721eedcda25d8415a70","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}