{"path":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"/dev/null","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  abstract public void delete(int docNum) throws IOException;\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fb2e14da294a8c919c6356cbbc8049158c368a7","date":1013197182,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  public synchronized final void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  abstract public void delete(int docNum) throws IOException;\n\n","bugFix":null,"bugIntro":["ff150a6da6c43f093044f7717b36fd565b99634d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03ae70812bc33b0270c1366378b2c2da95fe86a6","date":1036648540,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  public synchronized final void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6dbb14e9adf67f0e8fb9cc55a25a71063c230338","date":1051751355,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"693a4c06f749274d170a2e87d4afb2709a810f46","date":1060700703,"type":3,"author":"Scott Ganyo","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain())\t\t\t  // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47f3057137fcb91417c83b50600b934bd0f34c68","date":1064526111,"type":3,"author":"Dmitry Serebrennikov","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"18a2a015b86d022024b2b712bd8b607afccbb881","date":1066054947,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"IndexWriter.WRITE_LOCK_NAME\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"write.lock\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc97c3750bb1acfa4dc8d7289e664ac0210c4f93","date":1066387782,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(\"IndexWriter.WRITE_LOCK_NAME\");\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6","date":1069355441,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(stale)\n      throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      \n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(segmentInfos != null  && SegmentInfos.readCurrentVersion(directory) > segmentInfos.getVersion()){\n          stale = true;\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(lastModified(directory) > segmentInfosAge){\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\n            \"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770281b8a8459cafcdd2354b6a06078fea2d83c9","date":1077308096,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   deleted it will not appear in TermDocs or TermPostitions enumerations.\n   Attempts to read its field with the {@link #document}\n   method will result in an error.  The presence of this document may still be\n   reflected in the {@link #docFreq} statistic, though\n   this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (stale)\n      throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if (segmentInfos != null && SegmentInfos.readCurrentVersion(directory) > segmentInfos.getVersion()) {\n        stale = true;\n        this.writeLock.release();\n        this.writeLock = null;\n        throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n    deleted it will not appear in TermDocs or TermPostitions enumerations.\n    Attempts to read its field with the {@link #document}\n    method will result in an error.  The presence of this document may still be\n    reflected in the {@link #docFreq} statistic, though\n    this will be corrected eventually as the index is further modified.\n  */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(stale)\n      throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      \n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if(segmentInfos != null  && SegmentInfos.readCurrentVersion(directory) > segmentInfos.getVersion()){\n          stale = true;\n          this.writeLock.release();\n          this.writeLock = null;\n          throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f653aecb322b74d99e6ecdb93765e453a3d7aa71","date":1082107025,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   deleted it will not appear in TermDocs or TermPostitions enumerations.\n   Attempts to read its field with the {@link #document}\n   method will result in an error.  The presence of this document may still be\n   reflected in the {@link #docFreq} statistic, though\n   this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(directoryOwner)\n      aquireWriteLock();\n    doDelete(docNum);\n    hasChanges = true;\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   deleted it will not appear in TermDocs or TermPostitions enumerations.\n   Attempts to read its field with the {@link #document}\n   method will result in an error.  The presence of this document may still be\n   reflected in the {@link #docFreq} statistic, though\n   this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if (stale)\n      throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n\n    if (writeLock == null) {\n      Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);\n      if (!writeLock.obtain(IndexWriter.WRITE_LOCK_TIMEOUT)) // obtain write lock\n        throw new IOException(\"Index locked for write: \" + writeLock);\n      this.writeLock = writeLock;\n\n      // we have to check whether index has changed since this reader was opened.\n      // if so, this reader is no longer valid for deletion\n      if (segmentInfos != null && SegmentInfos.readCurrentVersion(directory) > segmentInfos.getVersion()) {\n        stale = true;\n        this.writeLock.release();\n        this.writeLock = null;\n        throw new IOException(\"IndexReader out of date and no longer valid for deletion\");\n      }\n    }\n    doDelete(docNum);\n  }\n\n","bugFix":null,"bugIntro":["ff150a6da6c43f093044f7717b36fd565b99634d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec9ae8cafc8006554fd1fcc13f8a3bff3517ebd6","date":1117912671,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   * deleted it will not appear in TermDocs or TermPostitions enumerations.\n   * Attempts to read its field with the {@link #document}\n   * method will result in an error.  The presence of this document may still be\n   * reflected in the {@link #docFreq} statistic, though\n   * this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(directoryOwner)\n      aquireWriteLock();\n    doDelete(docNum);\n    hasChanges = true;\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   deleted it will not appear in TermDocs or TermPostitions enumerations.\n   Attempts to read its field with the {@link #document}\n   method will result in an error.  The presence of this document may still be\n   reflected in the {@link #docFreq} statistic, though\n   this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(directoryOwner)\n      aquireWriteLock();\n    doDelete(docNum);\n    hasChanges = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff150a6da6c43f093044f7717b36fd565b99634d","date":1134001320,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   * deleted it will not appear in TermDocs or TermPostitions enumerations.\n   * Attempts to read its field with the {@link #document}\n   * method will result in an error.  The presence of this document may still be\n   * reflected in the {@link #docFreq} statistic, though\n   * this will be corrected eventually as the index is further modified.\n   *\n   * @deprecated Use {@link #deleteDocument(int docNum)} instead.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    deleteDocument(docNum);\n  }\n\n","sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   * deleted it will not appear in TermDocs or TermPostitions enumerations.\n   * Attempts to read its field with the {@link #document}\n   * method will result in an error.  The presence of this document may still be\n   * reflected in the {@link #docFreq} statistic, though\n   * this will be corrected eventually as the index is further modified.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    if(directoryOwner)\n      aquireWriteLock();\n    doDelete(docNum);\n    hasChanges = true;\n  }\n\n","bugFix":["f653aecb322b74d99e6ecdb93765e453a3d7aa71","3fb2e14da294a8c919c6356cbbc8049158c368a7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69e98ffd83f56083b99e5443ca713cd5783a2ae","date":1142955392,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexReader#delete(int).mjava","sourceNew":null,"sourceOld":"  /** Deletes the document numbered <code>docNum</code>.  Once a document is\n   * deleted it will not appear in TermDocs or TermPostitions enumerations.\n   * Attempts to read its field with the {@link #document}\n   * method will result in an error.  The presence of this document may still be\n   * reflected in the {@link #docFreq} statistic, though\n   * this will be corrected eventually as the index is further modified.\n   *\n   * @deprecated Use {@link #deleteDocument(int docNum)} instead.\n   */\n  public final synchronized void delete(int docNum) throws IOException {\n    deleteDocument(docNum);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"18a2a015b86d022024b2b712bd8b607afccbb881":["47f3057137fcb91417c83b50600b934bd0f34c68"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"693a4c06f749274d170a2e87d4afb2709a810f46":["6dbb14e9adf67f0e8fb9cc55a25a71063c230338"],"47f3057137fcb91417c83b50600b934bd0f34c68":["693a4c06f749274d170a2e87d4afb2709a810f46"],"ff150a6da6c43f093044f7717b36fd565b99634d":["ec9ae8cafc8006554fd1fcc13f8a3bff3517ebd6"],"ec9ae8cafc8006554fd1fcc13f8a3bff3517ebd6":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"fc97c3750bb1acfa4dc8d7289e664ac0210c4f93":["18a2a015b86d022024b2b712bd8b607afccbb881"],"770281b8a8459cafcdd2354b6a06078fea2d83c9":["6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6"],"6dbb14e9adf67f0e8fb9cc55a25a71063c230338":["03ae70812bc33b0270c1366378b2c2da95fe86a6"],"3fb2e14da294a8c919c6356cbbc8049158c368a7":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["ff150a6da6c43f093044f7717b36fd565b99634d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6":["fc97c3750bb1acfa4dc8d7289e664ac0210c4f93"],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["3fb2e14da294a8c919c6356cbbc8049158c368a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"]},"commit2Childs":{"18a2a015b86d022024b2b712bd8b607afccbb881":["fc97c3750bb1acfa4dc8d7289e664ac0210c4f93"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["3fb2e14da294a8c919c6356cbbc8049158c368a7"],"693a4c06f749274d170a2e87d4afb2709a810f46":["47f3057137fcb91417c83b50600b934bd0f34c68"],"47f3057137fcb91417c83b50600b934bd0f34c68":["18a2a015b86d022024b2b712bd8b607afccbb881"],"ff150a6da6c43f093044f7717b36fd565b99634d":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"ec9ae8cafc8006554fd1fcc13f8a3bff3517ebd6":["ff150a6da6c43f093044f7717b36fd565b99634d"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["ec9ae8cafc8006554fd1fcc13f8a3bff3517ebd6"],"fc97c3750bb1acfa4dc8d7289e664ac0210c4f93":["6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6"],"6dbb14e9adf67f0e8fb9cc55a25a71063c230338":["693a4c06f749274d170a2e87d4afb2709a810f46"],"770281b8a8459cafcdd2354b6a06078fea2d83c9":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"3fb2e14da294a8c919c6356cbbc8049158c368a7":["03ae70812bc33b0270c1366378b2c2da95fe86a6"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"6c1c4d5b9a1f3631a80687ab505cbb0debfe7cc6":["770281b8a8459cafcdd2354b6a06078fea2d83c9"],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["6dbb14e9adf67f0e8fb9cc55a25a71063c230338"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}