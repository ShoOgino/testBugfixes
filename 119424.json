{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","commits":[{"id":"ace9b78896617dcee984890f3300d45c539c1b15","date":1337655022,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readSegmentInfo(null, directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a917aca07a305ab70118a83e84d931503441271","date":1337826487,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readSegmentInfo(null, directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readSegmentInfo(null, directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6842f2837919389de395b2bb61824335f40e5431","date":1337865715,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readLegacySegmentInfo(directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readSegmentInfo(null, directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readLegacySegmentInfo(directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader#readLegacyInfos(SegmentInfos,Directory,IndexInput,int).mjava","sourceNew":null,"sourceOld":"  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {\n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfoPerCommit siPerCommit = reader.readLegacySegmentInfo(directory, format, input);\n      SegmentInfo si = siPerCommit.info;\n\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (Lucene3xSegmentInfoFormat.getDocStoreOffset(si) != -1) {\n          if (Lucene3xSegmentInfoFormat.getDocStoreIsCompoundFile(si)) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                Lucene3xSegmentInfoFormat.getDocStoreSegment(si), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, Lucene3xSegmentInfoFormat.getDocStoreSegment(si));\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(siPerCommit);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6842f2837919389de395b2bb61824335f40e5431"],"6a917aca07a305ab70118a83e84d931503441271":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ace9b78896617dcee984890f3300d45c539c1b15"],"6842f2837919389de395b2bb61824335f40e5431":["6a917aca07a305ab70118a83e84d931503441271"],"ace9b78896617dcee984890f3300d45c539c1b15":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"]},"commit2Childs":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"6a917aca07a305ab70118a83e84d931503441271":["6842f2837919389de395b2bb61824335f40e5431"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","ace9b78896617dcee984890f3300d45c539c1b15"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["6a917aca07a305ab70118a83e84d931503441271"],"6842f2837919389de395b2bb61824335f40e5431":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"ace9b78896617dcee984890f3300d45c539c1b15":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}