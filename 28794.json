{"path":"lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter#testRandom2().mjava","commits":[{"id":"1fe0bf6f56e53523bff126e044c05461b54b465c","date":1470249088,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter#testRandom2().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom2() {\n    // how large our alphabet is\n    int letterCount = TestUtil.nextInt(random(), 2, 10);\n\n    // how many substring fragments to use\n    int substringCount = TestUtil.nextInt(random(), 2, 10);\n    Set<BytesRef> substringsSet = new HashSet<>();\n\n    // how many strings to make\n    int stringCount = atLeast(10000);\n\n    //System.out.println(\"letterCount=\" + letterCount + \" substringCount=\" + substringCount + \" stringCount=\" + stringCount);\n    while(substringsSet.size() < substringCount) {\n      int length = TestUtil.nextInt(random(), 2, 10);\n      byte[] bytes = new byte[length];\n      for(int i=0;i<length;i++) {\n        bytes[i] = (byte) random().nextInt(letterCount);\n      }\n      BytesRef br = new BytesRef(bytes);\n      substringsSet.add(br);\n      //System.out.println(\"add substring count=\" + substringsSet.size() + \": \" + br);\n    }\n\n    BytesRef[] substrings = substringsSet.toArray(new BytesRef[substringsSet.size()]);\n    double[] chance = new double[substrings.length];\n    double sum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      chance[i] = random().nextDouble();\n      sum += chance[i];\n    }\n\n    // give each substring a random chance of occurring:\n    double accum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      accum += chance[i]/sum;\n      chance[i] = accum;\n    }\n\n    Set<BytesRef> stringsSet = new HashSet<>();\n    int iters = 0;\n    while (stringsSet.size() < stringCount && iters < stringCount*5) {\n      int count = TestUtil.nextInt(random(), 1, 5);\n      BytesRefBuilder b = new BytesRefBuilder();\n      for(int i=0;i<count;i++) {\n        double v = random().nextDouble();\n        accum = 0.0;\n        for(int j=0;j<substrings.length;j++) {\n          accum += chance[j];\n          if (accum >= v) {\n            b.append(substrings[j]);\n            break;\n          }\n        }\n      }\n      BytesRef br = b.toBytesRef();\n      stringsSet.add(br);\n      //System.out.println(\"add string count=\" + stringsSet.size() + \": \" + br);\n      iters++;\n    }\n\n    test(stringsSet.toArray(new BytesRef[stringsSet.size()]), stringsSet.size());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter#testRandom2().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom2() {\n    // how large our alphabet is\n    int letterCount = TestUtil.nextInt(random(), 2, 10);\n\n    // how many substring fragments to use\n    int substringCount = TestUtil.nextInt(random(), 2, 10);\n    Set<BytesRef> substringsSet = new HashSet<>();\n\n    // how many strings to make\n    int stringCount = atLeast(10000);\n\n    //System.out.println(\"letterCount=\" + letterCount + \" substringCount=\" + substringCount + \" stringCount=\" + stringCount);\n    while(substringsSet.size() < substringCount) {\n      int length = TestUtil.nextInt(random(), 2, 10);\n      byte[] bytes = new byte[length];\n      for(int i=0;i<length;i++) {\n        bytes[i] = (byte) random().nextInt(letterCount);\n      }\n      BytesRef br = new BytesRef(bytes);\n      substringsSet.add(br);\n      //System.out.println(\"add substring count=\" + substringsSet.size() + \": \" + br);\n    }\n\n    BytesRef[] substrings = substringsSet.toArray(new BytesRef[substringsSet.size()]);\n    double[] chance = new double[substrings.length];\n    double sum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      chance[i] = random().nextDouble();\n      sum += chance[i];\n    }\n\n    // give each substring a random chance of occurring:\n    double accum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      accum += chance[i]/sum;\n      chance[i] = accum;\n    }\n\n    Set<BytesRef> stringsSet = new HashSet<>();\n    int iters = 0;\n    while (stringsSet.size() < stringCount && iters < stringCount*5) {\n      int count = TestUtil.nextInt(random(), 1, 5);\n      BytesRefBuilder b = new BytesRefBuilder();\n      for(int i=0;i<count;i++) {\n        double v = random().nextDouble();\n        accum = 0.0;\n        for(int j=0;j<substrings.length;j++) {\n          accum += chance[j];\n          if (accum >= v) {\n            b.append(substrings[j]);\n            break;\n          }\n        }\n      }\n      BytesRef br = b.toBytesRef();\n      stringsSet.add(br);\n      //System.out.println(\"add string count=\" + stringsSet.size() + \": \" + br);\n      iters++;\n    }\n\n    test(stringsSet.toArray(new BytesRef[stringsSet.size()]), stringsSet.size());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter#testRandom2().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom2() {\n    // how large our alphabet is\n    int letterCount = TestUtil.nextInt(random(), 2, 10);\n\n    // how many substring fragments to use\n    int substringCount = TestUtil.nextInt(random(), 2, 10);\n    Set<BytesRef> substringsSet = new HashSet<>();\n\n    // how many strings to make\n    int stringCount = atLeast(10000);\n\n    //System.out.println(\"letterCount=\" + letterCount + \" substringCount=\" + substringCount + \" stringCount=\" + stringCount);\n    while(substringsSet.size() < substringCount) {\n      int length = TestUtil.nextInt(random(), 2, 10);\n      byte[] bytes = new byte[length];\n      for(int i=0;i<length;i++) {\n        bytes[i] = (byte) random().nextInt(letterCount);\n      }\n      BytesRef br = new BytesRef(bytes);\n      substringsSet.add(br);\n      //System.out.println(\"add substring count=\" + substringsSet.size() + \": \" + br);\n    }\n\n    BytesRef[] substrings = substringsSet.toArray(new BytesRef[substringsSet.size()]);\n    double[] chance = new double[substrings.length];\n    double sum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      chance[i] = random().nextDouble();\n      sum += chance[i];\n    }\n\n    // give each substring a random chance of occurring:\n    double accum = 0.0;\n    for(int i=0;i<substrings.length;i++) {\n      accum += chance[i]/sum;\n      chance[i] = accum;\n    }\n\n    Set<BytesRef> stringsSet = new HashSet<>();\n    int iters = 0;\n    while (stringsSet.size() < stringCount && iters < stringCount*5) {\n      int count = TestUtil.nextInt(random(), 1, 5);\n      BytesRefBuilder b = new BytesRefBuilder();\n      for(int i=0;i<count;i++) {\n        double v = random().nextDouble();\n        accum = 0.0;\n        for(int j=0;j<substrings.length;j++) {\n          accum += chance[j];\n          if (accum >= v) {\n            b.append(substrings[j]);\n            break;\n          }\n        }\n      }\n      BytesRef br = b.toBytesRef();\n      stringsSet.add(br);\n      //System.out.println(\"add string count=\" + stringsSet.size() + \": \" + br);\n      iters++;\n    }\n\n    test(stringsSet.toArray(new BytesRef[stringsSet.size()]), stringsSet.size());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1fe0bf6f56e53523bff126e044c05461b54b465c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1fe0bf6f56e53523bff126e044c05461b54b465c"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1fe0bf6f56e53523bff126e044c05461b54b465c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1fe0bf6f56e53523bff126e044c05461b54b465c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1fe0bf6f56e53523bff126e044c05461b54b465c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"1fe0bf6f56e53523bff126e044c05461b54b465c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}