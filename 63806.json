{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,String).mjava","commits":[{"id":"b11b097f011a298f1a54676482032c2b261e26f3","date":1411698138,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, String segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    String id = in.readString();\n    if (!id.equals(segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + segmentID + \", got=\" + id, in);\n    }\n    return version;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkSegmentHeader(DataInput,String,int,int,String).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, byte[])\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    in.readBytes(id, 0, id.length);\n    if (!Arrays.equals(id, segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + StringHelper.idToString(segmentID) \n                                                                 + \", got=\" + StringHelper.idToString(id), in);\n    }\n    return version;\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeSegmentHeader(DataOutput, String, int, String)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code>,\n   * expected version range (<code>minVersion to maxVersion</code>),\n   * and segment ID.\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @param segmentID The expected segment this file belongs to.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>, \n   *         and matching <code>segmentID</code>\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>, or if the <code>segmentID</code>\n   *         does not match.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeSegmentHeader(DataOutput, String, int, String)\n   */\n  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, String segmentID) throws IOException {\n    int version = checkHeader(in, codec, minVersion, maxVersion);\n    String id = in.readString();\n    if (!id.equals(segmentID)) {\n      throw new CorruptIndexException(\"file mismatch, expected segment id=\" + segmentID + \", got=\" + id, in);\n    }\n    return version;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["b11b097f011a298f1a54676482032c2b261e26f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b11b097f011a298f1a54676482032c2b261e26f3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b11b097f011a298f1a54676482032c2b261e26f3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b11b097f011a298f1a54676482032c2b261e26f3":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}