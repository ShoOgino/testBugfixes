{"path":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","commits":[{"id":"240c2c222c1b7eb253bd7e596c2d4731355836ef","date":1416366514,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlySegmentReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlySegmentReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":["240c2c222c1b7eb253bd7e596c2d4731355836ef"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      Bits docsWithField = r.getDocsWithField(\"ndv\");\n      assertNotNull(docsWithField);\n      assertTrue(docsWithField.get(0));\n      assertEquals(5L, ndv.get(0));\n      assertFalse(docsWithField.get(1));\n      assertEquals(0L, ndv.get(1));\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates#testUpdateSegmentWithNoDocValues2().mjava","sourceNew":"  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateSegmentWithNoDocValues2() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    // prevent merges, otherwise by the time updates are applied\n    // (writer.close()), the segments might have merged and that update becomes\n    // legit.\n    conf.setMergePolicy(NoMergePolicy.INSTANCE);\n    IndexWriter writer = new IndexWriter(dir, conf);\n    \n    // first segment with NDV\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"doc0\", Store.NO));\n    doc.add(new NumericDocValuesField(\"ndv\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc4\", Store.NO)); // document without 'ndv' field\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // second segment with no NDV, but another dv field \"foo\"\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc1\", Store.NO));\n    doc.add(new NumericDocValuesField(\"foo\", 3));\n    writer.addDocument(doc);\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"doc2\", Store.NO)); // document that isn't updated\n    writer.addDocument(doc);\n    writer.commit();\n    \n    // update document in the first segment - should not affect docsWithField of\n    // the document without NDV field\n    writer.updateNumericDocValue(new Term(\"id\", \"doc0\"), \"ndv\", 5L);\n    \n    // update document in the second segment - field should be added and we should\n    // be able to handle the other document correctly (e.g. no NPE)\n    writer.updateNumericDocValue(new Term(\"id\", \"doc1\"), \"ndv\", 5L);\n    writer.close();\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    for (LeafReaderContext context : reader.leaves()) {\n      LeafReader r = context.reader();\n      NumericDocValues ndv = r.getNumericDocValues(\"ndv\");\n      assertEquals(0, ndv.nextDoc());\n      assertEquals(5L, ndv.longValue());\n      assertTrue(ndv.nextDoc() > 1);\n    }\n    reader.close();\n    \n    TestUtil.checkIndex(dir);\n    \n    conf = newIndexWriterConfig(new MockAnalyzer(random()));\n    writer = new IndexWriter(dir, conf);\n    writer.forceMerge(1);\n    writer.close();\n    \n    reader = DirectoryReader.open(dir);\n    LeafReader ar = getOnlyLeafReader(reader);\n    assertEquals(DocValuesType.NUMERIC, ar.getFieldInfos().fieldInfo(\"foo\").getDocValuesType());\n    IndexSearcher searcher = new IndexSearcher(reader);\n    TopFieldDocs td;\n    // doc0\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc0\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc1\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc1\")), 1, \n                         new Sort(new SortField(\"ndv\", SortField.Type.LONG), new SortField(\"foo\", SortField.Type.LONG)));\n    assertEquals(5L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    assertEquals(3L, ((FieldDoc)td.scoreDocs[0]).fields[1]);\n    // doc2\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc2\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    // doc4\n    td = searcher.search(new TermQuery(new Term(\"id\", \"doc4\")), 1, \n        new Sort(new SortField(\"ndv\", SortField.Type.LONG)));\n    assertEquals(0L, ((FieldDoc)td.scoreDocs[0]).fields[0]);\n    reader.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["240c2c222c1b7eb253bd7e596c2d4731355836ef"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["240c2c222c1b7eb253bd7e596c2d4731355836ef"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}