{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","commits":[{"id":"381d580ec52adb3c6976ebe95b15943af3af7dcb","date":1331480752,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.type();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd0f953fbccd59aa346f280fe7e30a698f5ecb04","date":1331511349,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","sourceNew":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.type();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99275efa2c9c9ae3bdba986218af82f2bf3dc30","date":1354658499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","sourceNew":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private static void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","sourceNew":null,"sourceOld":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private static void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52c580dd9b6b94ad7fded2b22756ec57fe25982a","date":1359054635,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","sourceNew":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int maxOrd = sortedValues.getValueCount() - 1;\n      FixedBitSet seenOrds = new FixedBitSet(sortedValues.getValueCount());\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > maxOrd) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n        seenOrds.set(ord);\n      }\n      if (seenOrds.cardinality() != sortedValues.getValueCount()) {\n        // TODO: find the bug here and figure out a workaround (we can implement in LUCENE-4547's back compat layer maybe)\n        // basically ord 0 is unused by any docs: so the sortedbytes ords are all off-by-one\n        // does it always happen? e.g. maybe only if there are missing values? or a bug in its merge optimizations?\n        // throw new RuntimeException(\"dv for field: \" + fieldName + \" has holes in its ords, valueCount=\" + sortedValues.getValueCount() + \" but only used: \" + seenOrds.cardinality());\n      }\n    }\n  }\n\n","sourceOld":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > expectedDocs) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkDocValues(DocValues,String,DocValues.Type,int).mjava","sourceNew":null,"sourceOld":"  /** Helper method to verify values (either docvalues or norms), also checking\n   *  type and size against fieldinfos/segmentinfo\n   */\n  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {\n    if (docValues == null) {\n      throw new RuntimeException(\"field: \" + fieldName + \" omits docvalues but should have them!\");\n    }\n    DocValues.Type type = docValues.getType();\n    if (type != expectedType) {\n      throw new RuntimeException(\"field: \" + fieldName + \" has type: \" + type + \" but fieldInfos says:\" + expectedType);\n    }\n    final Source values = docValues.getDirectSource();\n    int size = docValues.getValueSize();\n    for (int i = 0; i < expectedDocs; i++) {\n      switch (type) {\n      case BYTES_FIXED_SORTED:\n      case BYTES_VAR_SORTED:\n      case BYTES_FIXED_DEREF:\n      case BYTES_FIXED_STRAIGHT:\n      case BYTES_VAR_DEREF:\n      case BYTES_VAR_STRAIGHT:\n        BytesRef bytes = new BytesRef();\n        values.getBytes(i, bytes);\n        if (size != -1 && size != bytes.length) {\n          throw new RuntimeException(\"field: \" + fieldName + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n        }\n        break;\n      case FLOAT_32:\n        assert size == 4;\n        values.getFloat(i);\n        break;\n      case FLOAT_64:\n        assert size == 8;\n        values.getFloat(i);\n        break;\n      case VAR_INTS:\n        assert size == -1;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_16:\n        assert size == 2;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_32:\n        assert size == 4;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_64:\n        assert size == 8;\n        values.getInt(i);\n        break;\n      case FIXED_INTS_8:\n        assert size == 1;\n        values.getInt(i);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Field: \" + fieldName\n                    + \" - no such DocValues type: \" + type);\n      }\n    }\n    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n      // check sorted bytes\n      SortedSource sortedValues = values.asSortedSource();\n      Comparator<BytesRef> comparator = sortedValues.getComparator();\n      int maxOrd = sortedValues.getValueCount() - 1;\n      FixedBitSet seenOrds = new FixedBitSet(sortedValues.getValueCount());\n      int lastOrd = -1;\n      BytesRef lastBytes = new BytesRef();\n      for (int i = 0; i < expectedDocs; i++) {\n        int ord = sortedValues.ord(i);\n        if (ord < 0 || ord > maxOrd) {\n          throw new RuntimeException(\"field: \" + fieldName + \" ord is out of bounds: \" + ord);\n        }\n        BytesRef bytes = new BytesRef();\n        sortedValues.getByOrd(ord, bytes);\n        if (lastOrd != -1) {\n          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n          if (ordComp != bytesComp) {\n            throw new RuntimeException(\"field: \" + fieldName + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n          }\n        }\n        lastOrd = ord;\n        lastBytes = bytes;\n        seenOrds.set(ord);\n      }\n      if (seenOrds.cardinality() != sortedValues.getValueCount()) {\n        // TODO: find the bug here and figure out a workaround (we can implement in LUCENE-4547's back compat layer maybe)\n        // basically ord 0 is unused by any docs: so the sortedbytes ords are all off-by-one\n        // does it always happen? e.g. maybe only if there are missing values? or a bug in its merge optimizations?\n        // throw new RuntimeException(\"dv for field: \" + fieldName + \" has holes in its ords, valueCount=\" + sortedValues.getValueCount() + \" but only used: \" + seenOrds.cardinality());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["52c580dd9b6b94ad7fded2b22756ec57fe25982a","0837ab0472feecb3a54260729d845f839e1cbd72"],"cd0f953fbccd59aa346f280fe7e30a698f5ecb04":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"381d580ec52adb3c6976ebe95b15943af3af7dcb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"52c580dd9b6b94ad7fded2b22756ec57fe25982a":["cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"0837ab0472feecb3a54260729d845f839e1cbd72":["e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd0f953fbccd59aa346f280fe7e30a698f5ecb04":["38e3b736c7ca086d61b7dbb841c905ee115490da","e99275efa2c9c9ae3bdba986218af82f2bf3dc30","52c580dd9b6b94ad7fded2b22756ec57fe25982a"],"381d580ec52adb3c6976ebe95b15943af3af7dcb":["cd0f953fbccd59aa346f280fe7e30a698f5ecb04"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["38e3b736c7ca086d61b7dbb841c905ee115490da","381d580ec52adb3c6976ebe95b15943af3af7dcb"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["0837ab0472feecb3a54260729d845f839e1cbd72"],"52c580dd9b6b94ad7fded2b22756ec57fe25982a":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}