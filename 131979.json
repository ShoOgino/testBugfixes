{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","commits":[{"id":"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96","date":1433340999,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private int intersect(Bits acceptDocs, QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      return addAll(acceptDocs, state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          state.sndv.setDocument(docID);\n          // How many values this doc has:\n          int docValueCount = state.sndv.count();\n          for(int j=0;j<docValueCount;j++) {\n            long enc = state.sndv.valueAt(j);\n\n            int latEnc = (int) ((enc>>32) & 0xffffffffL);\n            int lonEnc = (int) (enc & 0xffffffffL);\n\n            if (latEnc >= state.latMinEnc &&\n                latEnc < state.latMaxEnc &&\n                lonEnc >= state.lonMinEnc &&\n                lonEnc < state.lonMaxEnc &&\n                (state.latLonFilter == null ||\n                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n              state.bits.set(docID);\n              hitCount++;\n\n              // Stop processing values for this doc:\n              break;\n            }\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"087ab61b67c554befcfe6f666ca3bb613eac8fe3","date":1433956986,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(Bits acceptDocs, QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(acceptDocs, state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(acceptDocs, state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          state.sndv.setDocument(docID);\n          // How many values this doc has:\n          int docValueCount = state.sndv.count();\n          for(int j=0;j<docValueCount;j++) {\n            long enc = state.sndv.valueAt(j);\n\n            int latEnc = (int) ((enc>>32) & 0xffffffffL);\n            int lonEnc = (int) (enc & 0xffffffffL);\n\n            if (latEnc >= state.latMinEnc &&\n                latEnc < state.latMaxEnc &&\n                lonEnc >= state.lonMinEnc &&\n                lonEnc < state.lonMaxEnc &&\n                (state.latLonFilter == null ||\n                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n              state.bits.set(docID);\n              hitCount++;\n\n              // Stop processing values for this doc:\n              break;\n            }\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(Bits acceptDocs, QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n\n      /*\n      System.out.println(\"A: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      return addAll(acceptDocs, state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          state.sndv.setDocument(docID);\n          // How many values this doc has:\n          int docValueCount = state.sndv.count();\n          for(int j=0;j<docValueCount;j++) {\n            long enc = state.sndv.valueAt(j);\n\n            int latEnc = (int) ((enc>>32) & 0xffffffffL);\n            int lonEnc = (int) (enc & 0xffffffffL);\n\n            if (latEnc >= state.latMinEnc &&\n                latEnc < state.latMaxEnc &&\n                lonEnc >= state.lonMinEnc &&\n                lonEnc < state.lonMaxEnc &&\n                (state.latLonFilter == null ||\n                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n              state.bits.set(docID);\n              hitCount++;\n\n              // Stop processing values for this doc:\n              break;\n            }\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(QueryState,int,int,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,QueryState,int,int,int,int,int).mjava","sourceNew":"  private int intersect(QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        state.sndv.setDocument(docID);\n        // How many values this doc has:\n        int docValueCount = state.sndv.count();\n        for(int j=0;j<docValueCount;j++) {\n          long enc = state.sndv.valueAt(j);\n\n          int latEnc = (int) ((enc>>32) & 0xffffffffL);\n          int lonEnc = (int) (enc & 0xffffffffL);\n\n          if (latEnc >= state.latMinEnc &&\n              latEnc < state.latMaxEnc &&\n              lonEnc >= state.lonMinEnc &&\n              lonEnc < state.lonMaxEnc &&\n              (state.latLonFilter == null ||\n               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n            state.bits.set(docID);\n            hitCount++;\n\n            // Stop processing values for this doc:\n            break;\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","sourceOld":"  private int intersect(Bits acceptDocs, QueryState state,\n                        int nodeID,\n                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)\n    throws IOException {\n\n    // 2.06 sec -> 1.52 sec for 225 OSM London queries:\n    if (state.latLonFilter != null) {\n      if (cellLatMinEnc > state.latMinEnc ||\n          cellLatMaxEnc < state.latMaxEnc ||\n          cellLonMinEnc > state.lonMinEnc ||\n          cellLonMaxEnc < state.lonMaxEnc) {\n        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),\n                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMinEnc),\n                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));\n        //System.out.println(\"BKD.intersect cellLat=\" + BKDTreeWriter.decodeLat(cellLatMinEnc) + \" TO \" + BKDTreeWriter.decodeLat(cellLatMaxEnc) + \", cellLon=\" + BKDTreeWriter.decodeLon(cellLonMinEnc) + \" TO \" + BKDTreeWriter.decodeLon(cellLonMaxEnc) + \" compare=\" + r);\n        if (r == Relation.OUTSIDE) {\n          // This cell is fully outside of the query shape: stop recursing\n          return 0;\n        } else if (r == Relation.INSIDE) {\n          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n          return addAll(acceptDocs, state, nodeID);\n        } else {\n          // The cell crosses the shape boundary, so we fall through and do full filtering\n        }\n      }\n    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {\n      // Optimize the case when the query fully contains this cell: we can\n      // recursively add all points without checking if they match the query:\n      return addAll(acceptDocs, state, nodeID);\n    }\n\n    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;\n    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;\n\n    int dim;\n    if (latRange >= lonRange) {\n      dim = 0;\n    } else {\n      dim = 1;\n    }\n\n    //System.out.println(\"\\nintersect node=\" + nodeID + \" vs \" + leafNodeOffset);\n\n    if (nodeID >= leafNodeOffset) {\n      // Leaf node; scan and filter all points in this block:\n      //System.out.println(\"    intersect leaf nodeID=\" + nodeID + \" vs leafNodeOffset=\" + leafNodeOffset + \" fp=\" + leafBlockFPs[nodeID-leafNodeOffset]);\n      int hitCount = 0;\n\n      //IndexInput in = leafDISI.in;\n      long fp = leafBlockFPs[nodeID-leafNodeOffset];\n      if (fp == 0) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end leaf\");\n        return 0;\n      }\n\n      /*\n      System.out.println(\"I: \" + BKDTreeWriter.decodeLat(cellLatMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLat(cellLatMaxEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMinEnc)\n                         + \" \" + BKDTreeWriter.decodeLon(cellLonMaxEnc));\n      */\n\n      state.in.seek(fp);\n\n      // How many points are stored in this leaf cell:\n      int count = state.in.readVInt();\n\n      for(int i=0;i<count;i++) {\n        int docID = state.in.readInt();\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          state.sndv.setDocument(docID);\n          // How many values this doc has:\n          int docValueCount = state.sndv.count();\n          for(int j=0;j<docValueCount;j++) {\n            long enc = state.sndv.valueAt(j);\n\n            int latEnc = (int) ((enc>>32) & 0xffffffffL);\n            int lonEnc = (int) (enc & 0xffffffffL);\n\n            if (latEnc >= state.latMinEnc &&\n                latEnc < state.latMaxEnc &&\n                lonEnc >= state.lonMinEnc &&\n                lonEnc < state.lonMaxEnc &&\n                (state.latLonFilter == null ||\n                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {\n              state.bits.set(docID);\n              hitCount++;\n\n              // Stop processing values for this doc:\n              break;\n            }\n          }\n        }\n      }\n\n      return hitCount;\n\n      // this (using BitDocIdSet.Builder) is 3.4X slower!\n      /*\n      //bits.or(leafDISI);\n      //return leafDISI.getHitCount();\n      */\n\n    } else {\n\n      int splitValue = splitValues[nodeID];\n\n      if (splitValue == Integer.MAX_VALUE) {\n        // Dead end node (adversary case):\n        //System.out.println(\"    dead-end sub-tree\");\n        return 0;\n      }\n\n      //System.out.println(\"  splitValue=\" + splitValue);\n\n      int count = 0;\n\n      if (dim == 0) {\n\n        //System.out.println(\"  split on lat=\" + splitValue);\n\n        // Inner node split on lat:\n\n        // Left node:\n        if (state.latMinEnc < splitValue) {\n          //System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n        // Right node:\n        if (state.latMaxEnc >= splitValue) {\n          //System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);\n        }\n\n      } else {\n        // Inner node split on lon:\n        assert dim == 1;\n\n        // System.out.println(\"  split on lon=\" + splitValue);\n\n        // Left node:\n        if (state.lonMinEnc < splitValue) {\n          // System.out.println(\"  recurse left\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID,\n                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);\n        }\n\n        // Right node:\n        if (state.lonMaxEnc >= splitValue) {\n          // System.out.println(\"  recurse right\");\n          count += intersect(acceptDocs, state,\n                             2*nodeID+1,\n                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);\n        }\n      }\n\n      return count;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["087ab61b67c554befcfe6f666ca3bb613eac8fe3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"087ab61b67c554befcfe6f666ca3bb613eac8fe3":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"087ab61b67c554befcfe6f666ca3bb613eac8fe3":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["087ab61b67c554befcfe6f666ca3bb613eac8fe3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}