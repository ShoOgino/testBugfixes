{"path":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","commits":[{"id":"50cdf7ad2df581562492397453567ab551cc74f9","date":1335885944,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"/dev/null","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          boolean success = false;\n          try {\n            swapReference(newReference);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a333953f2d3ad264dca2d3f4c5b46ad3077b0838"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a333953f2d3ad264dca2d3f4c5b46ad3077b0838","date":1354369573,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterMaybeRefresh();\n      if (refreshed) {\n        notifyRefreshListeners();\n      }\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          boolean success = false;\n          try {\n            swapReference(newReference);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":["50cdf7ad2df581562492397453567ab551cc74f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterMaybeRefresh();\n      if (refreshed) {\n        notifyRefreshListeners();\n      }\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          boolean success = false;\n          try {\n            swapReference(newReference);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa09157b213a620622ccae0ef62a1da45a683222","date":1359149228,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterMaybeRefresh();\n      if (refreshed) {\n        notifyRefreshListeners();\n      }\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n      }\n      afterMaybeRefresh();\n      if (refreshed) {\n        notifyRefreshListeners();\n      }\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2af44fa9bd43d5df330d6438c1af390323f7d567","date":1574847240,"type":3,"author":"Benedict Jin","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#doMaybeRefresh().mjava","sourceNew":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefresh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","sourceOld":"  private void doMaybeRefresh() throws IOException {\n    // it's ok to call lock() here (blocking) because we're supposed to get here\n    // from either maybeRefreh() or maybeRefreshBlocking(), after the lock has\n    // already been obtained. Doing that protects us from an accidental bug\n    // where this method will be called outside the scope of refreshLock.\n    // Per ReentrantLock's javadoc, calling lock() by the same thread more than\n    // once is ok, as long as unlock() is called a matching number of times.\n    refreshLock.lock();\n    boolean refreshed = false;\n    try {\n      final G reference = acquire();\n      try {\n        notifyRefreshListenersBefore();\n        G newReference = refreshIfNeeded(reference);\n        if (newReference != null) {\n          assert newReference != reference : \"refreshIfNeeded should return null if refresh wasn't needed\";\n          try {\n            swapReference(newReference);\n            refreshed = true;\n          } finally {\n            if (!refreshed) {\n              release(newReference);\n            }\n          }\n        }\n      } finally {\n        release(reference);\n        notifyRefreshListenersRefreshed(refreshed);\n      }\n      afterMaybeRefresh();\n    } finally {\n      refreshLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a333953f2d3ad264dca2d3f4c5b46ad3077b0838":["50cdf7ad2df581562492397453567ab551cc74f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["50cdf7ad2df581562492397453567ab551cc74f9","a333953f2d3ad264dca2d3f4c5b46ad3077b0838"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["aa09157b213a620622ccae0ef62a1da45a683222"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["aa09157b213a620622ccae0ef62a1da45a683222"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["407687e67faf6e1f02a211ca078d8e3eed631027","aa09157b213a620622ccae0ef62a1da45a683222"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"aa09157b213a620622ccae0ef62a1da45a683222":["a333953f2d3ad264dca2d3f4c5b46ad3077b0838"],"50cdf7ad2df581562492397453567ab551cc74f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2af44fa9bd43d5df330d6438c1af390323f7d567"]},"commit2Childs":{"a333953f2d3ad264dca2d3f4c5b46ad3077b0838":["407687e67faf6e1f02a211ca078d8e3eed631027","aa09157b213a620622ccae0ef62a1da45a683222"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50cdf7ad2df581562492397453567ab551cc74f9"],"407687e67faf6e1f02a211ca078d8e3eed631027":["dd45d4a2ee01a1932d33eec42f5272c2402da679"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["2af44fa9bd43d5df330d6438c1af390323f7d567"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"aa09157b213a620622ccae0ef62a1da45a683222":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"50cdf7ad2df581562492397453567ab551cc74f9":["a333953f2d3ad264dca2d3f4c5b46ad3077b0838","407687e67faf6e1f02a211ca078d8e3eed631027"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","dd45d4a2ee01a1932d33eec42f5272c2402da679","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}