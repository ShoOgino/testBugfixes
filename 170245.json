{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e16ac84f9e5d560008fe1554462ff8b853b3d3c","date":1520142134,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d6f92dfa9251d9da6d80ec5963a9cbecc90180","date":1530559969,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2d6b868457b26b5a2145b8441b1cfcfc0692b02","date":1534307099,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n    }\n\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n    }\n\n    cluster.injectChaos(random());\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n\n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":["a4efd3fffdd7acd625bb88e455c8097e17f75735","cc3b13b430571c2e169f98fe38e1e7666f88522d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001c311c586b01319b6442ad3471475dd773f26b","date":1544401888,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    long numFound = 0;\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n\n      numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n      if (numFound == 3) {\n        break;\n      }\n\n      Thread.sleep(500);\n    }\n    \n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout waiting to see 3 found, instead saw \" + numFound + \" for collection \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        long numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n        assertEquals(3, numFound);\n        break;\n      } catch (Exception e) {\n        // Query node can have stale clusterstate\n        log.info(\"Error when query \" + collectionName, e);\n        Thread.sleep(500);\n      }\n    }\n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout on query \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    long numFound = 0;\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n\n      numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n      if (numFound == 3) {\n        break;\n      }\n\n      Thread.sleep(500);\n    }\n    \n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout waiting to see 3 found, instead saw \" + numFound + \" for collection \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    long numFound = 0;\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n\n      numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n      if (numFound == 3) {\n        break;\n      }\n\n      Thread.sleep(500);\n    }\n    \n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout waiting to see 3 found, instead saw \" + numFound + \" for collection \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#testCollectionsAPI().mjava","sourceNew":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    long numFound = 0;\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n\n      numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n      if (numFound == 3) {\n        break;\n      }\n\n      Thread.sleep(500);\n    }\n    \n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout waiting to see 3 found, instead saw \" + numFound + \" for collection \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","sourceOld":"  @Test\n  //28-June-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // See: https://issues.apache.org/jira/browse/SOLR-12028 Tests cannot remove files on Windows machines occasionally\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 09-Aug-2018 SOLR-12028\n  public void testCollectionsAPI() throws Exception {\n\n    // create new collections rapid fire\n    int cnt = random().nextInt(TEST_NIGHTLY ? 3 : 1) + 1;\n    CollectionAdminRequest.Create[] createRequests = new CollectionAdminRequest.Create[cnt];\n    \n    class Coll {\n      String name;\n      int numShards;\n      int replicationFactor;\n    }\n    \n    List<Coll> colls = new ArrayList<>();\n\n    for (int i = 0; i < cnt; i++) {\n\n      int numShards = TestUtil.nextInt(random(), 0, cluster.getJettySolrRunners().size()) + 1;\n      int replicationFactor = TestUtil.nextInt(random(), 0, 3) + 1;\n      int maxShardsPerNode = (((numShards * replicationFactor) / cluster.getJettySolrRunners().size())) + 1;\n\n      createRequests[i]\n          = CollectionAdminRequest.createCollection(\"awhollynewcollection_\" + i, \"conf2\", numShards, replicationFactor)\n          .setMaxShardsPerNode(maxShardsPerNode);\n      createRequests[i].processAsync(cluster.getSolrClient());\n      \n      Coll coll = new Coll();\n      coll.name = \"awhollynewcollection_\" + i;\n      coll.numShards = numShards;\n      coll.replicationFactor = replicationFactor;\n      colls.add(coll);\n    }\n\n    for (Coll coll : colls) {\n      cluster.waitForActiveCollection(coll.name, coll.numShards, coll.numShards * coll.replicationFactor);\n    }\n\n    waitForStable(cnt, createRequests);\n\n    for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n      checkInstanceDirs(cluster.getJettySolrRunner(i));\n    }\n    \n    String collectionName = createRequests[random().nextInt(createRequests.length)].getCollectionName();\n    \n    // TODO: we should not need this...beast test well when trying to fix\n    Thread.sleep(1000);\n    \n    cluster.getSolrClient().getZkStateReader().forciblyRefreshAllClusterStateSlow();\n\n    new UpdateRequest()\n        .add(\"id\", \"6\")\n        .add(\"id\", \"7\")\n        .add(\"id\", \"8\")\n        .commit(cluster.getSolrClient(), collectionName);\n    long numFound = 0;\n    TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n\n      numFound = cluster.getSolrClient().query(collectionName, new SolrQuery(\"*:*\")).getResults().getNumFound();\n      if (numFound == 3) {\n        break;\n      }\n\n      Thread.sleep(500);\n    }\n    \n    if (timeOut.hasTimedOut()) {\n      fail(\"Timeout waiting to see 3 found, instead saw \" + numFound + \" for collection \" + collectionName);\n    }\n\n    checkNoTwoShardsUseTheSameIndexDir();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d2d6b868457b26b5a2145b8441b1cfcfc0692b02":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["d2d6b868457b26b5a2145b8441b1cfcfc0692b02"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["001c311c586b01319b6442ad3471475dd773f26b"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"001c311c586b01319b6442ad3471475dd773f26b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"]},"commit2Childs":{"d2d6b868457b26b5a2145b8441b1cfcfc0692b02":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"b94236357aaa22b76c10629851fe4e376e0cea82":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["001c311c586b01319b6442ad3471475dd773f26b"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["d2d6b868457b26b5a2145b8441b1cfcfc0692b02","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"001c311c586b01319b6442ad3471475dd773f26b":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}