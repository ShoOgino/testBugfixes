{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","commits":[{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private void commitMergedDeletes(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + merge.segString(directory));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    int delCount = 0;\n    long minGen = Long.MAX_VALUE;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      {\n        final SegmentReader currentReader = readerPool.getIfExists(info, IOContext.Context.READ);\n        if (currentReader != null) {\n          currentLiveDocs = (BitVector) currentReader.getLiveDocs();\n          readerPool.release(currentReader, false, IOContext.Context.READ);\n        } else {\n          assert readerPool.infoIsLive(info);\n          if (info.hasDeletions()) {\n            currentLiveDocs = new BitVector(directory,\n                                            info.getDelFileName(),\n                                            new IOContext(IOContext.Context.READ));\n          } else {\n            currentLiveDocs = null;\n          }\n        }\n      }\n\n      if (prevLiveDocs != null) {\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                mergedReader.deleteDocument(docUpto);\n                delCount++;\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            mergedReader.deleteDocument(docUpto);\n            delCount++;\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    assert mergedReader.numDeletedDocs() == delCount;\n\n    mergedReader.hasChanges = delCount > 0;\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert !mergedReader.hasChanges || minGen > mergedReader.getSegmentInfo().getBufferedDeletesGen();\n\n    mergedReader.getSegmentInfo().setBufferedDeletesGen(minGen);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef2642aa76c0d0714b26e5e7d5e3438a62db3cb7","date":1326996651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final MutableBits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final MutableBits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a16d06e7522604de20b2d758d9b9464bb30fe02","date":1327070101,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs != prevLiveDocs) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          final int readerDocCount;\n          if (i == sourceSegments.size()-1) {\n            readerDocCount = mergeState.mergedDocCount - mergeState.docBase[i];\n          } else {\n            readerDocCount = mergeState.docBase[i+1] - mergeState.docBase[i];\n          }\n          docUpto += readerDocCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final MutableBits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final MutableBits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":["36d84416fc00253f9e834f8dba14fa89b298e64e","36d84416fc00253f9e834f8dba14fa89b298e64e","c95a819869502635864dac0a788f874787e3395b","c95a819869502635864dac0a788f874787e3395b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb","date":1327773585,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge,MergeState).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += info.docCount - info.getDelCount() - rld.pendingDeleteCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += mergeState.segmentDocCounts.get(info);\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31","date":1327836826,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += info.docCount - info.getDelCount() - rld.pendingDeleteCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += info.docCount - info.getDelCount() - rld.pendingDeleteCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final BitVector prevLiveDocs = merge.readerLiveDocs.get(i);\n      final BitVector currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        if (currentLiveDocs.count() < prevLiveDocs.count()) {\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          assert currentLiveDocs.count() == prevLiveDocs.count(): \"currentLiveDocs.count()==\" + currentLiveDocs.count() + \" vs prevLiveDocs.count()=\" + prevLiveDocs.count() + \" info=\" + info;\n          docUpto += currentLiveDocs.count();\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMergedDeletes(MergePolicy.OneMerge).mjava","sourceNew":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += info.docCount - info.getDelCount() - rld.pendingDeleteCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","sourceOld":"  /** Carefully merges deletes for the segments we just\n   *  merged.  This is tricky because, although merging will\n   *  clear all deletes (compacts the documents), new\n   *  deletes may have been flushed to the segments since\n   *  the merge was started.  This method \"carries over\"\n   *  such new deletes onto the newly merged segment, and\n   *  saves the resulting deletes file (incrementing the\n   *  delete generation for merge.info).  If no deletes were\n   *  flushed, no new deletes file is saved. */\n  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMergeDeletes\");\n\n    final List<SegmentInfo> sourceSegments = merge.segments;\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMergeDeletes \" + segString(merge.segments));\n    }\n\n    // Carefully merge deletes that occurred after we\n    // started merging:\n    int docUpto = 0;\n    long minGen = Long.MAX_VALUE;\n\n    // Lazy init (only when we find a delete to carry over):\n    ReadersAndLiveDocs mergedDeletes = null;\n\n    for(int i=0; i < sourceSegments.size(); i++) {\n      SegmentInfo info = sourceSegments.get(i);\n      minGen = Math.min(info.getBufferedDeletesGen(), minGen);\n      final int docCount = info.docCount;\n      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);\n      final Bits currentLiveDocs;\n      ReadersAndLiveDocs rld = readerPool.get(info, false);\n      // We enrolled in mergeInit:\n      assert rld != null;\n      currentLiveDocs = rld.liveDocs;\n\n      if (prevLiveDocs != null) {\n\n        // If we had deletions on starting the merge we must\n        // still have deletions now:\n        assert currentLiveDocs != null;\n\n        // There were deletes on this segment when the merge\n        // started.  The merge has collapsed away those\n        // deletes, but, if new deletes were flushed since\n        // the merge started, we must now carefully keep any\n        // newly flushed deletes but mapping them to the new\n        // docIDs.\n\n        // Since we copy-on-write, if any new deletes were\n        // applied after merging has started, we can just\n        // check if the before/after liveDocs have changed.\n        // If so, we must carefully merge the liveDocs one\n        // doc at a time:\n        if (currentLiveDocs != prevLiveDocs) {\n\n          // This means this segment received new deletes\n          // since we started the merge, so we\n          // must merge them:\n          for(int j=0;j<docCount;j++) {\n            if (!prevLiveDocs.get(j)) {\n              assert !currentLiveDocs.get(j);\n            } else {\n              if (!currentLiveDocs.get(j)) {\n                if (mergedDeletes == null) {\n                  mergedDeletes = readerPool.get(merge.info, true);\n                  mergedDeletes.initWritableLiveDocs();\n                }\n                mergedDeletes.delete(docUpto);\n              }\n              docUpto++;\n            }\n          }\n        } else {\n          docUpto += info.docCount - info.getDelCount() - rld.pendingDeleteCount;\n        }\n      } else if (currentLiveDocs != null) {\n        // This segment had no deletes before but now it\n        // does:\n        for(int j=0; j<docCount; j++) {\n          if (!currentLiveDocs.get(j)) {\n            if (mergedDeletes == null) {\n              mergedDeletes = readerPool.get(merge.info, true);\n              mergedDeletes.initWritableLiveDocs();\n            }\n            mergedDeletes.delete(docUpto);\n          }\n          docUpto++;\n        }\n      } else {\n        // No deletes before or after\n        docUpto += info.docCount;\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (mergedDeletes == null) {\n        infoStream.message(\"IW\", \"no new deletes since merge started\");\n      } else {\n        infoStream.message(\"IW\", mergedDeletes.pendingDeleteCount + \" new deletes since merge started\");\n      }\n    }\n\n    // If new deletes were applied while we were merging\n    // (which happens if eg commit() or getReader() is\n    // called during our merge), then it better be the case\n    // that the delGen has increased for all our merged\n    // segments:\n    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();\n\n    merge.info.setBufferedDeletesGen(minGen);\n\n    return mergedDeletes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ef2642aa76c0d0714b26e5e7d5e3438a62db3cb7":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd92b8bcc88e969302510acf77bd6970da3994c4":["9ce667c6d3400b22523701c549c0d35e26da8b46","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":["8a16d06e7522604de20b2d758d9b9464bb30fe02"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["9ce667c6d3400b22523701c549c0d35e26da8b46","32feb7c2c571b402d2e231bd8e3b6add4af6d6eb"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["ef2642aa76c0d0714b26e5e7d5e3438a62db3cb7"]},"commit2Childs":{"ef2642aa76c0d0714b26e5e7d5e3438a62db3cb7":["8a16d06e7522604de20b2d758d9b9464bb30fe02"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":["c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fd92b8bcc88e969302510acf77bd6970da3994c4"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["ef2642aa76c0d0714b26e5e7d5e3438a62db3cb7","fd92b8bcc88e969302510acf77bd6970da3994c4","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["32feb7c2c571b402d2e231bd8e3b6add4af6d6eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}