{"path":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","commits":[{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      if (preferredFieldNumber == -1) {\n        preferredFieldNumber = findNextAvailableFieldNumber(localFieldInfos.nextAvailableNumber, localFieldInfos.byNumber.keySet());\n        localFieldInfos.nextAvailableNumber = preferredFieldNumber;\n      }\n\n      // get a global number for this field\n      int fieldNumber = globalFieldNumbers.addOrGet(name, localFieldInfos, preferredFieldNumber);\n      if (localFieldInfos.get(fieldNumber) != null) {\n        // fall back if the global number is already taken\n        fieldNumber = preferredFieldNumber;\n      }\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      if (preferredFieldNumber == -1) {\n        preferredFieldNumber = findNextAvailableFieldNumber(localFieldInfos.nextAvailableNumber, localFieldInfos.byNumber.keySet());\n        localFieldInfos.nextAvailableNumber = preferredFieldNumber;\n      }\n\n      // get a global number for this field\n      int fieldNumber = globalFieldNumbers.addOrGet(name, localFieldInfos, preferredFieldNumber);\n      if (localFieldInfos.get(fieldNumber) != null) {\n        // fall back if the global number is already taken\n        fieldNumber = preferredFieldNumber;\n      }\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      if (preferredFieldNumber == -1) {\n        preferredFieldNumber = findNextAvailableFieldNumber(localFieldInfos.nextAvailableNumber, localFieldInfos.byNumber.keySet());\n        localFieldInfos.nextAvailableNumber = preferredFieldNumber;\n      }\n\n      // get a global number for this field\n      int fieldNumber = globalFieldNumbers.addOrGet(name, localFieldInfos, preferredFieldNumber);\n      if (localFieldInfos.get(fieldNumber) != null) {\n        // fall back if the global number is already taken\n        fieldNumber = preferredFieldNumber;\n      }\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c2cf5832e0f01230bc2c4886e16887a0d1f3341","date":1301042882,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    final FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e92442af786151ee55bc283eb472f629e3c7b52b","date":1301070252,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    final FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      if (preferredFieldNumber == -1) {\n        preferredFieldNumber = findNextAvailableFieldNumber(localFieldInfos.nextAvailableNumber, localFieldInfos.byNumber.keySet());\n        localFieldInfos.nextAvailableNumber = preferredFieldNumber;\n      }\n\n      // get a global number for this field\n      int fieldNumber = globalFieldNumbers.addOrGet(name, localFieldInfos, preferredFieldNumber);\n      if (localFieldInfos.get(fieldNumber) != null) {\n        // fall back if the global number is already taken\n        fieldNumber = preferredFieldNumber;\n      }\n      return addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19ec8535092055101db3ede419e136b73d235ac","date":1302777181,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eb46686a27187e42311e77666a2c7026f461ebc","date":1302858020,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fe2fc74577855eadfb5eae3153c2fffdaaf791","date":1305237079,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    version++;\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    version++;\n    return fi;\n  }\n\n","sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n      boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n      boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    version++;\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/FieldInfos#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,boolean,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n                                                     boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,\n                                                     boolean omitNorms, boolean storePayloads, boolean omitTermFreqAndPositions) {\n    if (globalFieldNumbers == null) {\n      throw new IllegalStateException(\"FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos\");\n    }\n    assert segmentCodecsBuilder != null : \"SegmentCodecsBuilder is set to null but FieldInfos is not read-only\";\n    FieldInfo fi = fieldInfo(name);\n    if (fi == null) {\n      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);\n      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    } else {\n      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, omitTermFreqAndPositions);\n    }\n    if (fi.isIndexed && fi.getCodecId() == FieldInfo.UNASSIGNED_CODEC_ID) {\n      segmentCodecsBuilder.tryAddAndSet(fi);\n    }\n    version++;\n    return fi;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a3776dccca01c11e7046323cfad46a3b4a471233","2e8d7ba2175f47e280231533f7d3016249cea88b"],"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["e19ec8535092055101db3ede419e136b73d235ac"],"e19ec8535092055101db3ede419e136b73d235ac":["e92442af786151ee55bc283eb472f629e3c7b52b"],"5c2cf5832e0f01230bc2c4886e16887a0d1f3341":["1224a4027481acce15495b03bce9b48b93b42722"],"e92442af786151ee55bc283eb472f629e3c7b52b":["5c2cf5832e0f01230bc2c4886e16887a0d1f3341"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","e92442af786151ee55bc283eb472f629e3c7b52b"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"1eb46686a27187e42311e77666a2c7026f461ebc":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","e19ec8535092055101db3ede419e136b73d235ac"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e92442af786151ee55bc283eb472f629e3c7b52b","d3fe2fc74577855eadfb5eae3153c2fffdaaf791"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"1224a4027481acce15495b03bce9b48b93b42722":["14ec33385f6fbb6ce172882d14605790418a5d31"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"d3fe2fc74577855eadfb5eae3153c2fffdaaf791":["2e8d7ba2175f47e280231533f7d3016249cea88b","a3776dccca01c11e7046323cfad46a3b4a471233"],"e19ec8535092055101db3ede419e136b73d235ac":["d3fe2fc74577855eadfb5eae3153c2fffdaaf791","1eb46686a27187e42311e77666a2c7026f461ebc"],"5c2cf5832e0f01230bc2c4886e16887a0d1f3341":["e92442af786151ee55bc283eb472f629e3c7b52b"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e92442af786151ee55bc283eb472f629e3c7b52b":["e19ec8535092055101db3ede419e136b73d235ac","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","a3776dccca01c11e7046323cfad46a3b4a471233"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["1eb46686a27187e42311e77666a2c7026f461ebc"],"14ec33385f6fbb6ce172882d14605790418a5d31":["1224a4027481acce15495b03bce9b48b93b42722"],"1eb46686a27187e42311e77666a2c7026f461ebc":[],"a3776dccca01c11e7046323cfad46a3b4a471233":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e8d7ba2175f47e280231533f7d3016249cea88b","b0c7a8f7304b75b1528814c5820fa23a96816c27","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"1224a4027481acce15495b03bce9b48b93b42722":["5c2cf5832e0f01230bc2c4886e16887a0d1f3341"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","1eb46686a27187e42311e77666a2c7026f461ebc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}