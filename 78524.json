{"path":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","commits":[{"id":"d374631bb6f5665bd5907a6186a9bb283a315f7d","date":1336345692,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions < 0) {\n      throw new IllegalArgumentException(\"maxExpansions cannot be negative.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9f7c14f40c65357617cada58ca9b026ab9f81c24","e6f2000c32e050b40aa63fb677b9d8b41744f2ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6f2000c32e050b40aa63fb677b9d8b41744f2ee","date":1407253160,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions < 0) {\n      throw new IllegalArgumentException(\"maxExpansions cannot be negative.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","bugFix":["d374631bb6f5665bd5907a6186a9bb283a315f7d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f7c14f40c65357617cada58ca9b026ab9f81c24","date":1432120112,"type":3,"author":"Mark Harwood","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));\n  }\n\n","bugFix":["d374631bb6f5665bd5907a6186a9bb283a315f7d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, \n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e99d92de6748e3bbd2dd7b72695cdb952b2d835","date":1579100291,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    int[] codePoints = FuzzyTermsEnum.stringToUTF32(term.text());\n    this.termLength = codePoints.length;\n    this.automata = FuzzyTermsEnum.buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits);\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n    this.ramBytesUsed = calculateRamBytesUsed(term, this.automata);\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad855e2f1f69c5e330d1027a5d54f8814e47a0d6","date":1588847334,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    int[] codePoints = FuzzyTermsEnum.stringToUTF32(term.text());\n    this.termLength = codePoints.length;\n    this.automata = FuzzyTermsEnum.buildAutomata(term.text(), codePoints, prefixLength, transpositions, maxEdits);\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n    this.ramBytesUsed = calculateRamBytesUsed(term, this.automata);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5ad69699c50bdc694006291c11e9d3a195e5aa1","date":1588860600,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    if (term.text().length() == prefixLength) {\n      setRewriteAsRegExpQuery();\n    } else {\n      setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f163061e60fd2090f36724344812460ef9de32a","date":1588865299,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyQuery#FuzzyQuery(Term,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n  }\n\n","sourceOld":"  /**\n   * Create a new FuzzyQuery that will match terms with an edit distance \n   * of at most <code>maxEdits</code> to <code>term</code>.\n   * If a <code>prefixLength</code> &gt; 0 is specified, a common prefix\n   * of that length is also required.\n   * \n   * @param term the term to search for\n   * @param maxEdits must be {@code >= 0} and {@code <=} {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param prefixLength length of common (non-fuzzy) prefix\n   * @param maxExpansions the maximum number of terms to match. If this number is\n   *  greater than {@link IndexSearcher#getMaxClauseCount} when the query is rewritten,\n   *  then the maxClauseCount will be used instead.\n   * @param transpositions true if transpositions should be treated as a primitive\n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   */\n  public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, boolean transpositions) {\n    super(term.field());\n    \n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (prefixLength < 0) {\n      throw new IllegalArgumentException(\"prefixLength cannot be negative.\");\n    }\n    if (maxExpansions <= 0) {\n      throw new IllegalArgumentException(\"maxExpansions must be positive.\");\n    }\n    \n    this.term = term;\n    this.maxEdits = maxEdits;\n    this.prefixLength = prefixLength;\n    this.transpositions = transpositions;\n    this.maxExpansions = maxExpansions;\n    if (term.text().length() == prefixLength) {\n      setRewriteAsRegExpQuery();\n    } else {\n      setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3e99d92de6748e3bbd2dd7b72695cdb952b2d835":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"8f163061e60fd2090f36724344812460ef9de32a":["c5ad69699c50bdc694006291c11e9d3a195e5aa1"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["e6f2000c32e050b40aa63fb677b9d8b41744f2ee"],"9f7c14f40c65357617cada58ca9b026ab9f81c24":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad855e2f1f69c5e330d1027a5d54f8814e47a0d6":["3e99d92de6748e3bbd2dd7b72695cdb952b2d835"],"e6f2000c32e050b40aa63fb677b9d8b41744f2ee":["d374631bb6f5665bd5907a6186a9bb283a315f7d"],"d374631bb6f5665bd5907a6186a9bb283a315f7d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5ad69699c50bdc694006291c11e9d3a195e5aa1":["ad855e2f1f69c5e330d1027a5d54f8814e47a0d6"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8f163061e60fd2090f36724344812460ef9de32a"]},"commit2Childs":{"3e99d92de6748e3bbd2dd7b72695cdb952b2d835":["ad855e2f1f69c5e330d1027a5d54f8814e47a0d6"],"8f163061e60fd2090f36724344812460ef9de32a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"9f7c14f40c65357617cada58ca9b026ab9f81c24":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d374631bb6f5665bd5907a6186a9bb283a315f7d"],"e6f2000c32e050b40aa63fb677b9d8b41744f2ee":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"ad855e2f1f69c5e330d1027a5d54f8814e47a0d6":["c5ad69699c50bdc694006291c11e9d3a195e5aa1"],"d374631bb6f5665bd5907a6186a9bb283a315f7d":["e6f2000c32e050b40aa63fb677b9d8b41744f2ee"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["3e99d92de6748e3bbd2dd7b72695cdb952b2d835"],"c5ad69699c50bdc694006291c11e9d3a195e5aa1":["8f163061e60fd2090f36724344812460ef9de32a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}