{"path":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","commits":[{"id":"4e6b620c271c84c0f14919eec7b90083b292ee51","date":1419461736,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(int,ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final int seq, final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    if (seq <= intSeqs.get(0)) {\n      if(seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath+\"/\"+seqs.get(0)) ) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going be leader {} , seq(0) {}\",context.leaderSeqPath,holdElectionPath+\"/\"+seqs.get(0));//but someone else jumped the line\n        retryElection(context,false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int i = 1;\n      for (; i < intSeqs.size(); i++) {\n        int s = intSeqs.get(i);\n        if (seq < s) {\n          // we found who we come before - watch the guy in front\n          break;\n        }\n      }\n      int index = i - 2;\n      if (index < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(index);\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(seq, context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5b3e70510efc80bc67f6ad80224387e441c14ec","date":1434309371,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","date":1441124018,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n      // first we delete the node advertising the old leader in case the ephem is still there\n      try {\n        zkClient.delete(context.leaderPath, -1, true);\n      }catch (KeeperException.NoNodeException nne){\n        //no problem\n      }catch (InterruptedException e){\n        throw e;\n      } catch (Exception e) {\n        //failed to delete the leader node\n        log.error(\"leader elect delete error\",e);\n        retryElection(context, false);\n        return;\n        // fine\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ea01e15f477524516b07b300a3ae03d1bec9bc","date":1455919598,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id;\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n\n    sortSeqs(seqs);\n    List<Integer> intSeqs = getSeqs(seqs);\n    if (intSeqs.size() == 0) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.\n\n    int seq = -1;\n\n    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.\n    String newLeaderSeq = \"\";\n    for (String elec : seqs) {\n      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {\n        seq = getSeq(elec); // so use the current sequence number.\n        newLeaderSeq = elec;\n        break;\n      }\n    }\n\n    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done\n    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {\n      log.info(\"Node \" + context.leaderSeqPath + \" already in queue as \" + newLeaderSeq + \" nothing to do.\");\n      return;\n    }\n\n    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.\n    if (seq == -1) {\n      seq = getSeq(context.leaderSeqPath);\n    }\n\n    if (seq <= intSeqs.get(0)) {\n      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + \"/\" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me\n        log.info(\"was going to be leader {} , seq(0) {}\", context.leaderSeqPath, holdElectionPath + \"/\" + seqs.get(0));//but someone else jumped the line\n\n        // The problem is that deleting the ZK node that's watched by others\n        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking\n        // this happens to be after the node has already taken over leadership. So just leave out of here.\n        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure\n        // the assumption that this is a bad state is valid.\n        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {\n          return;\n        }\n        retryElection(context, false);//join at the tail again\n        return;\n      }\n\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      int toWatch = -1;\n      for (int idx = 0; idx < intSeqs.size(); idx++) {\n        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {\n          toWatch = idx;\n        }\n        if (intSeqs.get(idx) >= seq) {\n          break;\n        }\n      }\n      if (toWatch < 0) {\n        log.warn(\"Our node is no longer in line to be leader\");\n        return;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + seqs.get(toWatch);\n\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException e) {\n        log.warn(\"Failed setting watch\", e);\n        // we couldn't set our watch - the node before us may already be down?\n        // we need to check if we are the leader again\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e58679227cd51c0676b0d204921cdf7558335bd1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e58679227cd51c0676b0d204921cdf7558335bd1","date":1458581977,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id;\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":["a1ea01e15f477524516b07b300a3ae03d1bec9bc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.debug(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.debug(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.debug(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.info(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbb0b5c5101d175049b4ced1462f4c266d32fc63","date":1559534216,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/LeaderElector#checkIfIamLeader(ElectionContext,boolean).mjava","sourceNew":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        if (zkClient.isClosed()) return; // but our zkClient is already closed\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.debug(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Check if the candidate with the given n_* sequence number is the leader.\n   * If it is, set the leaderId on the leader zk node. If it is not, start\n   * watching the candidate that is in line before this one - if it goes down, check\n   * if this candidate is the leader again.\n   *\n   * @param replacement has someone else been the leader already?\n   */\n  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,\n      InterruptedException, IOException {\n    context.checkIfIamLeaderFired();\n    // get all other numbers...\n    final String holdElectionPath = context.electionPath + ELECTION_NODE;\n    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);\n    sortSeqs(seqs);\n\n    String leaderSeqNodeName = context.leaderSeqPath.substring(context.leaderSeqPath.lastIndexOf('/') + 1);\n    if (!seqs.contains(leaderSeqNodeName)) {\n      log.warn(\"Our node is no longer in line to be leader\");\n      return;\n    }\n\n    // If any double-registrations exist for me, remove all but this latest one!\n    // TODO: can we even get into this state?\n    String prefix = zkClient.getSolrZooKeeper().getSessionId() + \"-\" + context.id + \"-\";\n    Iterator<String> it = seqs.iterator();\n    while (it.hasNext()) {\n      String elec = it.next();\n      if (!elec.equals(leaderSeqNodeName) && elec.startsWith(prefix)) {\n        try {\n          String toDelete = holdElectionPath + \"/\" + elec;\n          log.warn(\"Deleting duplicate registration: {}\", toDelete);\n          zkClient.delete(toDelete, -1, true);\n        } catch (KeeperException.NoNodeException e) {\n          // ignore\n        }\n        it.remove();\n      }\n    }\n\n    if (leaderSeqNodeName.equals(seqs.get(0))) {\n      // I am the leader\n      try {\n        runIamLeaderProcess(context, replacement);\n      } catch (KeeperException.NodeExistsException e) {\n        log.error(\"node exists\",e);\n        retryElection(context, false);\n        return;\n      }\n    } else {\n      // I am not the leader - watch the node below me\n      String toWatch = seqs.get(0);\n      for (String node : seqs) {\n        if (leaderSeqNodeName.equals(node)) {\n          break;\n        }\n        toWatch = node;\n      }\n      try {\n        String watchedNode = holdElectionPath + \"/\" + toWatch;\n        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath, watchedNode, getSeq(context.leaderSeqPath), context), null, true);\n        log.debug(\"Watching path {} to know if I could be the leader\", watchedNode);\n      } catch (KeeperException.SessionExpiredException e) {\n        throw e;\n      } catch (KeeperException.NoNodeException e) {\n        // the previous node disappeared, check if we are the leader again\n        checkIfIamLeader(context, true);\n      } catch (KeeperException e) {\n        // we couldn't set our watch for some other reason, retry\n        log.warn(\"Failed setting watch\", e);\n        checkIfIamLeader(context, true);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"962cd4f5e313777f35da8f521265323e84184929":["e58679227cd51c0676b0d204921cdf7558335bd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e58679227cd51c0676b0d204921cdf7558335bd1","962cd4f5e313777f35da8f521265323e84184929"],"a1ea01e15f477524516b07b300a3ae03d1bec9bc":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["a5b3e70510efc80bc67f6ad80224387e441c14ec"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a5b3e70510efc80bc67f6ad80224387e441c14ec":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"e58679227cd51c0676b0d204921cdf7558335bd1":["a1ea01e15f477524516b07b300a3ae03d1bec9bc"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e58679227cd51c0676b0d204921cdf7558335bd1","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bbb0b5c5101d175049b4ced1462f4c266d32fc63"]},"commit2Childs":{"962cd4f5e313777f35da8f521265323e84184929":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["bbb0b5c5101d175049b4ced1462f4c266d32fc63","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a1ea01e15f477524516b07b300a3ae03d1bec9bc":["e58679227cd51c0676b0d204921cdf7558335bd1"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["a1ea01e15f477524516b07b300a3ae03d1bec9bc"],"a5b3e70510efc80bc67f6ad80224387e441c14ec":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"bbb0b5c5101d175049b4ced1462f4c266d32fc63":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e58679227cd51c0676b0d204921cdf7558335bd1":["962cd4f5e313777f35da8f521265323e84184929","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4e6b620c271c84c0f14919eec7b90083b292ee51":["a5b3e70510efc80bc67f6ad80224387e441c14ec"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}