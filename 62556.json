{"path":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","commits":[{"id":"5ef0a91e147ef5c263ff965642f847b554b13ba2","date":1386676110,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"/dev/null","sourceNew":"  private void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"/dev/null","sourceNew":"  private void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","sourceOld":"  private void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c7856260bc28f285ae7bfefa99b28db4dca6daf","date":1395253500,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n\n    getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrServer().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n\n    getCommonCloudSolrServer().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrServer().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n    HttpSolrClient collectionClient = new HttpSolrClient(url);\n\n    SolrQuery solrQuery = new SolrQuery(\"*:*\");\n    assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n    invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n    long finishTime = System.currentTimeMillis();\n\n    indexer.join();\n    splitKeyCount[0] += indexer.getSplitKeyCount();\n\n    try {\n      cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n      splitKeyCount[0]--;\n    } catch (Exception e) {\n      log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n    }\n    cloudClient.commit();\n    collectionClient.commit();\n\n    solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n    QueryResponse response = collectionClient.query(solrQuery);\n    log.info(\"Response from target collection: \" + response);\n    assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n    collectionClient.shutdown();\n    collectionClient = null;\n\n    getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n    ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n    Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n    assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n    assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n    assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n    boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n    assertTrue(\"Routing rule was not expired\", ruleRemoved);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"234afba21d42e6c527535c6aa11baba09a4771f3","date":1432825127,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = CustomCollectionTest.getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState();\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState(true);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState();\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.currentTimeMillis();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState();\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().updateClusterState();\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = new HttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a02c54923e5f4de08097fa9028e09e8cf5caa82","date":1475573567,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  @Test\n  public void multipleShardMigrateTest() throws Exception  {\n\n    CollectionAdminRequest.createCollection(\"sourceCollection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.getSolrClient().setDefaultCollection(\"sourceCollection\");\n\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cluster.getSolrClient().add(\"sourceCollection\", doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    CollectionAdminRequest.createCollection(targetCollection, \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    Indexer indexer = new Indexer(cluster.getSolrClient(), splitKey, 1, 30);\n    indexer.start();\n\n    DocCollection state = getCollectionState(targetCollection);\n    Replica replica = state.getReplicas().get(0);\n    try (HttpSolrClient collectionClient = getHttpSolrClient(replica.getCoreUrl())) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeCollectionMigration(\n          CollectionAdminRequest.migrateData(\"sourceCollection\", targetCollection, splitKey + \"/\" + BIT_SEP + \"!\")\n          .setForwardTimeout(45));\n\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cluster.getSolrClient().deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cluster.getSolrClient().commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      waitForState(\"Expected to find routing rule for split key \" + splitKey, \"sourceCollection\", (n, c) -> {\n        if (c == null)\n          return false;\n        Slice shard = c.getSlice(\"shard2\");\n        if (shard == null)\n          return false;\n        if (shard.getRoutingRules() == null || shard.getRoutingRules().isEmpty())\n          return false;\n        if (shard.getRoutingRules().get(splitKey + \"!\") == null)\n          return false;\n        return true;\n      });\n\n      boolean ruleRemoved = waitForRuleToExpire(\"sourceCollection\", \"shard2\", splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1967bed916cc89da82a1c2085f27976da6d08cbd","date":1475588750,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  @Test\n  public void multipleShardMigrateTest() throws Exception  {\n\n    CollectionAdminRequest.createCollection(\"sourceCollection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.getSolrClient().setDefaultCollection(\"sourceCollection\");\n\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cluster.getSolrClient().add(\"sourceCollection\", doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    CollectionAdminRequest.createCollection(targetCollection, \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    Indexer indexer = new Indexer(cluster.getSolrClient(), splitKey, 1, 30);\n    indexer.start();\n\n    DocCollection state = getCollectionState(targetCollection);\n    Replica replica = state.getReplicas().get(0);\n    try (HttpSolrClient collectionClient = getHttpSolrClient(replica.getCoreUrl())) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeCollectionMigration(\n          CollectionAdminRequest.migrateData(\"sourceCollection\", targetCollection, splitKey + \"/\" + BIT_SEP + \"!\")\n          .setForwardTimeout(45));\n\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cluster.getSolrClient().deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cluster.getSolrClient().commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      waitForState(\"Expected to find routing rule for split key \" + splitKey, \"sourceCollection\", (n, c) -> {\n        if (c == null)\n          return false;\n        Slice shard = c.getSlice(\"shard2\");\n        if (shard == null)\n          return false;\n        if (shard.getRoutingRules() == null || shard.getRoutingRules().isEmpty())\n          return false;\n        if (shard.getRoutingRules().get(splitKey + \"!\") == null)\n          return false;\n        return true;\n      });\n\n      boolean ruleRemoved = waitForRuleToExpire(\"sourceCollection\", \"shard2\", splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  @Test\n  public void multipleShardMigrateTest() throws Exception  {\n\n    CollectionAdminRequest.createCollection(\"sourceCollection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.getSolrClient().setDefaultCollection(\"sourceCollection\");\n\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cluster.getSolrClient().add(\"sourceCollection\", doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    CollectionAdminRequest.createCollection(targetCollection, \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    Indexer indexer = new Indexer(cluster.getSolrClient(), splitKey, 1, 30);\n    indexer.start();\n\n    DocCollection state = getCollectionState(targetCollection);\n    Replica replica = state.getReplicas().get(0);\n    try (HttpSolrClient collectionClient = getHttpSolrClient(replica.getCoreUrl())) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeCollectionMigration(\n          CollectionAdminRequest.migrateData(\"sourceCollection\", targetCollection, splitKey + \"/\" + BIT_SEP + \"!\")\n          .setForwardTimeout(45));\n\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cluster.getSolrClient().deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cluster.getSolrClient().commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      waitForState(\"Expected to find routing rule for split key \" + splitKey, \"sourceCollection\", (n, c) -> {\n        if (c == null)\n          return false;\n        Slice shard = c.getSlice(\"shard2\");\n        if (shard == null)\n          return false;\n        if (shard.getRoutingRules() == null || shard.getRoutingRules().isEmpty())\n          return false;\n        if (shard.getRoutingRules().get(splitKey + \"!\") == null)\n          return false;\n        return true;\n      });\n\n      boolean ruleRemoved = waitForRuleToExpire(\"sourceCollection\", \"shard2\", splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  protected void multipleShardMigrateTest() throws Exception  {\n    del(\"*:*\");\n    commit();\n    assertTrue(cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound() == 0);\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cloudClient.add(doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    createCollection(targetCollection);\n\n    Indexer indexer = new Indexer(cloudClient, splitKey, 1, 30);\n    indexer.start();\n\n    String url = getUrlFromZk(getCommonCloudSolrClient().getZkStateReader().getClusterState(), targetCollection);\n\n    try (HttpSolrClient collectionClient = getHttpSolrClient(url)) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeMigrateApi(AbstractDistribZkTestBase.DEFAULT_COLLECTION, splitKey + \"/\" + BIT_SEP + \"!\", targetCollection);\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cloudClient.deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cloudClient.commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      getCommonCloudSolrClient().getZkStateReader().forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = getCommonCloudSolrClient().getZkStateReader().getClusterState();\n      Slice slice = state.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD2);\n      assertNotNull(\"Routing rule map is null\", slice.getRoutingRules());\n      assertFalse(\"Routing rule map is empty\", slice.getRoutingRules().isEmpty());\n      assertNotNull(\"No routing rule exists for route key: \" + splitKey, slice.getRoutingRules().get(splitKey + \"!\"));\n\n      boolean ruleRemoved = waitForRuleToExpire(splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest#multipleShardMigrateTest().mjava","sourceNew":"  @Test\n  public void multipleShardMigrateTest() throws Exception  {\n\n    CollectionAdminRequest.createCollection(\"sourceCollection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.getSolrClient().setDefaultCollection(\"sourceCollection\");\n\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cluster.getSolrClient().add(\"sourceCollection\", doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    CollectionAdminRequest.createCollection(targetCollection, \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    Indexer indexer = new Indexer(cluster.getSolrClient(), splitKey, 1, 30);\n    indexer.start();\n\n    DocCollection state = getCollectionState(targetCollection);\n    Replica replica = state.getReplicas().get(0);\n    try (HttpSolrClient collectionClient = getHttpSolrClient(replica.getCoreUrl())) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeCollectionMigration(\n          CollectionAdminRequest.migrateData(\"sourceCollection\", targetCollection, splitKey + \"/\" + BIT_SEP + \"!\")\n          .setForwardTimeout(45));\n\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cluster.getSolrClient().deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/{}!104\", BIT_SEP, e);\n      }\n      cluster.getSolrClient().commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: {}\", response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      waitForState(\"Expected to find routing rule for split key \" + splitKey, \"sourceCollection\", (n, c) -> {\n        if (c == null)\n          return false;\n        Slice shard = c.getSlice(\"shard2\");\n        if (shard == null)\n          return false;\n        if (shard.getRoutingRules() == null || shard.getRoutingRules().isEmpty())\n          return false;\n        if (shard.getRoutingRules().get(splitKey + \"!\") == null)\n          return false;\n        return true;\n      });\n\n      boolean ruleRemoved = waitForRuleToExpire(\"sourceCollection\", \"shard2\", splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void multipleShardMigrateTest() throws Exception  {\n\n    CollectionAdminRequest.createCollection(\"sourceCollection\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    cluster.getSolrClient().setDefaultCollection(\"sourceCollection\");\n\n    final String splitKey = \"a\";\n    final int BIT_SEP = 1;\n    final int[] splitKeyCount = new int[1];\n    for (int id = 0; id < 26*3; id++) {\n      String shardKey = \"\" + (char) ('a' + (id % 26)); // See comment in ShardRoutingTest for hash distribution\n      String key = shardKey;\n      if (splitKey.equals(shardKey))  {\n        key += \"/\" + BIT_SEP;  // spread it over half the collection\n      }\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", key + \"!\" + id);\n      doc.addField(\"n_ti\", id);\n      cluster.getSolrClient().add(\"sourceCollection\", doc);\n      if (splitKey.equals(shardKey))\n        splitKeyCount[0]++;\n    }\n    assertTrue(splitKeyCount[0] > 0);\n\n    String targetCollection = \"migrate_multipleshardtest_targetCollection\";\n    CollectionAdminRequest.createCollection(targetCollection, \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    Indexer indexer = new Indexer(cluster.getSolrClient(), splitKey, 1, 30);\n    indexer.start();\n\n    DocCollection state = getCollectionState(targetCollection);\n    Replica replica = state.getReplicas().get(0);\n    try (HttpSolrClient collectionClient = getHttpSolrClient(replica.getCoreUrl())) {\n\n      SolrQuery solrQuery = new SolrQuery(\"*:*\");\n      assertEquals(\"DocCount on target collection does not match\", 0, collectionClient.query(solrQuery).getResults().getNumFound());\n\n      invokeCollectionMigration(\n          CollectionAdminRequest.migrateData(\"sourceCollection\", targetCollection, splitKey + \"/\" + BIT_SEP + \"!\")\n          .setForwardTimeout(45));\n\n      long finishTime = System.nanoTime();\n\n      indexer.join();\n      splitKeyCount[0] += indexer.getSplitKeyCount();\n\n      try {\n        cluster.getSolrClient().deleteById(\"a/\" + BIT_SEP + \"!104\");\n        splitKeyCount[0]--;\n      } catch (Exception e) {\n        log.warn(\"Error deleting document a/\" + BIT_SEP + \"!104\", e);\n      }\n      cluster.getSolrClient().commit();\n      collectionClient.commit();\n\n      solrQuery = new SolrQuery(\"*:*\").setRows(1000);\n      QueryResponse response = collectionClient.query(solrQuery);\n      log.info(\"Response from target collection: \" + response);\n      assertEquals(\"DocCount on target collection does not match\", splitKeyCount[0], response.getResults().getNumFound());\n\n      waitForState(\"Expected to find routing rule for split key \" + splitKey, \"sourceCollection\", (n, c) -> {\n        if (c == null)\n          return false;\n        Slice shard = c.getSlice(\"shard2\");\n        if (shard == null)\n          return false;\n        if (shard.getRoutingRules() == null || shard.getRoutingRules().isEmpty())\n          return false;\n        if (shard.getRoutingRules().get(splitKey + \"!\") == null)\n          return false;\n        return true;\n      });\n\n      boolean ruleRemoved = waitForRuleToExpire(\"sourceCollection\", \"shard2\", splitKey, finishTime);\n      assertTrue(\"Routing rule was not expired\", ruleRemoved);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1967bed916cc89da82a1c2085f27976da6d08cbd":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","5a02c54923e5f4de08097fa9028e09e8cf5caa82"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["234afba21d42e6c527535c6aa11baba09a4771f3"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["5ef0a91e147ef5c263ff965642f847b554b13ba2"],"bafca15d8e408346a67f4282ad1143b88023893b":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","1967bed916cc89da82a1c2085f27976da6d08cbd"],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"234afba21d42e6c527535c6aa11baba09a4771f3":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ef0a91e147ef5c263ff965642f847b554b13ba2"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"5a02c54923e5f4de08097fa9028e09e8cf5caa82":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"1967bed916cc89da82a1c2085f27976da6d08cbd":["a966532d92cf9ba2856f15a8140151bb6b518e4b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"5ef0a91e147ef5c263ff965642f847b554b13ba2":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"234afba21d42e6c527535c6aa11baba09a4771f3":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ef0a91e147ef5c263ff965642f847b554b13ba2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["1967bed916cc89da82a1c2085f27976da6d08cbd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","5a02c54923e5f4de08097fa9028e09e8cf5caa82"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["234afba21d42e6c527535c6aa11baba09a4771f3"],"5a02c54923e5f4de08097fa9028e09e8cf5caa82":["1967bed916cc89da82a1c2085f27976da6d08cbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}