{"path":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","commits":[{"id":"2062967ab57824b59d116b38d53d2058ac7e4592","date":1367320813,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(new RangeFacetRequest<FloatRange>(\"field\", ranges));\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(fsp, r));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(new RangeFacetRequest<FloatRange>(\"field\", ranges)));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest<?>) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(new RangeFacetRequest<FloatRange>(\"field\", ranges));\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(fsp, r));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(new RangeFacetRequest<FloatRange>(\"field\", ranges)));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest<?>) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetSearchParams fsp = new FacetSearchParams(new RangeFacetRequest<FloatRange>(\"field\", ranges));\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(fsp, r));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce7aff7772c162c15d520e31af46c555f60d5c3b","date":1385135519,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets#testRandomFloats().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","sourceNew":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n\n    IndexSearcher s = newSearcher(r);\n    FacetsConfig config = new FacetsConfig();\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      SimpleFacetsCollector sfc = new SimpleFacetsCollector();\n      s.search(new MatchAllDocsQuery(), sfc);\n      Facets facets = new RangeFacetCounts(\"field\", sfc, ranges);\n      SimpleFacetResult result = facets.getTopChildren(10, \"field\");\n      assertEquals(numRange, result.labelValues.length);\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        LabelAndValue subNode = result.labelValues[rangeID];\n        assertEquals(\"r\" + rangeID, subNode.label);\n        assertEquals(expectedCounts[rangeID], subNode.value.intValue());\n\n        FloatRange range = ranges[rangeID];\n\n        // Test drill-down:\n        SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    IOUtils.close(w, r, dir);\n  }\n\n","sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(new RangeFacetRequest<FloatRange>(\"field\", ranges)));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest<?>) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator#testRandomFloats().mjava","sourceNew":null,"sourceOld":"  public void testRandomFloats() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int numDocs = atLeast(1000);\n    float[] values = new float[numDocs];\n    for(int i=0;i<numDocs;i++) {\n      Document doc = new Document();\n      float v = random().nextFloat();\n      values[i] = v;\n      doc.add(new FloatDocValuesField(\"field\", v));\n      doc.add(new FloatField(\"field\", v, Field.Store.NO));\n      w.addDocument(doc);\n    }\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n    \n    int numIters = atLeast(10);\n    for(int iter=0;iter<numIters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter);\n      }\n      int numRange = _TestUtil.nextInt(random(), 1, 5);\n      FloatRange[] ranges = new FloatRange[numRange];\n      int[] expectedCounts = new int[numRange];\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        float min = random().nextFloat();\n        float max = random().nextFloat();\n        if (min > max) {\n          float x = min;\n          min = max;\n          max = x;\n        }\n        boolean minIncl = random().nextBoolean();\n        boolean maxIncl = random().nextBoolean();\n        ranges[rangeID] = new FloatRange(\"r\" + rangeID, min, minIncl, max, maxIncl);\n\n        // Do \"slow but hopefully correct\" computation of\n        // expected count:\n        for(int i=0;i<numDocs;i++) {\n          boolean accept = true;\n          if (minIncl) {\n            accept &= values[i] >= min;\n          } else {\n            accept &= values[i] > min;\n          }\n          if (maxIncl) {\n            accept &= values[i] <= max;\n          } else {\n            accept &= values[i] < max;\n          }\n          if (accept) {\n            expectedCounts[rangeID]++;\n          }\n        }\n      }\n\n      FacetsCollector fc = FacetsCollector.create(new RangeAccumulator(new RangeFacetRequest<FloatRange>(\"field\", ranges)));\n      s.search(new MatchAllDocsQuery(), fc);\n      List<FacetResult> results = fc.getFacetResults();\n      assertEquals(1, results.size());\n      List<FacetResultNode> nodes = results.get(0).getFacetResultNode().subResults;\n      assertEquals(numRange, nodes.size());\n      for(int rangeID=0;rangeID<numRange;rangeID++) {\n        if (VERBOSE) {\n          System.out.println(\"  range \" + rangeID + \" expectedCount=\" + expectedCounts[rangeID]);\n        }\n        FacetResultNode subNode = nodes.get(rangeID);\n        assertEquals(\"field/r\" + rangeID, subNode.label.toString('/'));\n        assertEquals(expectedCounts[rangeID], (int) subNode.value);\n\n        FloatRange range = (FloatRange) ((RangeFacetRequest<?>) results.get(0).getFacetRequest()).ranges[rangeID];\n\n        // Test drill-down:\n        DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT);\n        ddq.add(\"field\", NumericRangeQuery.newFloatRange(\"field\", range.min, range.max, range.minInclusive, range.maxInclusive));\n        assertEquals(expectedCounts[rangeID], s.search(ddq, 10).totalHits);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2062967ab57824b59d116b38d53d2058ac7e4592":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["2062967ab57824b59d116b38d53d2058ac7e4592"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","ce7aff7772c162c15d520e31af46c555f60d5c3b"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["2062967ab57824b59d116b38d53d2058ac7e4592"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"2062967ab57824b59d116b38d53d2058ac7e4592":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2062967ab57824b59d116b38d53d2058ac7e4592"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["ce7aff7772c162c15d520e31af46c555f60d5c3b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}