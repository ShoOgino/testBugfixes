{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","commits":[{"id":"ee67a99e7e36da49a4b68758a01d1ac09ff5472c","date":1547653069,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock() {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() throws IOException {\n    synchronized (this) {\n      if (closed) {\n        throw new AlreadyClosedException(\"DWPTPool is already closed\");\n      }\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock() {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72","date":1597413898,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() throws IOException {\n    synchronized (this) {\n      ensureOpen();\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() throws IOException {\n    synchronized (this) {\n      if (closed) {\n        throw new AlreadyClosedException(\"DWPTPool is already closed\");\n      }\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49f1924bd448393fbdfef8b5ebed799f938169d3","date":1600069616,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() {\n    synchronized (this) {\n      ensureOpen();\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() throws IOException {\n    synchronized (this) {\n      ensureOpen();\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcf8f79417865e5028d753e669fae06457e8369","date":1600073240,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() {\n    synchronized (this) {\n      ensureOpen();\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a DWPT to do an indexing operation (add/updateDocument). */\n  DocumentsWriterPerThread getAndLock() throws IOException {\n    synchronized (this) {\n      ensureOpen();\n      // Important that we are LIFO here! This way if number of concurrent indexing threads was once high,\n      // but has now reduced, we only use a limited number of DWPTs. This also guarantees that if we have suddenly\n      // a single thread indexing\n      final Iterator<DocumentsWriterPerThread> descendingIterator = freeList.descendingIterator();\n      while (descendingIterator.hasNext()) {\n        DocumentsWriterPerThread perThread = descendingIterator.next();\n        if (perThread.tryLock()) {\n          descendingIterator.remove();\n          return perThread;\n        }\n      }\n      // DWPT is already locked before return by this method:\n      return newWriter();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"264935965977b4a9e2f3920420647072c9c49176":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"49f1924bd448393fbdfef8b5ebed799f938169d3":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72"],"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72":["264935965977b4a9e2f3920420647072c9c49176"],"0dcf8f79417865e5028d753e669fae06457e8369":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72","49f1924bd448393fbdfef8b5ebed799f938169d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dcf8f79417865e5028d753e669fae06457e8369"]},"commit2Childs":{"264935965977b4a9e2f3920420647072c9c49176":["bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72"],"49f1924bd448393fbdfef8b5ebed799f938169d3":["0dcf8f79417865e5028d753e669fae06457e8369"],"bd3903df1f9f4cfe074c9e72c60e31a9bed0ff72":["49f1924bd448393fbdfef8b5ebed799f938169d3","0dcf8f79417865e5028d753e669fae06457e8369"],"0dcf8f79417865e5028d753e669fae06457e8369":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["264935965977b4a9e2f3920420647072c9c49176"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}