{"path":"solr/core/src/java/org/apache/solr/handler/SortingResponseWriter[ExportWriter]#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"50f05d6b69cfaabd51b5d26cba4e3122f51fff83","date":1478603228,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SortingResponseWriter[ExportWriter]#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbb7f1f4cf1e9a820364c090bb7e9a590f351339","date":1478603266,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ExportWriter#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SortingResponseWriter[ExportWriter]#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(OutputStream os) throws IOException {\n    respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n    writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbb7f1f4cf1e9a820364c090bb7e9a590f351339","date":1478603266,"type":6,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/ExportWriter#writeDocs(SolrQueryRequest,IteratorWriter.ItemWriter,Sort).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SortingResponseWriter[ExportWriter]#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void writeDocs(SolrQueryRequest req, IteratorWriter.ItemWriter writer, Sort sort) throws IOException {\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n      //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          writer.add((MapWriter) ew -> {\n            writeDoc(s, leaves, ew);\n            s.reset();\n          });\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cbb7f1f4cf1e9a820364c090bb7e9a590f351339":["50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cbb7f1f4cf1e9a820364c090bb7e9a590f351339"]},"commit2Childs":{"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["cbb7f1f4cf1e9a820364c090bb7e9a590f351339"],"cbb7f1f4cf1e9a820364c090bb7e9a590f351339":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}