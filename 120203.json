{"path":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","commits":[{"id":"eee9156bf08d7eaae5e8d8ab5f855ba61012e257","date":1285443157,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\r\n   * Utility function to help check what bits are valid\r\n   */\r\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int maxDocs, int numDocs )\r\n  {\r\n    if( numDocs != maxDocs ) {\r\n      if( hasOption( OPTION_CACHE_BITS ) ) {\r\n        if( deleted == null ) {\r\n          for( int i=0; i<maxDocs; i++ ) {\r\n            if( !valid.get(i) ) {\r\n              return valid;\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          for( int i=0; i<maxDocs; i++ ) {\r\n            if( !deleted.get(i) && !valid.get(i) ) {\r\n              return valid;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        return null;\r\n      }\r\n    }\r\n    return new Bits.MatchAllBits( maxDocs );\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5637938a7dc36e7ff09a5d9398957bd46b15129a","date":1285538458,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","sourceNew":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int maxDocs, int numDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","sourceOld":"  /**\r\n   * Utility function to help check what bits are valid\r\n   */\r\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int maxDocs, int numDocs )\r\n  {\r\n    if( numDocs != maxDocs ) {\r\n      if( hasOption( OPTION_CACHE_BITS ) ) {\r\n        if( deleted == null ) {\r\n          for( int i=0; i<maxDocs; i++ ) {\r\n            if( !valid.get(i) ) {\r\n              return valid;\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          for( int i=0; i<maxDocs; i++ ) {\r\n            if( !deleted.get(i) && !valid.get(i) ) {\r\n              return valid;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        return null;\r\n      }\r\n    }\r\n    return new Bits.MatchAllBits( maxDocs );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3d3855bbeac213eadb1d7a684da16d22cf570a8","date":1286887559,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","sourceNew":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","sourceOld":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int maxDocs, int numDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","sourceNew":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","sourceOld":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int maxDocs, int numDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee24cbec95372b8e747bf9146a5ef33734029a6","date":1291686380,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(OpenBitSet,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","sourceNew":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        for( int i=0; i<maxDocs; i++ ) {\n          if( !valid.get(i) ) {\n            return valid;\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","sourceOld":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","date":1291833341,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(OpenBitSet,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator#checkMatchAllBits(Bits,OpenBitSet,int,int).mjava","sourceNew":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        for( int i=0; i<maxDocs; i++ ) {\n          if( !valid.get(i) ) {\n            return valid;\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","sourceOld":"  /**\n   * Utility function to help check what bits are valid\n   */\n  protected Bits checkMatchAllBits( Bits deleted, OpenBitSet valid, int numDocs, int maxDocs )\n  {\n    if( numDocs != maxDocs ) {\n      if( hasOption( OPTION_CACHE_BITS ) ) {\n        if( deleted == null ) {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n        else {\n          for( int i=0; i<maxDocs; i++ ) {\n            if( !deleted.get(i) && !valid.get(i) ) {\n              return valid;\n            }\n          }\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    return new Bits.MatchAllBits( maxDocs );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eee9156bf08d7eaae5e8d8ab5f855ba61012e257":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c3d3855bbeac213eadb1d7a684da16d22cf570a8":["5637938a7dc36e7ff09a5d9398957bd46b15129a"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":["4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"5637938a7dc36e7ff09a5d9398957bd46b15129a":["eee9156bf08d7eaae5e8d8ab5f855ba61012e257"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["5637938a7dc36e7ff09a5d9398957bd46b15129a","c3d3855bbeac213eadb1d7a684da16d22cf570a8"],"eee24cbec95372b8e747bf9146a5ef33734029a6":["c3d3855bbeac213eadb1d7a684da16d22cf570a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eee24cbec95372b8e747bf9146a5ef33734029a6"]},"commit2Childs":{"eee9156bf08d7eaae5e8d8ab5f855ba61012e257":["5637938a7dc36e7ff09a5d9398957bd46b15129a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eee9156bf08d7eaae5e8d8ab5f855ba61012e257"],"c3d3855bbeac213eadb1d7a684da16d22cf570a8":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","eee24cbec95372b8e747bf9146a5ef33734029a6"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":[],"5637938a7dc36e7ff09a5d9398957bd46b15129a":["c3d3855bbeac213eadb1d7a684da16d22cf570a8","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["4a69e5860d014751cc9329dfeb441a6d8fd1ed8e"],"eee24cbec95372b8e747bf9146a5ef33734029a6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}