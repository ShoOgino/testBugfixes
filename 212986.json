{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","commits":[{"id":"c52ad29218ee436d52c57bf0829b98acad9de379","date":1383401544,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(UpdateLog).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.out.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(UpdateLog ulog)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = ulog.applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n//    try {\n//      RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);\n//      SolrIndexSearcher searcher = searchHolder.get();\n//      try {\n//        System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + \" replayed \"\n//            + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n//      } finally {\n//        searchHolder.decref();\n//      }\n//    } catch (Exception e) {\n//      \n//    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8","date":1383401729,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.err.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.out.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b56ee224dbe29ee4436d91a7070ca418ffc4fb","date":1383492966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (Boolean.getBoolean(\"solr.cloud.debug\")) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          System.err.println(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, null, e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed.\");\n    } else {\n      log.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed. core=\" + coreName);\n    } else {\n      log.info(\"Replaying buffered documents. core=\" + coreName);\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"610f5499a87a7113d53e5b621b616890f002e9f1","date":1450873010,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed.\");\n    } else {\n      log.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    if (log.isDebugEnabled()) {\n      try {\n        RefCounted<SolrIndexSearcher> searchHolder = core\n            .getNewestSearcher(false);\n        SolrIndexSearcher searcher = searchHolder.get();\n        try {\n          log.debug(core.getCoreDescriptor().getCoreContainer()\n              .getZkController().getNodeName()\n              + \" replayed \"\n              + searcher.search(new MatchAllDocsQuery(), 1).totalHits);\n        } finally {\n          searchHolder.decref();\n        }\n      } catch (Exception e) {\n        log.debug(\"Error in solrcloud_debug block\", e);\n      }\n    }\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (onlyLeaderIndexes) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (onlyLeaderIndexes) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (onlyLeaderIndexes) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (onlyLeaderIndexes) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (onlyLeaderIndexes) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","date":1529486762,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8670a91ead9cc2ff2fd5fb94507e11abd9a77803","date":1530583336,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed.\");\n    } else {\n      log.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      LOG.info(\"No replay needed.\");\n    } else {\n      LOG.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(LOG, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#replay(SolrCore).mjava","sourceNew":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed.\");\n    } else {\n      log.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n\n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n\n    return future;\n  }\n\n","sourceOld":"  final private Future<RecoveryInfo> replay(SolrCore core)\n      throws InterruptedException, ExecutionException {\n    if (testing_beforeReplayBufferingUpdates != null) {\n      testing_beforeReplayBufferingUpdates.run();\n    }\n    if (replicaType == Replica.Type.TLOG) {\n      // roll over all updates during buffering to new tlog, make RTG available\n      SolrQueryRequest req = new LocalSolrQueryRequest(core,\n          new ModifiableSolrParams());\n      core.getUpdateHandler().getUpdateLog().copyOverBufferingUpdates(new CommitUpdateCommand(req, false));\n      req.close();\n      return null;\n    }\n    Future<RecoveryInfo> future = core.getUpdateHandler().getUpdateLog().applyBufferedUpdates();\n    if (future == null) {\n      // no replay needed\\\n      log.info(\"No replay needed.\");\n    } else {\n      log.info(\"Replaying buffered documents.\");\n      // wait for replay\n      RecoveryInfo report = future.get();\n      if (report.failed) {\n        SolrException.log(log, \"Replay failed\");\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Replay failed\");\n      }\n    }\n\n    // the index may ahead of the tlog's caches after recovery, by calling this tlog's caches will be purged\n    core.getUpdateHandler().getUpdateLog().openRealtimeSearcher();\n    \n    // solrcloud_debug\n    cloudDebugLog(core, \"replayed\");\n    \n    return future;\n  }\n\n","bugFix":["c52ad29218ee436d52c57bf0829b98acad9de379"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8670a91ead9cc2ff2fd5fb94507e11abd9a77803":["ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7"],"610f5499a87a7113d53e5b621b616890f002e9f1":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8":["c52ad29218ee436d52c57bf0829b98acad9de379"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["1b17e61942d57c9c1c6dc8a926bce1c5c47882f8"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["61c45e99cf6676da48f19d7511c73712ad39402b","8670a91ead9cc2ff2fd5fb94507e11abd9a77803"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c52ad29218ee436d52c57bf0829b98acad9de379":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"be320990bdc77e643388fa801e75017f19289c42":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["610f5499a87a7113d53e5b621b616890f002e9f1"],"ab68488225b6a6c357dda72ed11dedca9914a192":["7392b75d2c2f2aecf31188732a0764fe0dc74ade","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["8670a91ead9cc2ff2fd5fb94507e11abd9a77803"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["61c45e99cf6676da48f19d7511c73712ad39402b"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["61c45e99cf6676da48f19d7511c73712ad39402b","8670a91ead9cc2ff2fd5fb94507e11abd9a77803"]},"commit2Childs":{"8670a91ead9cc2ff2fd5fb94507e11abd9a77803":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"610f5499a87a7113d53e5b621b616890f002e9f1":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"1b17e61942d57c9c1c6dc8a926bce1c5c47882f8":["89b56ee224dbe29ee4436d91a7070ca418ffc4fb"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"89b56ee224dbe29ee4436d91a7070ca418ffc4fb":["6c94d2661bc1c14426980ec7882e951fdcff08d0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["439c63ae5d22132fca810a0029a854e97d2c1a3e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["610f5499a87a7113d53e5b621b616890f002e9f1"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c52ad29218ee436d52c57bf0829b98acad9de379"],"c52ad29218ee436d52c57bf0829b98acad9de379":["1b17e61942d57c9c1c6dc8a926bce1c5c47882f8"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"ba0e7b86ac6002d5286b4589d87b3c80bbcabdc7":["8670a91ead9cc2ff2fd5fb94507e11abd9a77803"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}