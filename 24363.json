{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","commits":[{"id":"50e202028300f452744bbd0e537a0f5c0cf044b6","date":1446478140,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"/dev/null","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + ClientUtils.toQueryString(requestParams, false));\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              NamedList<Object> resp =\n                  client.parser.processResponse(response.getEntity().getContent(),\n                      response.getEntity().getContentType().getValue());\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null)\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f8b96886ff093f65f10863a5eb7ea1275ded86d1","7065efda8f35a7182b1ead959371c47f3615eaac","42718e80a64f6c041cebc3699ab91cd1c928444d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42718e80a64f6c041cebc3699ab91cd1c928444d","date":1448186182,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              NamedList<Object> resp =\n                  client.parser.processResponse(response.getEntity().getContent(),\n                      response.getEntity().getContentType().getValue());\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null)\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + ClientUtils.toQueryString(requestParams, false));\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              NamedList<Object> resp =\n                  client.parser.processResponse(response.getEntity().getContent(),\n                      response.getEntity().getContentType().getValue());\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null)\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","bugFix":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8b96886ff093f65f10863a5eb7ea1275ded86d1","date":1449241928,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(response.getEntity().getContent(), encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              NamedList<Object> resp =\n                  client.parser.processResponse(response.getEntity().getContent(),\n                      response.getEntity().getContentType().getValue());\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null)\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","bugFix":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              EntityUtils.consume(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(response.getEntity().getContent(), encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              response.getEntity().getContent().close();\n            }\n          } catch (Exception ex) {\n            log.warn(\"\", ex);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c787dc902884220111b2b719b1bcf15d1506c298","date":1455136376,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              EntityUtils.consume(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method);\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7065efda8f35a7182b1ead959371c47f3615eaac","date":1460559321,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final UpdateRequest updateRequest =\n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (updateRequest == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                UpdateRequest req = updateRequest;\n                while (req != null) {\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(req); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    req = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          method = new HttpPost(client.getBaseURL() + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"070b525fb213c5643ba35e1b60f1a1d4f7b23312","date":1475678176,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext(scheduler));\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07cebc9816f8c940e8e9683abbdc742fe95e25d7","date":1475696954,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext(scheduler));\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15fb22f207e0cbf913dbc9857b6a4fe30390a625","date":1475989569,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient().execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65ff6ef880637c4ec23ec5bed2c6036058f4e42d","date":1481049262,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","date":1481116359,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ca1cace44c816965501b934686a2354382f000","date":1487792658,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                  queue.add(upd); // params are different, push back to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n\n        InputStream rspBody = null;\n        try {\n          final Update update = \n              queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n              try {\n                if (isXml) {\n                  out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                }\n                Update upd = update;\n                while (upd != null) {\n                  UpdateRequest req = upd.getRequest();\n                  SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                  if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                    queue.add(upd); // params are different, push back to queue\n                    break;\n                  }\n\n                  client.requestWriter.write(req, out);\n                  if (isXml) {\n                    // check for commit or optimize\n                    SolrParams params = req.getParams();\n                    if (params != null) {\n                      String fmt = null;\n                      if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                        fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                      } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                        fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                      }\n                      if (fmt != null) {\n                        byte[] content = String.format(Locale.ROOT,\n                            fmt,\n                            params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                + \"\").getBytes(StandardCharsets.UTF_8);\n                        out.write(content);\n                      }\n                    }\n                  }\n                  out.flush();\n\n                  if (pollQueueTime > 0 && threadCount == 1 && req.isLastDocInBatch()) {\n                    // no need to wait to see another doc in the queue if we've hit the last doc in a batch\n                    upd = queue.poll(0, TimeUnit.MILLISECONDS);\n                  } else {\n                    upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n\n                }\n\n                if (isXml) {\n                  out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                }\n\n              } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n              }\n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n\n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          rspBody = response.getEntity().getContent();\n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7b0a0e9ce4d498a205a1572b7058348a9ec782f","date":1538921330,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                  queue.add(upd); // params are different, push back to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    @SuppressWarnings({\"deprecation\", \"unchecked\"})\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n            \n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    @SuppressWarnings({\"deprecation\", \"unchecked\"})\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n            \n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db96734b79e26d948b59f68bd4564c4836a71acf","date":1585375566,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new BaseHttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new HttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from {} due to: \", client.getBaseURL(), exc);\n            } finally {\n              solrExc = new BaseHttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from \" + client.getBaseURL() + \" due to: \" + exc);\n            } finally {\n              solrExc = new BaseHttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#sendUpdateStream().mjava","sourceNew":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    @SuppressWarnings({\"unchecked\"})\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from {} due to: \", client.getBaseURL(), exc);\n            } finally {\n              solrExc = new BaseHttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","sourceOld":"    //\n    // Pull from the queue multiple times and streams over a single connection.\n    // Exits on exception, interruption, or an empty queue to pull from.\n    //\n    void sendUpdateStream() throws Exception {\n    \n      while (!queue.isEmpty()) {\n        HttpPost method = null;\n        HttpResponse response = null;\n        \n        InputStream rspBody = null;\n        try {\n          Update update;\n          notifyQueueAndRunnersIfEmptyQueue();\n          try {\n            inPoll = true;\n            update = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n          } catch (InterruptedException e) {\n            if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n            continue;\n          } finally {\n            inPoll = false;\n          }\n          if (update == null)\n            break;\n\n          String contentType = client.requestWriter.getUpdateContentType();\n          final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n          final ModifiableSolrParams origParams = new ModifiableSolrParams(update.getRequest().getParams());\n          final String origTargetCollection = update.getCollection();\n\n          EntityTemplate template = new EntityTemplate(new ContentProducer() {\n            \n            @Override\n            public void writeTo(OutputStream out) throws IOException {\n\n              if (isXml) {\n                out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n              }\n              Update upd = update;\n              while (upd != null) {\n                UpdateRequest req = upd.getRequest();\n                SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                if (!origParams.toNamedList().equals(currentParams.toNamedList()) || !StringUtils.equals(origTargetCollection, upd.getCollection())) {\n                  queue.add(upd); // Request has different params or destination core/collection, return to queue\n                  break;\n                }\n\n                client.requestWriter.write(req, out);\n                if (isXml) {\n                  // check for commit or optimize\n                  SolrParams params = req.getParams();\n                  if (params != null) {\n                    String fmt = null;\n                    if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                      fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                    } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                      fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                    }\n                    if (fmt != null) {\n                      byte[] content = String.format(Locale.ROOT,\n                          fmt, params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                              + \"\")\n                          .getBytes(StandardCharsets.UTF_8);\n                      out.write(content);\n                    }\n                  }\n                }\n                out.flush();\n\n                notifyQueueAndRunnersIfEmptyQueue();\n                inPoll = true;\n                try {\n                  while (true) {\n                    try {\n                      upd = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                      break;\n                    } catch (InterruptedException e) {\n                      if (log.isDebugEnabled()) pollInterrupts.incrementAndGet();\n                      if (!queue.isEmpty()) {\n                        continue;\n                      }\n                      if (log.isDebugEnabled()) pollExits.incrementAndGet();\n                      upd = null;\n                      break;\n                    } finally {\n                      inPoll = false;\n                    }\n                  }\n                }finally {\n                  inPoll = false;\n                }\n              }\n\n              if (isXml) {\n                out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n              }\n            \n            \n            }\n          });\n\n          // The parser 'wt=' and 'version=' params are used instead of the\n          // original params\n          ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n          requestParams.set(CommonParams.WT, client.parser.getWriterType());\n          requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n          String basePath = client.getBaseURL();\n          if (update.getCollection() != null)\n            basePath += \"/\" + update.getCollection();\n\n          method = new HttpPost(basePath + \"/update\"\n              + requestParams.toQueryString());\n          \n          org.apache.http.client.config.RequestConfig.Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n  \n          method.setConfig(requestConfigBuilder.build());\n          \n          method.setEntity(template);\n          method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n          method.addHeader(\"Content-Type\", contentType);\n          \n       \n          response = client.getHttpClient()\n              .execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n          \n          rspBody = response.getEntity().getContent();\n            \n          int statusCode = response.getStatusLine().getStatusCode();\n          if (statusCode != HttpStatus.SC_OK) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(response.getStatusLine().getReasonPhrase());\n            msg.append(\"\\n\\n\\n\\n\");\n            msg.append(\"request: \").append(method.getURI());\n\n            SolrException solrExc;\n            NamedList<String> metadata = null;\n            // parse out the metadata from the SolrException\n            try {\n              String encoding = \"UTF-8\"; // default\n              if (response.getEntity().getContentType().getElements().length > 0) {\n                NameValuePair param = response.getEntity().getContentType().getElements()[0].getParameterByName(\"charset\");\n                if (param != null)  {\n                  encoding = param.getValue();\n                }\n              }\n              NamedList<Object> resp = client.parser.processResponse(rspBody, encoding);\n              NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n              if (error != null) {\n                metadata = (NamedList<String>) error.get(\"metadata\");\n                String remoteMsg = (String) error.get(\"msg\");\n                if (remoteMsg != null) {\n                  msg.append(\"\\nRemote error message: \");\n                  msg.append(remoteMsg);\n                }\n              }\n            } catch (Exception exc) {\n              // don't want to fail to report error if parsing the response fails\n              log.warn(\"Failed to parse error response from {} due to: \", client.getBaseURL(), exc);\n            } finally {\n              solrExc = new BaseHttpSolrClient.RemoteSolrException(client.getBaseURL(), statusCode, msg.toString(), null);\n              if (metadata != null) {\n                solrExc.setMetadata(metadata);\n              }\n            }\n\n            handleError(solrExc);\n          } else {\n            onSuccess(response);\n          }\n          \n        } finally {\n          try {\n            if (response != null) {\n              Utils.consumeFully(response.getEntity());\n            }\n          } catch (Exception e) {\n            log.error(\"Error consuming and closing http response stream.\", e);\n          }\n          notifyQueueAndRunnersIfEmptyQueue();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["db96734b79e26d948b59f68bd4564c4836a71acf"],"a7b0a0e9ce4d498a205a1572b7058348a9ec782f":["c7ca1cace44c816965501b934686a2354382f000"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["f8b96886ff093f65f10863a5eb7ea1275ded86d1"],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["15fb22f207e0cbf913dbc9857b6a4fe30390a625","65ff6ef880637c4ec23ec5bed2c6036058f4e42d"],"070b525fb213c5643ba35e1b60f1a1d4f7b23312":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["859081acf00749f5dd462772c571d611d4a4d2db"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["07cebc9816f8c940e8e9683abbdc742fe95e25d7"],"c787dc902884220111b2b719b1bcf15d1506c298":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"f8b96886ff093f65f10863a5eb7ea1275ded86d1":["42718e80a64f6c041cebc3699ab91cd1c928444d"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","7065efda8f35a7182b1ead959371c47f3615eaac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7065efda8f35a7182b1ead959371c47f3615eaac":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["a7b0a0e9ce4d498a205a1572b7058348a9ec782f"],"50e202028300f452744bbd0e537a0f5c0cf044b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"859081acf00749f5dd462772c571d611d4a4d2db":["c787dc902884220111b2b719b1bcf15d1506c298"],"07cebc9816f8c940e8e9683abbdc742fe95e25d7":["070b525fb213c5643ba35e1b60f1a1d4f7b23312"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["859081acf00749f5dd462772c571d611d4a4d2db","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"db96734b79e26d948b59f68bd4564c4836a71acf":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"42718e80a64f6c041cebc3699ab91cd1c928444d":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"65ff6ef880637c4ec23ec5bed2c6036058f4e42d":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"c7ca1cace44c816965501b934686a2354382f000":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"]},"commit2Childs":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a7b0a0e9ce4d498a205a1572b7058348a9ec782f":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["c787dc902884220111b2b719b1bcf15d1506c298"],"ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d":["9856095f7afb5a607bf5e65077615ed91273508c","c7ca1cace44c816965501b934686a2354382f000"],"070b525fb213c5643ba35e1b60f1a1d4f7b23312":["07cebc9816f8c940e8e9683abbdc742fe95e25d7"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","65ff6ef880637c4ec23ec5bed2c6036058f4e42d"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c787dc902884220111b2b719b1bcf15d1506c298":["859081acf00749f5dd462772c571d611d4a4d2db"],"f8b96886ff093f65f10863a5eb7ea1275ded86d1":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["070b525fb213c5643ba35e1b60f1a1d4f7b23312","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7065efda8f35a7182b1ead959371c47f3615eaac":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"50e202028300f452744bbd0e537a0f5c0cf044b6":["42718e80a64f6c041cebc3699ab91cd1c928444d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"859081acf00749f5dd462772c571d611d4a4d2db":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"07cebc9816f8c940e8e9683abbdc742fe95e25d7":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["db96734b79e26d948b59f68bd4564c4836a71acf"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","7065efda8f35a7182b1ead959371c47f3615eaac"],"db96734b79e26d948b59f68bd4564c4836a71acf":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"42718e80a64f6c041cebc3699ab91cd1c928444d":["f8b96886ff093f65f10863a5eb7ea1275ded86d1"],"65ff6ef880637c4ec23ec5bed2c6036058f4e42d":["ee8992dea79b51ba77a3fd1a5c0f94a5f0b8808d"],"c7ca1cace44c816965501b934686a2354382f000":["a7b0a0e9ce4d498a205a1572b7058348a9ec782f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}