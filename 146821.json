{"path":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"modules/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"    // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint lb = limit_backward;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j;\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n\t\tif (c - common == lb) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c - 1 - common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break;\n\t\tif (j == i) break;\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c - w.s_size;\n\t\tif (w.method == null) return w.result;\n\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c - w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint lb = limit_backward;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j;\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n\t\tif (c - common == lb) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c - 1 - common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break;\n\t\tif (j == i) break;\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c - w.s_size;\n\t\tif (w.method == null) return w.result;\n\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c - w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res;\n          try {\n            Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n            res = resobj.toString().equals(\"true\");\n          } catch (InvocationTargetException e) {\n            res = false;\n            // FIXME - debug message\n          } catch (IllegalAccessException e) {\n            res = false;\n            // FIXME - debug message\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","sourceOld":"    // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint lb = limit_backward;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j;\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n\t\tif (c - common == lb) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c - 1 - common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break;\n\t\tif (j == i) break;\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c - w.s_size;\n\t\tif (w.method == null) return w.result;\n\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c - w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":["770e1c49d8dece84946f0ced1abe4409f451bc41"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789","date":1439672757,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res;\n          try {\n            Object resobj = w.method.invoke(w.methodobject);\n            res = resobj.toString().equals(\"true\");\n          } catch (InvocationTargetException e) {\n            res = false;\n            // FIXME - debug message\n          } catch (IllegalAccessException e) {\n            res = false;\n            // FIXME - debug message\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","sourceOld":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res;\n          try {\n            Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n            res = resobj.toString().equals(\"true\");\n          } catch (InvocationTargetException e) {\n            res = false;\n            // FIXME - debug message\n          } catch (IllegalAccessException e) {\n            res = false;\n            // FIXME - debug message\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","bugFix":null,"bugIntro":["770e1c49d8dece84946f0ced1abe4409f451bc41"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770e1c49d8dece84946f0ced1abe4409f451bc41","date":1439734957,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Throwable e) {\n            rethrow(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","sourceOld":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res;\n          try {\n            Object resobj = w.method.invoke(w.methodobject);\n            res = resobj.toString().equals(\"true\");\n          } catch (InvocationTargetException e) {\n            res = false;\n            // FIXME - debug message\n          } catch (IllegalAccessException e) {\n            res = false;\n            // FIXME - debug message\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","bugFix":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d","date":1495118387,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Error | RuntimeException e) {\n            throw e;\n          } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","sourceOld":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Throwable e) {\n            rethrow(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Error | RuntimeException e) {\n            throw e;\n          } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","sourceOld":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Throwable e) {\n            rethrow(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09479cd2de06c67a115b7346a8e5de8af4d62e81","date":1581961081,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among_b(Among[],int).mjava","sourceNew":null,"sourceOld":"  // find_among_b is for backwards processing. Same comments apply\n    protected int find_among_b(Among v[], int v_size)\n    {\n  int i = 0;\n  int j = v_size;\n\n  int c = cursor;\n  int lb = limit_backward;\n\n  int common_i = 0;\n  int common_j = 0;\n\n  boolean first_key_inspected = false;\n\n      while (true) {\n        int k = i + ((j - i) >> 1);\n        int diff = 0;\n        int common = common_i < common_j ? common_i : common_j;\n        Among w = v[k];\n        int i2;\n        for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {\n          if (c - common == lb) {\n            diff = -1;\n            break;\n          }\n          diff = current[c - 1 - common] - w.s[i2];\n          if (diff != 0) break;\n          common++;\n        }\n        if (diff < 0) {\n          j = k;\n          common_j = common;\n        } else {\n          i = k;\n          common_i = common;\n        }\n        if (j - i <= 1) {\n          if (i > 0) break;\n          if (j == i) break;\n          if (first_key_inspected) break;\n          first_key_inspected = true;\n        }\n      }\n      while (true) {\n        Among w = v[i];\n        if (common_i >= w.s_size) {\n          cursor = c - w.s_size;\n          if (w.method == null) return w.result;\n\n          boolean res = false;\n          try {\n            res = (boolean) w.method.invokeExact(this);\n          } catch (Error | RuntimeException e) {\n            throw e;\n          } catch (Throwable e) {\n            throw new UndeclaredThrowableException(e);\n          }\n          cursor = c - w.s_size;\n          if (res) return w.result;\n        }\n        i = w.substring_i;\n        if (i < 0) return 0;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"770e1c49d8dece84946f0ced1abe4409f451bc41":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["770e1c49d8dece84946f0ced1abe4409f451bc41","8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"09479cd2de06c67a115b7346a8e5de8af4d62e81":["8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d":["770e1c49d8dece84946f0ced1abe4409f451bc41"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09479cd2de06c67a115b7346a8e5de8af4d62e81"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"770e1c49d8dece84946f0ced1abe4409f451bc41":["e9017cf144952056066919f1ebc7897ff9bd71b1","8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789":["770e1c49d8dece84946f0ced1abe4409f451bc41"],"09479cd2de06c67a115b7346a8e5de8af4d62e81":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d":["e9017cf144952056066919f1ebc7897ff9bd71b1","09479cd2de06c67a115b7346a8e5de8af4d62e81"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["4db7976c38cb8d2fbd54bae4fa5ec4b0f0d5c789"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}