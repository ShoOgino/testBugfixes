{"path":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd0ef6574805f3cb9880e0983b7548a6aa933508","date":1315345052,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["e2d531c99815e9282449614650df62aad96c688e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["6d061c6ac0252e445714563a37eb8aa9816ce369"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a5469a71486c4c1e313c7fcb08188d7111195c2","date":1333407337,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["e2d531c99815e9282449614650df62aad96c688e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21591922fb4db3e2a6ffb2cb342b3d61c053a973","date":1340761680,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d061c6ac0252e445714563a37eb8aa9816ce369","date":1341880528,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278"],"bugIntro":["e2d531c99815e9282449614650df62aad96c688e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"mainIndex/codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cf81bc8c6e4078e236f0e38b3a2d0271854f207","date":1364832963,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["e2d531c99815e9282449614650df62aad96c688e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"415fc059c6f2340aed1714220b9578c3f66ed09c","date":1366942705,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2901fdf41816ed0ac227f1c2245c963778fb2074","date":1375381090,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = get(\"indexDefaults/text()\", null) != null || get(\"mainIndex/text()\", null) != null;\n    boolean hasNewIndexConfig = get(\"indexConfig/text()\", null) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2d531c99815e9282449614650df62aad96c688e","date":1377014558,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":["6d061c6ac0252e445714563a37eb8aa9816ce369","6a7153c5cd4b2cd8054f8e46101442030d8a3c37","c1c76c72faecc7c9b683ad67e99240c975ee37b3","4a5469a71486c4c1e313c7fcb08188d7111195c2","9cf81bc8c6e4078e236f0e38b3a2d0271854f207","28a016ae2abf4934515e45810192aa4350e3092b","bd0ef6574805f3cb9880e0983b7548a6aa933508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",false, true);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\",false, false);\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",false, true);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360","date":1378833548,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    reopenReaders = getBool(indexConfigPrefix+\"/reopenReaders\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43fbcd532bdc735ef51c6d46a5f7f0e5bc761cec","date":1389843994,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eba342e8f50703ef6d48ac759b5fd5798b34d669","date":1391662062,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"afb6bf9ce227ab6aac5068547e286ecc958b8b9d","date":1394661169,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d4e985daefcb892b529223b478c47985fc3c483","date":1395658491,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null; \n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n   \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1 \n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\", \n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\", \n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\", \n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd330c9d05eacbd6e952fe0dea852e7ae037eb50","date":1398873035,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_40.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_40)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_40 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"057a1793765d068ea9302f1a29e21734ee58d41e","date":1408130117,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f7392e322590b1c5c54beda8e0dc4dac5a0dc70","date":1409367206,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false ); \n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36985f6a6a7b91997dfbf45341789379f0d89e62","date":1409704529,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE, MULTI_OK);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a","date":1410373276,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0_ALPHA)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE, MULTI_OK);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE, MULTI_OK);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb537081ae8ce706dd40a122f57a9e7b8a112be8","date":1411065946,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0_ALPHA)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0_ALPHA)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(ParamSet.class,ParamSet.TYPE, MULTI_OK);\n    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;\n    if(paramSetInfos!=null){\n      Map<String,ParamSet> paramSets = new HashMap<>();\n      for (PluginInfo p : paramSetInfos) {\n        ParamSet paramSet = new ParamSet(p);\n        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );\n      }\n      this.paramSets = Collections.unmodifiableMap(paramSets);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    boolean hasNewIndexConfig = getNode(\"indexConfig\", false) != null;\n    if(hasDeprecatedIndexConfig){\n      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0_ALPHA)) {\n        throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n      } else {\n        // Still allow the old sections for older LuceneMatchVersion's\n        if(hasNewIndexConfig) {\n          throw new SolrException(ErrorCode.FORBIDDEN, \"Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.\");\n        }\n        log.warn(\"<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.\");\n        defaultIndexConfig = new SolrIndexConfig(this, \"indexDefaults\", null);\n        mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n        indexConfigPrefix = \"mainIndex\";\n      }\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb55f6c347c48c2f7a9fb29b2e6dfe819b1a56f9","date":1414167719,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", 1000);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ab63427379c12859d6d1de312037b877f5148a9","date":1414432324,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", 1000);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"531fe719c7218235a679452eb3d137bfd8fc6af1","date":1415191086,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",\n                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);\n\n     // TODO: WTF is up with queryConverter???\n     // it aparently *only* works as a singleton? - SOLR-4304\n     // and even then -- only if there is a single SpellCheckComponent\n     // because of queryConverter.setIndexAnalyzer\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",\n                    REQUIRE_NAME, REQUIRE_CLASS);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why they are used (or even if they are\n     // declared outside of the appropriate context) but there's no nice\n     // way around that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",\n                    REQUIRE_CLASS, MULTI_OK);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+\"/deletionPolicy\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(CodecFactory.class,\"codecFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",\n                    MULTI_OK);\n     loadPluginInfo(UpdateLog.class,\"updateHandler/updateLog\");\n     loadPluginInfo(IndexSchemaFactory.class,\"schemaFactory\",\n                    REQUIRE_CLASS);\n     loadPluginInfo(RestManager.class, \"restManager\");\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    loadPluginInfo(InitParams.class, InitParams.TYPE, MULTI_OK);\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a94e45463a0089149b0d148ae5369140e7f54b8c","date":1419231934,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n     slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5a70f7ff0756e3668447bffbbf8bce8e7c361b9","date":1420028708,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac2f1cdbdc54a889e88543cc1d939a931cb96883","date":1420554488,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) != null,\n        false\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    nrtMode = getBool(indexConfigPrefix+\"/nrtMode\", true);\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["ae1dfc6b5c606bdefacac904cca6ac5619c4d81e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a94151dd8593cf0cddf5cce38cf48849077be12","date":1420555609,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        false\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) != null,\n        false\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"969792332ae6ed8052858ba4e3cf52502b22550f","date":1420555854,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        false\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae2f5be890d26585d438eba0b9cc7d3c0a9775be","date":1427387954,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(\"name\", \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(\"name\", \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if(hasDeprecatedIndexConfig){\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if(get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if(get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix+\"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n                                       get(\"jmx/@agentId\", null),\n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n     updateHandlerInfo = loadUpdatehandlerInfo();\n     \n     multipartUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048 );\n     \n     formUploadLimitKB = getInt( \n         \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048 );\n     \n     enableRemoteStreams = getBool( \n         \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n \n     // Let this filter take care of /select?xxx format\n     handleSelect = getBool( \n         \"requestDispatcher/@handleSelect\", true ); \n     \n     addHttpRequestToContext = getBool( \n         \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false );\n\n    List<PluginInfo> argsInfos =  pluginStore.get(InitParams.class.getName()) ;\n    if(argsInfos!=null){\n      Map<String,InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(\"name\", \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(\"name\", \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(indexConfigPrefix + \"/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae1dfc6b5c606bdefacac904cca6ac5619c4d81e","date":1440696940,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n\n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":["ac2f1cdbdc54a889e88543cc1d939a931cb96883"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"733eaf468f18297b1bcc51031353bdfdd1913bdf","date":1456928540,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      defaultIndexConfig = mainIndexConfig = null;\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", mainIndexConfig);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiński","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e511b092029d56e0d4e30204fba8509c1c2647b6","date":1467838965,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8381eb1cd44d2e0defb52130de3295a576ac1e7b","date":1467840340,"type":3,"author":"Chris Hostetter","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15f9a498a407241cefcbd00ca7fc84d5e7fa573e","date":1470840868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":["656ba78dd2c0e88d11623fc5bceca3ea217ce0b3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d62172dd2fc1195c7e475550ac394a9948a18ae","date":1474974102,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer neccessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6554f36a4636755009195a7840518bf6b4f03d6c","date":1481906808,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", Integer.MAX_VALUE);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true,\n          get(\"jmx/@agentId\", null),\n          get(\"jmx/@serviceUrl\", null),\n          get(\"jmx/@rootName\", null));\n\n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0388110fe119c0c8d3716cd93e30af79a0b70356","date":1497949208,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2048);\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", 2048);\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    // Let this filter take care of /select?xxx format\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", true);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2238da841c6da38e6ed909d35da8f4c0ea3147b","date":1499346175,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88","date":1546726477,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":["73b91012493e4750b9dc169cf1ae8cdd91493b42"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d722b735bc69d2234e957cb69cf96ad28ea7e1c3","date":1546867201,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", !luceneMatchVersion.onOrAfter(Version.LUCENE_7_0_0));\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2be0a2886c76942ff986465eabde7b858895dc9","date":1555349228,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    if (BooleanQuery.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, BooleanQuery.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    if (BooleanQuery.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, BooleanQuery.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"053c4cbd30d228154839dc536ca5a15a5f0c48bf","date":1564559417,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","date":1566455239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args,\"query/fieldValueCache\");\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes, StrUtils.join(c.pathInConfig, '/')));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b91012493e4750b9dc169cf1ae8cdd91493b42","date":1569935879,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args,\"query/fieldValueCache\");\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes, StrUtils.join(c.pathInConfig, '/')));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args,\"query/fieldValueCache\");\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes, StrUtils.join(c.pathInConfig, '/')));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":["2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args,\"query/fieldValueCache\");\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes, StrUtils.join(c.pathInConfig, '/')));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(\"luceneMatchVersion\", true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      args.put(\"class\", FastLRUCache.class.getName());\n      conf = new CacheConfig(args,\"query/fieldValueCache\");\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, new CacheConfig(c.attributes, StrUtils.join(c.pathInConfig, '/')));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d7d3943904804560937e6239effeebda0f920e4","date":1573762904,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96","date":1576143009,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param                     loader the resource loader\n   * @param name                the configuration name\n   * @param is                  the configuration stream\n   * @param isConfigsetTrusted  false if configset was uploaded using unsecured configset upload API, true otherwise\n   */\n  private SolrConfig(SolrResourceLoader loader, String name, InputSource is, boolean isConfigsetTrusted)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs(isConfigsetTrusted);\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","sourceOld":"  /**\n   * Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *\n   * @param loader the resource loader\n   * @param name   the configuration name\n   * @param is     the configuration stream\n   */\n  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n      throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    getOverlay();//just in case it is not initialized\n    getRequestParams();\n    initLibs();\n    luceneMatchVersion = SolrConfig.parseLuceneVersionString(getVal(IndexSchema.LUCENE_MATCH_VERSION_PARAM, true));\n    log.info(\"Using Lucene MatchVersion: {}\", luceneMatchVersion);\n\n    String indexConfigPrefix;\n\n    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.\n    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>\n    boolean hasDeprecatedIndexConfig = (getNode(\"indexDefaults\", false) != null) || (getNode(\"mainIndex\", false) != null);\n    if (hasDeprecatedIndexConfig) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.\");\n    } else {\n      indexConfigPrefix = \"indexConfig\";\n    }\n    assertWarnOrFail(\"The <nrtMode> config has been discontinued and NRT mode is always used by Solr.\" +\n            \" This config will be removed in future versions.\", getNode(indexConfigPrefix + \"/nrtMode\", false) == null,\n        true\n    );\n    assertWarnOrFail(\"Solr no longer supports forceful unlocking via the 'unlockOnStartup' option.  \"+\n                     \"This is no longer necessary for the default lockType except in situations where \"+\n                     \"it would be dangerous and should not be done.  For other lockTypes and/or \"+\n                     \"directoryFactory options it may also be dangerous and users must resolve \"+\n                     \"problematic locks manually.\",\n                     null == getNode(indexConfigPrefix + \"/unlockOnStartup\", false),\n                     true // 'fail' in trunk\n                     );\n                     \n    // Parse indexConfig section, using mainIndex as backup in case old config is used\n    indexConfig = new SolrIndexConfig(this, \"indexConfig\", null);\n\n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", IndexSearcher.getMaxClauseCount());\n    if (IndexSearcher.getMaxClauseCount() < booleanQueryMaxClauseCount) {\n      log.warn(\"solrconfig.xml: <maxBooleanClauses> of {} is greater than global limit of {} \"+\n               \"and will have no effect\", booleanQueryMaxClauseCount, IndexSearcher.getMaxClauseCount());\n      log.warn(\"set 'maxBooleanClauses' in solr.xml to increase global limit\");\n    }\n    \n    // Warn about deprecated / discontinued parameters\n    // boolToFilterOptimizer has had no effect since 3.1\n    if (get(\"query/boolTofilterOptimizer\", null) != null)\n      log.warn(\"solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.\");\n    if (get(\"query/HashDocSet\", null) != null)\n      log.warn(\"solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.\");\n\n// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()\n//    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n//    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n//    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n\n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n    \n    useRangeVersionsForPeerSync = getBool(\"peerSync/useRangeVersions\", true);\n\n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String, String> args = new HashMap<>();\n      args.put(NAME, \"fieldValueCache\");\n      args.put(\"size\", \"10000\");\n      args.put(\"initialSize\", \"10\");\n      args.put(\"showItems\", \"-1\");\n      conf = new CacheConfig(CaffeineCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    useColdSearcher = getBool(\"query/useColdSearcher\", false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length() == 0) dataDir = null;\n\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\", 0.75f);\n    hashDocSetMaxSize = getInt(\"//HashDocSet/@maxSize\", 3000);\n\n    if (get(\"jmx\", null) != null) {\n      log.warn(\"solrconfig.xml: <jmx> is no longer supported, use solr.xml:/metrics/reporter section instead\");\n    }\n\n    httpCachingConfig = new HttpCachingConfig(this);\n\n    maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\", 1);\n    slowQueryThresholdMillis = getInt(\"query/slowQueryThresholdMillis\", -1);\n    for (SolrPluginInfo plugin : plugins) loadPluginInfo(plugin);\n\n    Map<String, CacheConfig> userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n    List<PluginInfo> caches = getPluginInfos(SolrCache.class.getName());\n    if (!caches.isEmpty()) {\n      for (PluginInfo c : caches) {\n        userCacheConfigs.put(c.name, CacheConfig.getConfig(this, \"cache\", c.attributes, null));\n      }\n    }\n    this.userCacheConfigs = Collections.unmodifiableMap(userCacheConfigs);\n\n    updateHandlerInfo = loadUpdatehandlerInfo();\n\n    multipartUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", Integer.MAX_VALUE);\n    if (multipartUploadLimitKB == -1) multipartUploadLimitKB = Integer.MAX_VALUE;\n\n    formUploadLimitKB = getInt(\n        \"requestDispatcher/requestParsers/@formdataUploadLimitInKB\", Integer.MAX_VALUE);\n    if (formUploadLimitKB == -1) formUploadLimitKB = Integer.MAX_VALUE;\n\n    enableRemoteStreams = getBool(\n        \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false);\n\n    enableStreamBody = getBool(\n        \"requestDispatcher/requestParsers/@enableStreamBody\", false);\n\n    handleSelect = getBool(\n        \"requestDispatcher/@handleSelect\", false);\n\n    addHttpRequestToContext = getBool(\n        \"requestDispatcher/requestParsers/@addHttpRequestToContext\", false);\n\n    List<PluginInfo> argsInfos = getPluginInfos(InitParams.class.getName());\n    if (argsInfos != null) {\n      Map<String, InitParams> argsMap = new HashMap<>();\n      for (PluginInfo p : argsInfos) {\n        InitParams args = new InitParams(p);\n        argsMap.put(args.name == null ? String.valueOf(args.hashCode()) : args.name, args);\n      }\n      this.initParams = Collections.unmodifiableMap(argsMap);\n\n    }\n\n    solrRequestParsers = new SolrRequestParsers(this);\n    log.debug(\"Loaded SolrConfig: {}\", name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"053c4cbd30d228154839dc536ca5a15a5f0c48bf":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"ae1dfc6b5c606bdefacac904cca6ac5619c4d81e":["618635065f043788c9e034f96ca5cd5cea1b4592"],"36985f6a6a7b91997dfbf45341789379f0d89e62":["0f7392e322590b1c5c54beda8e0dc4dac5a0dc70"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["a2be0a2886c76942ff986465eabde7b858895dc9"],"ae2f5be890d26585d438eba0b9cc7d3c0a9775be":["969792332ae6ed8052858ba4e3cf52502b22550f"],"15f9a498a407241cefcbd00ca7fc84d5e7fa573e":["8381eb1cd44d2e0defb52130de3295a576ac1e7b"],"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a":["36985f6a6a7b91997dfbf45341789379f0d89e62"],"aba371508186796cc6151d8223a5b4e16d02e26e":["21591922fb4db3e2a6ffb2cb342b3d61c053a973","6d061c6ac0252e445714563a37eb8aa9816ce369"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6554f36a4636755009195a7840518bf6b4f03d6c"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"73b91012493e4750b9dc169cf1ae8cdd91493b42":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360":["e2d531c99815e9282449614650df62aad96c688e"],"0f7392e322590b1c5c54beda8e0dc4dac5a0dc70":["057a1793765d068ea9302f1a29e21734ee58d41e"],"bb537081ae8ce706dd40a122f57a9e7b8a112be8":["5e2420f5fc81a6b19783f84250b5a5a3f19eb46a"],"8381eb1cd44d2e0defb52130de3295a576ac1e7b":["d470c8182e92b264680e34081b75e70a9f2b3c89","e511b092029d56e0d4e30204fba8509c1c2647b6"],"e2238da841c6da38e6ed909d35da8f4c0ea3147b":["28288370235ed02234a64753cdbf0c6ec096304a"],"2901fdf41816ed0ac227f1c2245c963778fb2074":["415fc059c6f2340aed1714220b9578c3f66ed09c"],"21591922fb4db3e2a6ffb2cb342b3d61c053a973":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"43fbcd532bdc735ef51c6d46a5f7f0e5bc761cec":["c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"30c8e5574b55d57947e989443dfde611646530ee":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","28288370235ed02234a64753cdbf0c6ec096304a"],"eba342e8f50703ef6d48ac759b5fd5798b34d669":["43fbcd532bdc735ef51c6d46a5f7f0e5bc761cec"],"f8061ddd97f3352007d927dae445884a6f3d857b":["36c70eb3b44de4355a7168b762cadc0f1cf194bc","053c4cbd30d228154839dc536ca5a15a5f0c48bf"],"0388110fe119c0c8d3716cd93e30af79a0b70356":["816521ebaad5add9cb96bb88c577394e2938c40b"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"126d6ad24eed13163ba0959435d5a80e5672837c":["403d05f7f8d69b65659157eff1bc1d2717f04c66","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["6d061c6ac0252e445714563a37eb8aa9816ce369"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["c26f00b574427b55127e869b935845554afde1fa"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["053c4cbd30d228154839dc536ca5a15a5f0c48bf"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["7b91922b55d15444d554721b352861d028eb8278"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4a5469a71486c4c1e313c7fcb08188d7111195c2","6d061c6ac0252e445714563a37eb8aa9816ce369"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9367dbf5b00d7764583d991c1888f4acc9c9991a","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","0388110fe119c0c8d3716cd93e30af79a0b70356"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88"],"e2d531c99815e9282449614650df62aad96c688e":["2901fdf41816ed0ac227f1c2245c963778fb2074"],"0158ced21948b6626f733c1c42c1e18d94449789":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["0388110fe119c0c8d3716cd93e30af79a0b70356"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6554f36a4636755009195a7840518bf6b4f03d6c"],"eb55f6c347c48c2f7a9fb29b2e6dfe819b1a56f9":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88":["e2238da841c6da38e6ed909d35da8f4c0ea3147b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"4d7d3943904804560937e6239effeebda0f920e4":["c44cc06c26e456fe9c215072b79fce30babe3975"],"969792332ae6ed8052858ba4e3cf52502b22550f":["6a94151dd8593cf0cddf5cce38cf48849077be12"],"c44cc06c26e456fe9c215072b79fce30babe3975":["73b91012493e4750b9dc169cf1ae8cdd91493b42"],"057a1793765d068ea9302f1a29e21734ee58d41e":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96":["4d7d3943904804560937e6239effeebda0f920e4"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["bb537081ae8ce706dd40a122f57a9e7b8a112be8"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","0158ced21948b6626f733c1c42c1e18d94449789"],"df724d84dab24a0cc54bec95a8680867adc7f171":["4d7d3943904804560937e6239effeebda0f920e4","ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["969792332ae6ed8052858ba4e3cf52502b22550f","ae2f5be890d26585d438eba0b9cc7d3c0a9775be"],"e511b092029d56e0d4e30204fba8509c1c2647b6":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["ae2f5be890d26585d438eba0b9cc7d3c0a9775be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"6d061c6ac0252e445714563a37eb8aa9816ce369":["21591922fb4db3e2a6ffb2cb342b3d61c053a973"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eba342e8f50703ef6d48ac759b5fd5798b34d669"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["3ab63427379c12859d6d1de312037b877f5148a9"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["8381eb1cd44d2e0defb52130de3295a576ac1e7b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["415fc059c6f2340aed1714220b9578c3f66ed09c","2901fdf41816ed0ac227f1c2245c963778fb2074"],"6a94151dd8593cf0cddf5cce38cf48849077be12":["ac2f1cdbdc54a889e88543cc1d939a931cb96883"],"6554f36a4636755009195a7840518bf6b4f03d6c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3ab63427379c12859d6d1de312037b877f5148a9":["eb55f6c347c48c2f7a9fb29b2e6dfe819b1a56f9"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["126d6ad24eed13163ba0959435d5a80e5672837c"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","e2d531c99815e9282449614650df62aad96c688e"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["ae1dfc6b5c606bdefacac904cca6ac5619c4d81e"],"816521ebaad5add9cb96bb88c577394e2938c40b":["6554f36a4636755009195a7840518bf6b4f03d6c"],"ac2f1cdbdc54a889e88543cc1d939a931cb96883":["b5a70f7ff0756e3668447bffbbf8bce8e7c361b9"],"28288370235ed02234a64753cdbf0c6ec096304a":["816521ebaad5add9cb96bb88c577394e2938c40b","5ff704ef91e9ae30ca59babb23ece85720701b60"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a2be0a2886c76942ff986465eabde7b858895dc9":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"618635065f043788c9e034f96ca5cd5cea1b4592":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"7b91922b55d15444d554721b352861d028eb8278":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["2d4e985daefcb892b529223b478c47985fc3c483"],"e73d8d559120669b47658108d818b637df5456ea":["30c8e5574b55d57947e989443dfde611646530ee","e2238da841c6da38e6ed909d35da8f4c0ea3147b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2d4e985daefcb892b529223b478c47985fc3c483":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"415fc059c6f2340aed1714220b9578c3f66ed09c":["9cf81bc8c6e4078e236f0e38b3a2d0271854f207"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"b5a70f7ff0756e3668447bffbbf8bce8e7c361b9":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["8381eb1cd44d2e0defb52130de3295a576ac1e7b","15f9a498a407241cefcbd00ca7fc84d5e7fa573e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96"],"b0b597c65628ca9e73913a07e81691f8229bae35":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"053c4cbd30d228154839dc536ca5a15a5f0c48bf":["f8061ddd97f3352007d927dae445884a6f3d857b","6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"ae1dfc6b5c606bdefacac904cca6ac5619c4d81e":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"36985f6a6a7b91997dfbf45341789379f0d89e62":["5e2420f5fc81a6b19783f84250b5a5a3f19eb46a"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["053c4cbd30d228154839dc536ca5a15a5f0c48bf","f8061ddd97f3352007d927dae445884a6f3d857b"],"ae2f5be890d26585d438eba0b9cc7d3c0a9775be":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"15f9a498a407241cefcbd00ca7fc84d5e7fa573e":["3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a":["bb537081ae8ce706dd40a122f57a9e7b8a112be8"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["057a1793765d068ea9302f1a29e21734ee58d41e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"73b91012493e4750b9dc169cf1ae8cdd91493b42":["c44cc06c26e456fe9c215072b79fce30babe3975"],"c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360":["43fbcd532bdc735ef51c6d46a5f7f0e5bc761cec"],"0f7392e322590b1c5c54beda8e0dc4dac5a0dc70":["36985f6a6a7b91997dfbf45341789379f0d89e62"],"bb537081ae8ce706dd40a122f57a9e7b8a112be8":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"8381eb1cd44d2e0defb52130de3295a576ac1e7b":["15f9a498a407241cefcbd00ca7fc84d5e7fa573e","403d05f7f8d69b65659157eff1bc1d2717f04c66","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"e2238da841c6da38e6ed909d35da8f4c0ea3147b":["2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88","e73d8d559120669b47658108d818b637df5456ea"],"21591922fb4db3e2a6ffb2cb342b3d61c053a973":["aba371508186796cc6151d8223a5b4e16d02e26e","6d061c6ac0252e445714563a37eb8aa9816ce369"],"2901fdf41816ed0ac227f1c2245c963778fb2074":["e2d531c99815e9282449614650df62aad96c688e","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"43fbcd532bdc735ef51c6d46a5f7f0e5bc761cec":["eba342e8f50703ef6d48ac759b5fd5798b34d669"],"afb6bf9ce227ab6aac5068547e286ecc958b8b9d":["2d4e985daefcb892b529223b478c47985fc3c483"],"30c8e5574b55d57947e989443dfde611646530ee":["e73d8d559120669b47658108d818b637df5456ea"],"eba342e8f50703ef6d48ac759b5fd5798b34d669":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"0388110fe119c0c8d3716cd93e30af79a0b70356":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","5ff704ef91e9ae30ca59babb23ece85720701b60"],"a94e45463a0089149b0d148ae5369140e7f54b8c":["b5a70f7ff0756e3668447bffbbf8bce8e7c361b9"],"126d6ad24eed13163ba0959435d5a80e5672837c":["0d62172dd2fc1195c7e475550ac394a9948a18ae"],"9cf81bc8c6e4078e236f0e38b3a2d0271854f207":["415fc059c6f2340aed1714220b9578c3f66ed09c"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["7b91922b55d15444d554721b352861d028eb8278"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["73b91012493e4750b9dc169cf1ae8cdd91493b42","b0b597c65628ca9e73913a07e81691f8229bae35"],"4a5469a71486c4c1e313c7fcb08188d7111195c2":["21591922fb4db3e2a6ffb2cb342b3d61c053a973","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["0158ced21948b6626f733c1c42c1e18d94449789","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["30c8e5574b55d57947e989443dfde611646530ee"],"e2d531c99815e9282449614650df62aad96c688e":["c9f81a0a8d08cc36757b7be45a8c8dcd66ff0360","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["a2be0a2886c76942ff986465eabde7b858895dc9"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"eb55f6c347c48c2f7a9fb29b2e6dfe819b1a56f9":["3ab63427379c12859d6d1de312037b877f5148a9"],"c26f00b574427b55127e869b935845554afde1fa":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"2eb89ed39d48c9dbf1ec6df65ed11f8cf5331e88":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"969792332ae6ed8052858ba4e3cf52502b22550f":["ae2f5be890d26585d438eba0b9cc7d3c0a9775be","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"4d7d3943904804560937e6239effeebda0f920e4":["ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96","df724d84dab24a0cc54bec95a8680867adc7f171"],"057a1793765d068ea9302f1a29e21734ee58d41e":["0f7392e322590b1c5c54beda8e0dc4dac5a0dc70"],"c44cc06c26e456fe9c215072b79fce30babe3975":["4d7d3943904804560937e6239effeebda0f920e4","b0b597c65628ca9e73913a07e81691f8229bae35"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["eb55f6c347c48c2f7a9fb29b2e6dfe819b1a56f9"],"ad8024a22d8bd3a09b7f618f41cdfe117ae6fe96":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["8381eb1cd44d2e0defb52130de3295a576ac1e7b","e511b092029d56e0d4e30204fba8509c1c2647b6"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"e511b092029d56e0d4e30204fba8509c1c2647b6":["8381eb1cd44d2e0defb52130de3295a576ac1e7b"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","618635065f043788c9e034f96ca5cd5cea1b4592"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["6554f36a4636755009195a7840518bf6b4f03d6c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6d061c6ac0252e445714563a37eb8aa9816ce369":["aba371508186796cc6151d8223a5b4e16d02e26e","9cf81bc8c6e4078e236f0e38b3a2d0271854f207","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["afb6bf9ce227ab6aac5068547e286ecc958b8b9d"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["a94e45463a0089149b0d148ae5369140e7f54b8c"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["126d6ad24eed13163ba0959435d5a80e5672837c","7f0c8426396c925de8db3ed3f8ff40fd73670a5c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"6a94151dd8593cf0cddf5cce38cf48849077be12":["969792332ae6ed8052858ba4e3cf52502b22550f"],"6554f36a4636755009195a7840518bf6b4f03d6c":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3ab63427379c12859d6d1de312037b877f5148a9":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","733eaf468f18297b1bcc51031353bdfdd1913bdf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"28288370235ed02234a64753cdbf0c6ec096304a":["e2238da841c6da38e6ed909d35da8f4c0ea3147b","30c8e5574b55d57947e989443dfde611646530ee"],"816521ebaad5add9cb96bb88c577394e2938c40b":["0388110fe119c0c8d3716cd93e30af79a0b70356","28288370235ed02234a64753cdbf0c6ec096304a"],"ac2f1cdbdc54a889e88543cc1d939a931cb96883":["6a94151dd8593cf0cddf5cce38cf48849077be12"],"618635065f043788c9e034f96ca5cd5cea1b4592":["ae1dfc6b5c606bdefacac904cca6ac5619c4d81e"],"a2be0a2886c76942ff986465eabde7b858895dc9":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"7b91922b55d15444d554721b352861d028eb8278":["4a5469a71486c4c1e313c7fcb08188d7111195c2"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"dd330c9d05eacbd6e952fe0dea852e7ae037eb50":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"e73d8d559120669b47658108d818b637df5456ea":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"415fc059c6f2340aed1714220b9578c3f66ed09c":["2901fdf41816ed0ac227f1c2245c963778fb2074","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"2d4e985daefcb892b529223b478c47985fc3c483":["dd330c9d05eacbd6e952fe0dea852e7ae037eb50"],"733eaf468f18297b1bcc51031353bdfdd1913bdf":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"b5a70f7ff0756e3668447bffbbf8bce8e7c361b9":["ac2f1cdbdc54a889e88543cc1d939a931cb96883"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","d2638f781be724518ff6c2263d14a48cf6e68017","f8061ddd97f3352007d927dae445884a6f3d857b","fe33227f6805edab2036cbb80645cc4e2d1fa424","df724d84dab24a0cc54bec95a8680867adc7f171","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e73d8d559120669b47658108d818b637df5456ea","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}