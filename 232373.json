{"path":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","commits":[{"id":"fb1ee331628e5e48978d05663ce7cd8c8fe2a471","date":1324228266,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    final int threadCount = atLeast(32), keyCount = atLeast(1024);\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount + 1);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      final AtomicInteger running = new AtomicInteger(threadCount);\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        final int count = atLeast(rnd, 20000);\n        exec.execute(new Runnable() {\n          public void run() {\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n            running.decrementAndGet();\n          }\n        });\n      }\n      exec.execute(new Runnable() {\n        public void run() {\n          // check that GC does not cause problems in reap() method:\n          while (running.get() > 0) {\n            System.runFinalization();\n            System.gc();\n            map.isEmpty(); // simple access\n          }\n        }\n      });\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"934a555c0310a0cc5317640ee0f1d86c93812b3f","date":1324296890,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    final int threadCount = atLeast(32), keyCount = atLeast(1024);\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        final int count = atLeast(rnd, 20000);\n        exec.execute(new Runnable() {\n          public void run() {\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    final int threadCount = atLeast(32), keyCount = atLeast(1024);\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount + 1);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      final AtomicInteger running = new AtomicInteger(threadCount);\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        final int count = atLeast(rnd, 20000);\n        exec.execute(new Runnable() {\n          public void run() {\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n            running.decrementAndGet();\n          }\n        });\n      }\n      exec.execute(new Runnable() {\n        public void run() {\n          // check that GC does not cause problems in reap() method:\n          while (running.get() > 0) {\n            System.runFinalization();\n            System.gc();\n            map.isEmpty(); // simple access\n          }\n        }\n      });\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63b5a60b7591d29f38770f82ea1418afe637f0a8","date":1324378397,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    final int threadCount = atLeast(32), keyCount = atLeast(1024);\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        final int count = atLeast(rnd, 20000);\n        exec.execute(new Runnable() {\n          public void run() {\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestWeakIdentityMap#testConcurrentHashMap().mjava","sourceNew":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","sourceOld":"  public void testConcurrentHashMap() throws Exception {\n    // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:\n    final int threadCount = 8, keyCount = 1024;\n    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);\n    final WeakIdentityMap<Object,Integer> map =\n      WeakIdentityMap.newConcurrentHashMap();\n    // we keep strong references to the keys,\n    // so WeakIdentityMap will not forget about them:\n    final AtomicReferenceArray<Object> keys = new AtomicReferenceArray<Object>(keyCount);\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, new Object());\n    }\n    \n    try {\n      for (int t = 0; t < threadCount; t++) {\n        final Random rnd = new Random(random.nextLong());\n        exec.execute(new Runnable() {\n          public void run() {\n            final int count = atLeast(rnd, 10000);\n            for (int i = 0; i < count; i++) {\n              final int j = rnd.nextInt(keyCount);\n              switch (rnd.nextInt(4)) {\n                case 0:\n                  map.put(keys.get(j), Integer.valueOf(j));\n                  break;\n                case 1:\n                  final Integer v = map.get(keys.get(j));\n                  if (v != null) {\n                    assertEquals(j, v.intValue());\n                  }\n                  break;\n                case 2:\n                  map.remove(keys.get(j));\n                  break;\n                case 3:\n                  // renew key, the old one will be GCed at some time:\n                  keys.set(j, new Object());\n                  break;\n                default:\n                  fail(\"Should not get here.\");\n              }\n            }\n          }\n        });\n      }\n    } finally {\n      exec.shutdown();\n      while (!exec.awaitTermination(1000L, TimeUnit.MILLISECONDS));\n    }\n    \n    // clear strong refs\n    for (int j = 0; j < keyCount; j++) {\n      keys.set(j, null);\n    }\n    \n    // check that GC does not cause problems in reap() method:\n    int size = map.size();\n    for (int i = 0; size > 0 && i < 10; i++) try {\n      System.runFinalization();\n      System.gc();\n      Thread.sleep(100L);\n      assertTrue(size >= map.size());\n      size = map.size();\n    } catch (InterruptedException ie) {}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"934a555c0310a0cc5317640ee0f1d86c93812b3f":["fb1ee331628e5e48978d05663ce7cd8c8fe2a471"],"63b5a60b7591d29f38770f82ea1418afe637f0a8":["934a555c0310a0cc5317640ee0f1d86c93812b3f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["63b5a60b7591d29f38770f82ea1418afe637f0a8"],"fb1ee331628e5e48978d05663ce7cd8c8fe2a471":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"934a555c0310a0cc5317640ee0f1d86c93812b3f":["63b5a60b7591d29f38770f82ea1418afe637f0a8"],"63b5a60b7591d29f38770f82ea1418afe637f0a8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"fb1ee331628e5e48978d05663ce7cd8c8fe2a471":["934a555c0310a0cc5317640ee0f1d86c93812b3f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb1ee331628e5e48978d05663ce7cd8c8fe2a471"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}