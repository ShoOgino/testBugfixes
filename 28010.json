{"path":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermText(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermText(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermBuffer(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermBuffer(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermBuffer(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7347509fad0711ac30cb15a746e9a3830a38ebd","date":1275388513,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token();\n      token.setTermBuffer(original);\n      token.setStartOffset(suggestion.getStartOffset());\n      token.setEndOffset(suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6aab5206b894bf0ea232b059a45cf2de460726f","date":1284150281,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":["9079aceb3d611cfeb6922ebdf91003c30a08b745"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d","date":1286157263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdcf766020b9b159d0b3a6ecae90ff1998ded019","date":1286818331,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = ((SuggestWord) sugQueue.top()).score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = ((SuggestWord) sugQueue.pop());\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n    response.add(\"suggestions\", toNamedList(result, origQuery, extendedResults, collate));\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","date":1307486921,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.add(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"d6aab5206b894bf0ea232b059a45cf2de460726f":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["cdcf766020b9b159d0b3a6ecae90ff1998ded019","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"c26f00b574427b55127e869b935845554afde1fa":["de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a7347509fad0711ac30cb15a746e9a3830a38ebd","cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["cdcf766020b9b159d0b3a6ecae90ff1998ded019","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["de86357ed7f45c7efec5ea6ab5a403b027a9f0b0"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"3f7e3e91f914e6265ed09a3208cc60c9ba2a477d":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"d6aab5206b894bf0ea232b059a45cf2de460726f":["3f7e3e91f914e6265ed09a3208cc60c9ba2a477d"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","de86357ed7f45c7efec5ea6ab5a403b027a9f0b0","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"de86357ed7f45c7efec5ea6ab5a403b027a9f0b0":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","c26f00b574427b55127e869b935845554afde1fa","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","a258fbb26824fd104ed795e5d9033d2d040049ee"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"1da8d55113b689b06716246649de6f62430f15c0":["a7347509fad0711ac30cb15a746e9a3830a38ebd"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"a7347509fad0711ac30cb15a746e9a3830a38ebd":["d6aab5206b894bf0ea232b059a45cf2de460726f","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}