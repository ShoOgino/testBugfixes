{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/BlockWriter#splitAndWriteBlock(IndexDictionary.Builder).mjava","commits":[{"id":"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89","date":1567784912,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/BlockWriter#splitAndWriteBlock(IndexDictionary.Builder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Defines the new block start according to {@link #targetNumBlockLines}\n   * and {@link #deltaNumLines}.\n   * The new block is started (including one or more of the lastly added lines),\n   * the current block is written to the block file, and the current block key\n   * is added to the {@link IndexDictionary.Builder}.\n   */\n  protected void splitAndWriteBlock(IndexDictionary.Builder dictionaryBuilder) throws IOException {\n    assert !blockLines.isEmpty();\n    int numLines = blockLines.size();\n\n    if (numLines <= targetNumBlockLines - deltaNumLines) {\n      writeBlock(blockLines, dictionaryBuilder);\n      blockLines.clear();\n      return;\n    }\n    int deltaStart = numLines - deltaNumLines * 2;\n    assert deltaStart >= 1 : \"blockLines size: \" + numLines;\n    int minMdpLength = Integer.MAX_VALUE;\n    int minMdpEndIndex = 0;\n\n    for (int i = deltaStart; i < numLines; i++) {\n      TermBytes term = blockLines.get(i).getTermBytes();\n      int mdpLength = term.getMdpLength();\n      if (mdpLength <= minMdpLength) {\n        minMdpLength = mdpLength;\n        minMdpEndIndex = i;\n      }\n    }\n\n    List<BlockLine> subList = blockLines.subList(0, minMdpEndIndex);\n    writeBlock(subList, dictionaryBuilder);\n    // Clear the written block lines to keep only the lines composing the next block.\n    // ArrayList.subList().clear() is O(N) but still fast since we work on a small list.\n    // It is internally an array copy and an iteration to set array refs to null.\n    // For clarity we keep that until the day a CircularArrayList is available in the jdk.\n    subList.clear();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}