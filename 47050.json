{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","commits":[{"id":"41aee74b5f91a096e3fd950f4a336bc763f0e7a7","date":1381772070,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqPayloadIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqPayloadIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a645276cbaf5dc96a42fd473b9019bde352996c8","date":1391806699,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36f5a8c57e16c0f801006a52f87c75378427852e","date":1393256707,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["ada2f7352a7f964fe49bccd13227c4ec38563d39","6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a1b4b3eeb982c8dc5baea5886cfb0e8af4b3553","date":1399644656,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["5a48377c9931ddb38c784846217ff68d7dcd0b44","c784b25e28b81ddedff2b97738c8286773f00f15","6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc3688252d4a8045d69a164236b2cf87b721f17","date":1409846185,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput.toPath());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5","0c1a09d2dfe98662e5268acb84685b971e16daf1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    File directory = OfflineSorter.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput.toPath());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35fa550f45857d99d3d6d743420ee54b4d0c37f8","date":1436039255,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n        count++;\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2","date":1443129829,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.getDefaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.defaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    String prefix = getClass().getSimpleName();\n    Path directory = OfflineSorter.getDefaultTempDir();\n    Path tempInput = Files.createTempFile(directory, prefix, \".input\");\n    Path tempSorted = Files.createTempFile(directory, prefix, \".sorted\");\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      Files.delete(tempInput);\n\n      reader = new OfflineSorter.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      \n      if (success) {\n        IOUtils.deleteFilesIfExist(tempInput, tempSorted);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(tempInput, tempSorted);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFiles(Collections.singleton(tempInput.getName()));\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFiles(Collections.singleton(tempInput.getName()));\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950b7a6881d14da782b60444c11295e3ec50d41a","date":1458379095,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName, IOContext.READONCE));\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7849935cc625c020857f3b29be91b5d4323d19aa","date":1458978426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (true) {\n        BytesRef bytes = reader.next();\n        if (bytes == null) {\n          break;\n        }\n        input.reset(bytes.bytes, bytes.offset, bytes.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = bytes.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = bytes.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = bytes.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes(), 0, scratch.length());\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes();\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length() - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length() - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes(), payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      FSTCompiler<Pair<Long,BytesRef>> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (true) {\n        BytesRef bytes = reader.next();\n        if (bytes == null) {\n          break;\n        }\n        input.reset(bytes.bytes, bytes.offset, bytes.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = bytes.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = bytes.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = bytes.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = fstCompiler.compile();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (true) {\n        BytesRef bytes = reader.next();\n        if (bytes == null) {\n          break;\n        }\n        input.reset(bytes.bytes, bytes.offset, bytes.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = bytes.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = bytes.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = bytes.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(InputIterator).mjava","sourceNew":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      FSTCompiler<Pair<Long,BytesRef>> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (true) {\n        BytesRef bytes = reader.next();\n        if (bytes == null) {\n          break;\n        }\n        input.reset(bytes.bytes, bytes.offset, bytes.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = bytes.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = bytes.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = bytes.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          fstCompiler.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = fstCompiler.compile();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(InputIterator iterator) throws IOException {\n    if (iterator.hasContexts()) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n\n    hasPayloads = iterator.hasPayloads();\n\n    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix, new AnalyzingComparator(hasPayloads));\n\n    IndexOutput tempInput = tempDir.createTempOutput(tempFileNamePrefix, \"input\", IOContext.DEFAULT);\n\n    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);\n    OfflineSorter.ByteSequencesReader reader = null;\n    BytesRefBuilder scratch = new BytesRefBuilder();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    String tempSortedFileName = null;\n\n    count = 0;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n\n      for (BytesRef surfaceForm; (surfaceForm = iterator.next()) != null;) {\n        LimitedFiniteStringsIterator finiteStrings =\n            new LimitedFiniteStringsIterator(toAutomaton(surfaceForm, ts2a), maxGraphExpansions);\n\n        for (IntsRef string; (string = finiteStrings.next()) != null; count++) {\n          Util.toBytesRef(string, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length() > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length() + \")\");\n          }\n          short analyzedLength = (short) scratch.length();\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes(), 0, scratch.length());\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n          writer.write(buffer, 0, output.getPosition());\n        }\n\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, finiteStrings.size());\n      }\n      CodecUtil.writeFooter(tempInput);\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      tempSortedFileName = sorter.sort(tempInput.getName());\n\n      // Free disk space:\n      tempDir.deleteFile(tempInput.getName());\n\n      reader = new OfflineSorter.ByteSequencesReader(tempDir.openChecksumInput(tempSortedFileName, IOContext.READONCE), tempSortedFileName);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRefBuilder previousAnalyzed = null;\n      BytesRefBuilder analyzed = new BytesRefBuilder();\n      BytesRef surface = new BytesRef();\n      IntsRefBuilder scratchInts = new IntsRefBuilder();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<>();\n\n      int dedup = 0;\n      while (true) {\n        BytesRef bytes = reader.next();\n        if (bytes == null) {\n          break;\n        }\n        input.reset(bytes.bytes, bytes.offset, bytes.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes(), 0, analyzedLength);\n        analyzed.setLength(analyzedLength);\n\n        long cost = input.readInt();\n\n        surface.bytes = bytes.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = bytes.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRefBuilder();\n          previousAnalyzed.copyBytes(analyzed.get());\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.get().equals(previousAnalyzed.get())) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.append((byte) 0);\n        analyzed.append((byte) dedup);\n\n        Util.toIntsRef(analyzed.get(), scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts.get(), outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = bytes.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(bytes.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts.get(), outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n    } finally {\n      IOUtils.closeWhileHandlingException(reader, writer);\n      IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName(), tempSortedFileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["1a1b4b3eeb982c8dc5baea5886cfb0e8af4b3553"],"f4abec28b874149a7223e32cc7a01704c27790de":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"a645276cbaf5dc96a42fd473b9019bde352996c8":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"35fa550f45857d99d3d6d743420ee54b4d0c37f8":["f4abec28b874149a7223e32cc7a01704c27790de"],"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["35fa550f45857d99d3d6d743420ee54b4d0c37f8"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["a645276cbaf5dc96a42fd473b9019bde352996c8","36f5a8c57e16c0f801006a52f87c75378427852e"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"36f5a8c57e16c0f801006a52f87c75378427852e":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"7849935cc625c020857f3b29be91b5d4323d19aa":["950b7a6881d14da782b60444c11295e3ec50d41a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950b7a6881d14da782b60444c11295e3ec50d41a":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["7849935cc625c020857f3b29be91b5d4323d19aa","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["7849935cc625c020857f3b29be91b5d4323d19aa"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"1a1b4b3eeb982c8dc5baea5886cfb0e8af4b3553":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["1a1b4b3eeb982c8dc5baea5886cfb0e8af4b3553"],"41aee74b5f91a096e3fd950f4a336bc763f0e7a7":["a645276cbaf5dc96a42fd473b9019bde352996c8"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"f4abec28b874149a7223e32cc7a01704c27790de":["35fa550f45857d99d3d6d743420ee54b4d0c37f8"],"a645276cbaf5dc96a42fd473b9019bde352996c8":["ba791bce8103c79e38f957e9c5a53a75871bd918","36f5a8c57e16c0f801006a52f87c75378427852e"],"35fa550f45857d99d3d6d743420ee54b4d0c37f8":["8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2"],"8ccfbb043f2ebf23df8782dd32a68ff1b399c3d2":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cbc3688252d4a8045d69a164236b2cf87b721f17":["f4abec28b874149a7223e32cc7a01704c27790de"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"36f5a8c57e16c0f801006a52f87c75378427852e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["41aee74b5f91a096e3fd950f4a336bc763f0e7a7"],"7849935cc625c020857f3b29be91b5d4323d19aa":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"950b7a6881d14da782b60444c11295e3ec50d41a":["7849935cc625c020857f3b29be91b5d4323d19aa"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1a1b4b3eeb982c8dc5baea5886cfb0e8af4b3553":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["950b7a6881d14da782b60444c11295e3ec50d41a","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}