{"path":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","commits":[{"id":"61e52acc0f10ced3042a4d0257710497d5ccf4ad","date":1289767503,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=0;  // make >0 to enable test\n    int queryIter=1000;\n\n    while (--indexIter >= 0) {\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',2,2)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,10)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n\n      Map<Comparable, Doc> model = indexDocs(types, null, 2);\n      System.out.println(\"############### model=\" + model);\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n        int rows = random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(11)-1;\ngroup_limit = random.nextInt(10)+1;\n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        // sort each group\n        String[] stringSortA = new String[1];\n        Comparator<Doc> groupComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // Test specific sort\n        /***\n         groupComparator = createComparator(\"_docid_\", false, false, false);\n         stringSort = \"_docid_ desc\";\n         ***/\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n        Comparator<Doc> sortComparator = random.nextBoolean() ? groupComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["286e1dbf267cac3961c3fc116b9069797ad7d1c2","286e1dbf267cac3961c3fc116b9069797ad7d1c2","286e1dbf267cac3961c3fc116b9069797ad7d1c2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b22a6f1b1da25ec412f6227c5135b917ee84fbe8","date":1290004614,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n// TODO: remove restriction on 0\ngroup_limit = random.nextInt(10)+1;      \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n// TODO: fix/support different groupComparator\ngroupComparator = sortComparator;\ngroupSortStr = null;\n// rows=1; start=0; group_offset=1; group_limit=1;\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=0;  // make >0 to enable test\n    int queryIter=1000;\n\n    while (--indexIter >= 0) {\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',2,2)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,10)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n\n      Map<Comparable, Doc> model = indexDocs(types, null, 2);\n      System.out.println(\"############### model=\" + model);\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n        int rows = random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(11)-1;\ngroup_limit = random.nextInt(10)+1;\n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        // sort each group\n        String[] stringSortA = new String[1];\n        Comparator<Doc> groupComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // Test specific sort\n        /***\n         groupComparator = createComparator(\"_docid_\", false, false, false);\n         stringSort = \"_docid_ desc\";\n         ***/\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n        Comparator<Doc> sortComparator = random.nextBoolean() ? groupComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=0;  // make >0 to enable test\n    int queryIter=1000;\n\n    while (--indexIter >= 0) {\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',2,2)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,10)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n\n      Map<Comparable, Doc> model = indexDocs(types, null, 2);\n      System.out.println(\"############### model=\" + model);\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n        int rows = random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(11)-1;\ngroup_limit = random.nextInt(10)+1;\n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        // sort each group\n        String[] stringSortA = new String[1];\n        Comparator<Doc> groupComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // Test specific sort\n        /***\n         groupComparator = createComparator(\"_docid_\", false, false, false);\n         stringSort = \"_docid_ desc\";\n         ***/\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n        Comparator<Doc> sortComparator = random.nextBoolean() ? groupComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43e368cad6a1cc3992f44375801ea528f49b542e","date":1290206535,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n// TODO: fix/support different groupComparator\ngroupComparator = sortComparator;\ngroupSortStr = null;\n// rows=1; start=0; group_offset=1; group_limit=1;\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n// TODO: remove restriction on 0\ngroup_limit = random.nextInt(10)+1;      \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n// TODO: fix/support different groupComparator\ngroupComparator = sortComparator;\ngroupSortStr = null;\n// rows=1; start=0; group_offset=1; group_limit=1;\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e62f57eded31ecb5e6b09f8edad73ba2819a5269","date":1290374488,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n// TODO: fix/support different groupComparator\ngroupComparator = sortComparator;\ngroupSortStr = null;\n// rows=1; start=0; group_offset=1; group_limit=1;\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a1f2fd9c5ec6d68e6c57de139a66673b613e13b","date":1290540872,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ONE_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ONE_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=0;  // make >0 to enable test\n    int queryIter=1000;\n\n    while (--indexIter >= 0) {\n\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',2,2)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ONE_ONE, new IRange(0,10)));\n      types.add(new FldType(\"foo_s\",ONE_ONE, new SVal('a','z',1,2)));\n\n      Map<Comparable, Doc> model = indexDocs(types, null, 2);\n      System.out.println(\"############### model=\" + model);\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n        int rows = random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(11)-1;\ngroup_limit = random.nextInt(10)+1;\n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        // sort each group\n        String[] stringSortA = new String[1];\n        Comparator<Doc> groupComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // Test specific sort\n        /***\n         groupComparator = createComparator(\"_docid_\", false, false, false);\n         stringSort = \"_docid_ desc\";\n         ***/\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups by the first doc in that group\n        Comparator<Doc> sortComparator = random.nextBoolean() ? groupComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups, createFirstDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9001fdb834e467ef899e41c747c42b27b4d45099","date":1296775304,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(\"foo_s\",ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(\"small_s\",ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(\"small_i\",ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"c\");\n        d1.getValues(\"small_i\").set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(\"small_s\").set(0,\"b\");\n        d1.getValues(\"small_i\").set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=\"small_i\";\n          sortComparator=createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, true)));\n          sortStr = \"small_s asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(\"small_s\", true, true, false, false)));\n          groupSortStr = \"small_s asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c7cdfe5a1ea9db97faa404b251fa644faa73597","date":1308345959,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7edfc3f7caa7b49a18fe367692768b33b018e9db","date":1308374217,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit);\n\n        // TODO: create a random filter too\n\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"nosort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"c26f00b574427b55127e869b935845554afde1fa":["9c7cdfe5a1ea9db97faa404b251fa644faa73597","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1a1f2fd9c5ec6d68e6c57de139a66673b613e13b"],"61e52acc0f10ced3042a4d0257710497d5ccf4ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b22a6f1b1da25ec412f6227c5135b917ee84fbe8":["61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"43e368cad6a1cc3992f44375801ea528f49b542e":["b22a6f1b1da25ec412f6227c5135b917ee84fbe8"],"7edfc3f7caa7b49a18fe367692768b33b018e9db":["9001fdb834e467ef899e41c747c42b27b4d45099","9c7cdfe5a1ea9db97faa404b251fa644faa73597"],"1a1f2fd9c5ec6d68e6c57de139a66673b613e13b":["e62f57eded31ecb5e6b09f8edad73ba2819a5269"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["7edfc3f7caa7b49a18fe367692768b33b018e9db"],"9001fdb834e467ef899e41c747c42b27b4d45099":["1a1f2fd9c5ec6d68e6c57de139a66673b613e13b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["3bb13258feba31ab676502787ab2e1779f129b7a","9001fdb834e467ef899e41c747c42b27b4d45099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9c7cdfe5a1ea9db97faa404b251fa644faa73597":["9001fdb834e467ef899e41c747c42b27b4d45099"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["9c7cdfe5a1ea9db97faa404b251fa644faa73597"],"e62f57eded31ecb5e6b09f8edad73ba2819a5269":["43e368cad6a1cc3992f44375801ea528f49b542e"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","9001fdb834e467ef899e41c747c42b27b4d45099"],"3bb13258feba31ab676502787ab2e1779f129b7a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","1a1f2fd9c5ec6d68e6c57de139a66673b613e13b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["3bb13258feba31ab676502787ab2e1779f129b7a"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"61e52acc0f10ced3042a4d0257710497d5ccf4ad":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","b22a6f1b1da25ec412f6227c5135b917ee84fbe8"],"b22a6f1b1da25ec412f6227c5135b917ee84fbe8":["43e368cad6a1cc3992f44375801ea528f49b542e"],"43e368cad6a1cc3992f44375801ea528f49b542e":["e62f57eded31ecb5e6b09f8edad73ba2819a5269"],"7edfc3f7caa7b49a18fe367692768b33b018e9db":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"1a1f2fd9c5ec6d68e6c57de139a66673b613e13b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","9001fdb834e467ef899e41c747c42b27b4d45099","3bb13258feba31ab676502787ab2e1779f129b7a"],"9001fdb834e467ef899e41c747c42b27b4d45099":["7edfc3f7caa7b49a18fe367692768b33b018e9db","29ef99d61cda9641b6250bf9567329a6e65f901d","9c7cdfe5a1ea9db97faa404b251fa644faa73597","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"9c7cdfe5a1ea9db97faa404b251fa644faa73597":["c26f00b574427b55127e869b935845554afde1fa","7edfc3f7caa7b49a18fe367692768b33b018e9db","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e62f57eded31ecb5e6b09f8edad73ba2819a5269":["1a1f2fd9c5ec6d68e6c57de139a66673b613e13b"],"3bb13258feba31ab676502787ab2e1779f129b7a":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}