{"path":"src/test-deprecated/org/apache/lucene/index/TermInfosTest#test().mjava","commits":[{"id":"5b5461affe637a07375542c763a4805300802be8","date":1102270918,"type":0,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/test-deprecated/org/apache/lucene/index/TermInfosTest#test().mjava","pathOld":"/dev/null","sourceNew":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91ad7bf225539c1d47faabb5f34da23cc4cf0617","date":1114538469,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/test-deprecated/org/apache/lucene/index/TermInfosTest#test().mjava","pathOld":"src/test-deprecated/org/apache/lucene/index/TermInfosTest#test().mjava","sourceNew":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis,\n    \t\tIndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","sourceOld":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69e98ffd83f56083b99e5443ca713cd5783a2ae","date":1142955392,"type":4,"author":"Yonik Seeley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test-deprecated/org/apache/lucene/index/TermInfosTest#test().mjava","sourceNew":null,"sourceOld":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis,\n    \t\tIndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b5461affe637a07375542c763a4805300802be8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["91ad7bf225539c1d47faabb5f34da23cc4cf0617"],"91ad7bf225539c1d47faabb5f34da23cc4cf0617":["5b5461affe637a07375542c763a4805300802be8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"]},"commit2Childs":{"5b5461affe637a07375542c763a4805300802be8":["91ad7bf225539c1d47faabb5f34da23cc4cf0617"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b5461affe637a07375542c763a4805300802be8"],"91ad7bf225539c1d47faabb5f34da23cc4cf0617":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}