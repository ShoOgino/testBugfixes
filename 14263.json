{"path":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","commits":[{"id":"b1add9ddc0005b07550d4350720aac22dc9886b3","date":1295549635,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"/dev/null","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e4db7734414fc682d619339760cc21cc16cd0b1d","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4db7734414fc682d619339760cc21cc16cd0b1d","date":1295892961,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":["b1add9ddc0005b07550d4350720aac22dc9886b3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd1bfe3cedf815c14939d170d53031c88eb5c444","date":1295896578,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"/dev/null","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"/dev/null","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762","date":1297938719,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount) {\n          if (!nextBlock()) {\n            //System.out.println(\"  eof\");\n            indexIsCurrent = false;\n            return null;\n          }\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termBlockOrd + \" (vs \" + blockTermCount + \")\");\n        if (state.termBlockOrd == blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termBlockOrd++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term + \" tbOrd=\" + state.termBlockOrd);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termCount + \" (vs \" + state.blockTermCount + \")\");\n        if (state.termCount == state.blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termCount++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.FieldReader.SegmentTermsEnum#_next().mjava","sourceNew":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termBlockOrd + \" (vs \" + blockTermCount + \")\");\n        if (state.termBlockOrd == blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termBlockOrd++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term + \" tbOrd=\" + state.termBlockOrd);\n        return term;\n      }\n\n","sourceOld":"      /* Decodes only the term bytes of the next term.  If caller then asks for\n         metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n         decode all metadata up to the current term. */\n      private BytesRef _next() throws IOException {\n        //System.out.println(\"BTR._next seg=\" + segment + \" this=\" + this + \" termCount=\" + state.termBlockOrd + \" (vs \" + blockTermCount + \")\");\n        if (state.termBlockOrd == blockTermCount && !nextBlock()) {\n          //System.out.println(\"  eof\");\n          indexIsCurrent = false;\n          return null;\n        }\n\n        // TODO: cutover to something better for these ints!  simple64?\n        final int suffix = termSuffixesReader.readVInt();\n        //System.out.println(\"  suffix=\" + suffix);\n\n        term.length = termBlockPrefix + suffix;\n        if (term.bytes.length < term.length) {\n          term.grow(term.length);\n        }\n        termSuffixesReader.readBytes(term.bytes, termBlockPrefix, suffix);\n        state.termBlockOrd++;\n\n        // NOTE: meaningless in the non-ord case\n        state.ord++;\n\n        //System.out.println(\"  return term=\" + fieldInfo.name + \":\" + term.utf8ToString() + \" \" + term + \" tbOrd=\" + state.termBlockOrd);\n        return term;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762"],"fd1bfe3cedf815c14939d170d53031c88eb5c444":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762"],"e4db7734414fc682d619339760cc21cc16cd0b1d":["b1add9ddc0005b07550d4350720aac22dc9886b3"],"4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762":["e4db7734414fc682d619339760cc21cc16cd0b1d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e4db7734414fc682d619339760cc21cc16cd0b1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b1add9ddc0005b07550d4350720aac22dc9886b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["fd1bfe3cedf815c14939d170d53031c88eb5c444","e4db7734414fc682d619339760cc21cc16cd0b1d"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"fd1bfe3cedf815c14939d170d53031c88eb5c444":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":[],"e4db7734414fc682d619339760cc21cc16cd0b1d":["4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762","29ef99d61cda9641b6250bf9567329a6e65f901d","bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"4fd64b6aa64934b0e35d9ec3e6c5a5c60ffc1762":["60ba444201d2570214b6fcf1d15600dc1a01f548","f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fd1bfe3cedf815c14939d170d53031c88eb5c444","29ef99d61cda9641b6250bf9567329a6e65f901d","b1add9ddc0005b07550d4350720aac22dc9886b3"],"b1add9ddc0005b07550d4350720aac22dc9886b3":["e4db7734414fc682d619339760cc21cc16cd0b1d"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}