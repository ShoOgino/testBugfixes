{"path":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","commits":[{"id":"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7","date":1309190785,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","pathOld":"/dev/null","sourceNew":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.bits == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","pathOld":"/dev/null","sourceNew":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.bits == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","sourceNew":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.liveDocs == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","sourceOld":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.bits == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","sourceNew":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.liveDocs == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","sourceOld":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.bits == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","pathOld":"/dev/null","sourceNew":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.liveDocs == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85eb75e0c0203e44dcf686f35876cf6080f3a671","date":1317221550,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/values/IntsImpl.IntsWriter#merge(MergeState).mjava","sourceNew":null,"sourceOld":"    // TODO how can we improve VAR_INT mergeing here without violating compression?\n    @Override\n    protected void merge(MergeState state) throws IOException {\n      merging = true;\n      if (typeOrd != PACKED) {\n        initDataOut(typeOrd); // init datOut since we merge directly\n        if (state.liveDocs == null && state.reader instanceof IntsReader) {\n          // no deleted docs - try bulk copy\n          final IntsReader reader = (IntsReader) state.reader;\n          if (reader.type == typeOrd) {\n            final int docBase = state.docBase;\n            if (docBase - lastDocId > 1) {\n              // fill with default values\n              lastDocId += fillDefault(datOut, docBase - lastDocId - 1);\n            }\n            lastDocId += reader.transferTo(datOut);\n            return;\n          }\n        }\n      }\n      super.merge(state);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"85eb75e0c0203e44dcf686f35876cf6080f3a671":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2553b00f699380c64959ccb27991289aae87be2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2553b00f699380c64959ccb27991289aae87be2e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["85eb75e0c0203e44dcf686f35876cf6080f3a671"]},"commit2Childs":{"5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","2553b00f699380c64959ccb27991289aae87be2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5f709d06503a0d7b88fbc7fe89cdc51caadfdaa7","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"85eb75e0c0203e44dcf686f35876cf6080f3a671":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["85eb75e0c0203e44dcf686f35876cf6080f3a671","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"2553b00f699380c64959ccb27991289aae87be2e":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}