{"path":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","commits":[{"id":"5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02","date":1243677645,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","pathOld":"/dev/null","sourceNew":"    /** IndexInput methods */\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n        do {\n          int i = file.read(b, offset+total, len-total);\n          if (i == -1)\n            throw new IOException(\"read past EOF\");\n          file.position += i;\n          total += i;\n        } while (total < len);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["37cdff042fc21a4f3d9c437c1022deac5d3bab72"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37cdff042fc21a4f3d9c437c1022deac5d3bab72","date":1247767655,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","pathOld":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","sourceNew":"    /** IndexInput methods */\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n\n        try {\n          do {\n            final int readLength;\n            if (total + chunkSize > len) {\n              readLength = len - total;\n            } else {\n              // LUCENE-1566 - work around JVM Bug by breaking very large reads into chunks\n              readLength = chunkSize;\n            }\n            final int i = file.read(b, offset + total, readLength);\n            if (i == -1) {\n              throw new IOException(\"read past EOF\");\n            }\n            file.position += i;\n            total += i;\n          } while (total < len);\n        } catch (OutOfMemoryError e) {\n          // propagate OOM up and add a hint for 32bit VM Users hitting the bug\n          // with a large chunk size in the fast path.\n          final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\n              \"OutOfMemoryError likely caused by the Sun VM Bug described in \"\n              + \"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize \"\n              + \"with a a value smaller than the current chunks size (\" + chunkSize + \")\");\n          outOfMemoryError.initCause(e);\n          throw outOfMemoryError;\n        }\n      }\n    }\n\n","sourceOld":"    /** IndexInput methods */\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n        do {\n          int i = file.read(b, offset+total, len-total);\n          if (i == -1)\n            throw new IOException(\"read past EOF\");\n          file.position += i;\n          total += i;\n        } while (total < len);\n      }\n    }\n\n","bugFix":["5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02"],"bugIntro":["462dfb1d8690f192817503773f5b8b94a702246a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","pathOld":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","sourceNew":"    /** IndexInput methods */\n    @Override\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n\n        try {\n          do {\n            final int readLength;\n            if (total + chunkSize > len) {\n              readLength = len - total;\n            } else {\n              // LUCENE-1566 - work around JVM Bug by breaking very large reads into chunks\n              readLength = chunkSize;\n            }\n            final int i = file.read(b, offset + total, readLength);\n            if (i == -1) {\n              throw new IOException(\"read past EOF\");\n            }\n            file.position += i;\n            total += i;\n          } while (total < len);\n        } catch (OutOfMemoryError e) {\n          // propagate OOM up and add a hint for 32bit VM Users hitting the bug\n          // with a large chunk size in the fast path.\n          final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\n              \"OutOfMemoryError likely caused by the Sun VM Bug described in \"\n              + \"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize \"\n              + \"with a a value smaller than the current chunks size (\" + chunkSize + \")\");\n          outOfMemoryError.initCause(e);\n          throw outOfMemoryError;\n        }\n      }\n    }\n\n","sourceOld":"    /** IndexInput methods */\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n\n        try {\n          do {\n            final int readLength;\n            if (total + chunkSize > len) {\n              readLength = len - total;\n            } else {\n              // LUCENE-1566 - work around JVM Bug by breaking very large reads into chunks\n              readLength = chunkSize;\n            }\n            final int i = file.read(b, offset + total, readLength);\n            if (i == -1) {\n              throw new IOException(\"read past EOF\");\n            }\n            file.position += i;\n            total += i;\n          } while (total < len);\n        } catch (OutOfMemoryError e) {\n          // propagate OOM up and add a hint for 32bit VM Users hitting the bug\n          // with a large chunk size in the fast path.\n          final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\n              \"OutOfMemoryError likely caused by the Sun VM Bug described in \"\n              + \"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize \"\n              + \"with a a value smaller than the current chunks size (\" + chunkSize + \")\");\n          outOfMemoryError.initCause(e);\n          throw outOfMemoryError;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","pathOld":"src/java/org/apache/lucene/store/SimpleFSDirectory.SimpleFSIndexInput#readInternal(byte[],int,int).mjava","sourceNew":"    /** IndexInput methods */\n    @Override\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n\n        try {\n          do {\n            final int readLength;\n            if (total + chunkSize > len) {\n              readLength = len - total;\n            } else {\n              // LUCENE-1566 - work around JVM Bug by breaking very large reads into chunks\n              readLength = chunkSize;\n            }\n            final int i = file.read(b, offset + total, readLength);\n            if (i == -1) {\n              throw new IOException(\"read past EOF\");\n            }\n            file.position += i;\n            total += i;\n          } while (total < len);\n        } catch (OutOfMemoryError e) {\n          // propagate OOM up and add a hint for 32bit VM Users hitting the bug\n          // with a large chunk size in the fast path.\n          final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\n              \"OutOfMemoryError likely caused by the Sun VM Bug described in \"\n              + \"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize \"\n              + \"with a a value smaller than the current chunks size (\" + chunkSize + \")\");\n          outOfMemoryError.initCause(e);\n          throw outOfMemoryError;\n        }\n      }\n    }\n\n","sourceOld":"    /** IndexInput methods */\n    @Override\n    protected void readInternal(byte[] b, int offset, int len)\n         throws IOException {\n      synchronized (file) {\n        long position = getFilePointer();\n        if (position != file.position) {\n          file.seek(position);\n          file.position = position;\n        }\n        int total = 0;\n\n        try {\n          do {\n            final int readLength;\n            if (total + chunkSize > len) {\n              readLength = len - total;\n            } else {\n              // LUCENE-1566 - work around JVM Bug by breaking very large reads into chunks\n              readLength = chunkSize;\n            }\n            final int i = file.read(b, offset + total, readLength);\n            if (i == -1) {\n              throw new IOException(\"read past EOF\");\n            }\n            file.position += i;\n            total += i;\n          } while (total < len);\n        } catch (OutOfMemoryError e) {\n          // propagate OOM up and add a hint for 32bit VM Users hitting the bug\n          // with a large chunk size in the fast path.\n          final OutOfMemoryError outOfMemoryError = new OutOfMemoryError(\n              \"OutOfMemoryError likely caused by the Sun VM Bug described in \"\n              + \"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize \"\n              + \"with a a value smaller than the current chunks size (\" + chunkSize + \")\");\n          outOfMemoryError.initCause(e);\n          throw outOfMemoryError;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"8a9e385641d717e641408d8fbbc62be8fc766357":["37cdff042fc21a4f3d9c437c1022deac5d3bab72"],"5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"37cdff042fc21a4f3d9c437c1022deac5d3bab72":["5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8a9e385641d717e641408d8fbbc62be8fc766357"]},"commit2Childs":{"8a9e385641d717e641408d8fbbc62be8fc766357":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02":["37cdff042fc21a4f3d9c437c1022deac5d3bab72"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5309ea37b2a7ec9c5f21c9eeacc9d9fb808cdb02"],"37cdff042fc21a4f3d9c437c1022deac5d3bab72":["8a9e385641d717e641408d8fbbc62be8fc766357"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}