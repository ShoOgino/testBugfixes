{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLatitudeQuantization().mjava","commits":[{"id":"bd6e28813bd3665a7c29cc07d0f32db701300168","date":1459966694,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLatitudeQuantization().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -90.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LATITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLatitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLatitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LATITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLatitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLatitudeQuantization().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -90.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LATITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLatitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLatitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LATITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLatitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","date":1460056040,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoEncodingUtils#testLatitudeQuantization().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLatitudeQuantization().mjava","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    final double LATITUDE_DECODE = 180.0D/(0x1L<<32);\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = MIN_LAT_INCL + (encoded - (long)Integer.MIN_VALUE) * LATITUDE_DECODE;\n      double decoded = decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encodeLatitude(decoded));\n      assertEquals(encoded, encodeLatitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LATITUDE_DECODE;\n        assertEquals(max, decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, encodeLatitude(max));\n        assertEquals(encoded+1, encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   encodeLatitude(minEdge));\n        assertEquals(encoded+1, encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   encodeLatitude(maxEdge));\n        assertEquals(encoded+1, encodeLatitudeCeil(maxEdge));\n\n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -90.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LATITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLatitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLatitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LATITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLatitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09f15823cf5eb6e807005579e875e117d8598f95","date":1460066385,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoEncodingUtils#testLatitudeQuantization().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLatitudeQuantization().mjava","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    final double LATITUDE_DECODE = 180.0D/(0x1L<<32);\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = MIN_LAT_INCL + (encoded - (long)Integer.MIN_VALUE) * LATITUDE_DECODE;\n      double decoded = decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encodeLatitude(decoded));\n      assertEquals(encoded, encodeLatitudeCeil(decoded));\n      // test within the range\n      if (encoded != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LATITUDE_DECODE;\n        assertEquals(max, decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, encodeLatitude(max));\n        assertEquals(encoded+1, encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   encodeLatitude(minEdge));\n        assertEquals(encoded+1, encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   encodeLatitude(maxEdge));\n        assertEquals(encoded+1, encodeLatitudeCeil(maxEdge));\n\n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -90 and increase by LATITUDE_DECODE for each integer.\n   * check edge cases within the double range and random doubles within the range too.\n   */\n  public void testLatitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -90.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LATITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLatitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLatitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLatitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LATITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLatitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLatitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLatitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLatitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLatitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b6284684320a9808c41a5e43de958b2da22f89bd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bd6e28813bd3665a7c29cc07d0f32db701300168"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd6e28813bd3665a7c29cc07d0f32db701300168":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["b6284684320a9808c41a5e43de958b2da22f89bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09f15823cf5eb6e807005579e875e117d8598f95"],"09f15823cf5eb6e807005579e875e117d8598f95":["b6284684320a9808c41a5e43de958b2da22f89bd","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"]},"commit2Childs":{"b6284684320a9808c41a5e43de958b2da22f89bd":["ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","09f15823cf5eb6e807005579e875e117d8598f95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b6284684320a9808c41a5e43de958b2da22f89bd","bd6e28813bd3665a7c29cc07d0f32db701300168"],"bd6e28813bd3665a7c29cc07d0f32db701300168":["b6284684320a9808c41a5e43de958b2da22f89bd"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["09f15823cf5eb6e807005579e875e117d8598f95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"09f15823cf5eb6e807005579e875e117d8598f95":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}