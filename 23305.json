{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonRangeFacets#doRangeOtherWhitebox(Client).mjava","commits":[{"id":"a067727e528e9edadcd1704b7a3a10912e5d95c1","date":1584973258,"type":1,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonRangeFacets#doRangeOtherWhitebox(Client).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacets#testRangeOtherWhitebox().mjava","sourceNew":"  /**\n   * whitebox sanity checks that a shard request range facet that returns \"between\" or \"after\"\n   * will cause the correct \"actual_end\" to be returned\n   */\n  private void doRangeOtherWhitebox(Client client) throws Exception {\n    indexSimple(client);\n\n    // false is default, but randomly check explicit false as well\n    final String nohardend = random().nextBoolean() ? \"\" : \" hardend:false, \";\n\n    { // first check some \"phase #1\" requests\n\n      final SolrParams p = params(\"q\", \"*:*\", \"rows\", \"0\", \"isShard\", \"true\", \"distrib\", \"false\",\n          \"_facet_\", \"{}\", \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS);\n      final String basic_opts = \"type:range, field:num_d, start:-5, end:10, gap:7, \";\n      final String buckets = \"buckets:[ {val:-5.0,count:1}, {val:2.0,count:2}, {val:9.0,count:1} ], \";\n\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \" other:before}}\")\n          , \"facets=={count:6, f:{\" + buckets\n              // before doesn't need actual_end\n              + \"   before:{count:1}\"\n              + \"} }\"\n      );\n      client.testJQ(params(p, \"json.facet\", \"{f:{\" + basic_opts + nohardend + \"other:after}}\")\n          , \"facets=={count:6, f:{\" + buckets\n              + \"   after:{count:0}, _actual_end:'16.0'\"\n              + \"} }\"\n      );\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \"other:between}}\")\n          , \"facets=={count:6, f:{\" + buckets\n              + \"   between:{count:4}, _actual_end:'16.0'\"\n              + \"} }\"\n      );\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \"other:all}}\")\n          , \"facets=={count:6, f:{\" + buckets\n              + \"   before:{count:1},\"\n              + \"   after:{count:0},\"\n              + \"   between:{count:4},\"\n              + \"   _actual_end:'16.0'\"\n              + \"} }\"\n      );\n      // with hardend:true, not only do the buckets change, but actual_end should not need to be returned\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + \" hardend:true, other:after}}\")\n          , \"facets=={count:6, f:{\"\n              + \"   buckets:[ {val:-5.0,count:1}, {val:2.0,count:2}, {val:9.0,count:0} ], \"\n              + \"   after:{count:1}\"\n              + \"} }\"\n      );\n    }\n\n    { // now check some \"phase #2\" requests with refinement buckets already specified\n\n      final String facet\n          = \"{ top:{ type:range, field:num_i, start:-5, end:5, gap:7,\" + nohardend\n          + \"        other:all, facet:{ x:{ type:terms, field:cat_s, limit:1, refine:true } } } }\";\n\n      // the behavior should be the same, regardless of wether we pass actual_end to the shards\n      // because in a \"mixed mode\" rolling update, the shards should be smart enough to re-compute if\n      // the merging node is running an older version that doesn't send it\n      for (String actual_end : Arrays.asList(\", _actual_end:'9'\", \"\")) {\n        client.testJQ(params(\"q\", \"*:*\", \"rows\", \"0\", \"isShard\", \"true\", \"distrib\", \"false\",\n            \"shards.purpose\", \"\"+FacetModule.PURPOSE_REFINE_JSON_FACETS,\n            \"json.facet\", facet,\n            \"_facet_\", \"{ refine: { top: { between:{ x:{ _l:[B] } }\" + actual_end + \"} } }\")\n            , \"facets=={top:{ buckets:[], between:{x:{buckets:[{val:B,count:3}] }} } }\");\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * whitebox sanity checks that a shard request range facet that returns \"between\" or \"after\"\n   * will cause the correct \"actual_end\" to be returned\n   */\n  public void testRangeOtherWhitebox() throws Exception {\n    Client client = Client.localClient();\n    indexSimple(client);\n\n    // false is default, but randomly check explicit false as well\n    final String nohardend = random().nextBoolean() ? \"\" : \" hardend:false, \";\n    \n    { // first check some \"phase #1\" requests\n      \n      final SolrParams p = params(\"q\", \"*:*\", \"rows\", \"0\", \"isShard\", \"true\", \"distrib\", \"false\",\n                                   \"_facet_\", \"{}\", \"shards.purpose\", \"\"+FacetModule.PURPOSE_GET_JSON_FACETS);\n      final String basic_opts = \"type:range, field:num_d, start:-5, end:10, gap:7, \";\n      final String buckets = \"buckets:[ {val:-5.0,count:1}, {val:2.0,count:2}, {val:9.0,count:1} ], \";\n      \n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \" other:before}}\")\n                    , \"facets=={count:6, f:{\" + buckets\n                    // before doesn't need actual_end\n                    + \"   before:{count:1}\"\n                    + \"} }\"\n                    );\n      client.testJQ(params(p, \"json.facet\", \"{f:{\" + basic_opts + nohardend + \"other:after}}\")\n                    , \"facets=={count:6, f:{\" + buckets\n                    + \"   after:{count:0}, _actual_end:'16.0'\"\n                    + \"} }\"\n                    );\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \"other:between}}\")\n                    , \"facets=={count:6, f:{\" + buckets\n                    + \"   between:{count:4}, _actual_end:'16.0'\"\n                    + \"} }\"\n                    );\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + nohardend + \"other:all}}\")\n                    , \"facets=={count:6, f:{\" + buckets\n                    + \"   before:{count:1},\"\n                    + \"   after:{count:0},\"\n                    + \"   between:{count:4},\"\n                    + \"   _actual_end:'16.0'\"\n                    + \"} }\"\n                    );\n      // with hardend:true, not only do the buckets change, but actual_end should not need to be returned\n      client.testJQ(params(p, \"json.facet\", \"{f:{ \" + basic_opts + \" hardend:true, other:after}}\")\n                    , \"facets=={count:6, f:{\"\n                    + \"   buckets:[ {val:-5.0,count:1}, {val:2.0,count:2}, {val:9.0,count:0} ], \"\n                    + \"   after:{count:1}\"\n                    + \"} }\"\n                    );\n    }\n\n    { // now check some \"phase #2\" requests with refinement buckets already specified\n\n      final String facet\n        = \"{ top:{ type:range, field:num_i, start:-5, end:5, gap:7,\" + nohardend\n        + \"        other:all, facet:{ x:{ type:terms, field:cat_s, limit:1, refine:true } } } }\";\n\n      // the behavior should be the same, regardless of wether we pass actual_end to the shards\n      // because in a \"mixed mode\" rolling update, the shards should be smart enough to re-compute if\n      // the merging node is running an older version that doesn't send it\n      for (String actual_end : Arrays.asList(\", _actual_end:'9'\", \"\")) {\n        client.testJQ(params(\"q\", \"*:*\", \"rows\", \"0\", \"isShard\", \"true\", \"distrib\", \"false\",\n                             \"shards.purpose\", \"\"+FacetModule.PURPOSE_REFINE_JSON_FACETS,\n                             \"json.facet\", facet,\n                             \"_facet_\", \"{ refine: { top: { between:{ x:{ _l:[B] } }\" + actual_end + \"} } }\")\n                      , \"facets=={top:{ buckets:[], between:{x:{buckets:[{val:B,count:3}] }} } }\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a067727e528e9edadcd1704b7a3a10912e5d95c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a067727e528e9edadcd1704b7a3a10912e5d95c1"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a067727e528e9edadcd1704b7a3a10912e5d95c1"],"a067727e528e9edadcd1704b7a3a10912e5d95c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}