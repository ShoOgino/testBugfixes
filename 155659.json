{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#testMergeHierarchies().mjava","commits":[{"id":"ff6a0dc6ca67172f353dbc6b826e324f84d378ef","date":1369831625,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#testMergeHierarchies().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMergeHierarchies() throws Exception {\n    Directory indexDir = new RAMDirectory(), taxoDir = new RAMDirectory();\n    initIndex(indexDir, taxoDir);\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    \n    String[] exp = new String[] { \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" } }, null);\n    \n    // two dimensions\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n\", \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" }, new String[] { \"A\" } }, null);\n    \n    // both parent and child are OR'd\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // both parent and child are OR'd (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // same DD twice\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2011\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2011\" }}, null);\n    \n    // Date/2010/April not in top-2 of Date/2010\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/April\", \"Date/2011\" }}, null);\n    \n    // missing ancestors\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (-1)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // missing ancestors (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // non-hierarchical dimension with both parent and child\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A/3\" }}, null);\n    \n    // non-hierarchical dimension with same request but different numResults\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n  2 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A\" }}, new int[] { 2, 4 });\n    \n    IOUtils.close(indexReader, taxoReader);\n    \n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca39562b2d7687143fdb601d5de1b8f7b778f1db","date":1385299806,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#testMergeHierarchies().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testMergeHierarchies() throws Exception {\n    Directory indexDir = new RAMDirectory(), taxoDir = new RAMDirectory();\n    initIndex(indexDir, taxoDir);\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    \n    String[] exp = new String[] { \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" } }, null);\n    \n    // two dimensions\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n\", \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" }, new String[] { \"A\" } }, null);\n    \n    // both parent and child are OR'd\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // both parent and child are OR'd (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // same DD twice\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2011\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2011\" }}, null);\n    \n    // Date/2010/April not in top-2 of Date/2010\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/April\", \"Date/2011\" }}, null);\n    \n    // missing ancestors\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (-1)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // missing ancestors (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // non-hierarchical dimension with both parent and child\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A/3\" }}, null);\n    \n    // non-hierarchical dimension with same request but different numResults\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n  2 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A\" }}, new int[] { 2, 4 });\n    \n    IOUtils.close(indexReader, taxoReader);\n    \n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#testMergeHierarchies().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testMergeHierarchies() throws Exception {\n    Directory indexDir = new RAMDirectory(), taxoDir = new RAMDirectory();\n    initIndex(indexDir, taxoDir);\n    \n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n    IndexSearcher searcher = new IndexSearcher(indexReader);\n    \n    String[] exp = new String[] { \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" } }, null);\n    \n    // two dimensions\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n\", \"Date (0)\\n  2010 (4)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date\" }, new String[] { \"A\" } }, null);\n    \n    // both parent and child are OR'd\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // both parent and child are OR'd (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/March/23\" }}, null);\n    \n    // same DD twice\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010\", \"Date/2011\" }}, null);\n    \n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2011\" }}, null);\n    \n    // Date/2010/April not in top-2 of Date/2010\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n      23 (1)\\n      12 (1)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    February (2)\\n    January (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2010/March\", \"Date/2010/April\", \"Date/2011\" }}, null);\n    \n    // missing ancestors\n    exp = new String[] { \"Date (-1)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (-1)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, false, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // missing ancestors (fill counts)\n    exp = new String[] { \"Date (0)\\n  2010 (4)\\n    March (2)\\n    May (1)\\n    April (1)\\n      17 (1)\\n  2011 (3)\\n    January (1)\\n      1 (1)\\n\" };\n    searchIndex(taxoReader, searcher, true, exp, new String[][] { new String[] { \"Date/2011/January/1\", \"Date/2010/April\" }}, null);\n    \n    // non-hierarchical dimension with both parent and child\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A/3\" }}, null);\n    \n    // non-hierarchical dimension with same request but different numResults\n    exp = new String[] { \"A (0)\\n  1 (5)\\n  4 (2)\\n  3 (2)\\n  2 (2)\\n\" };\n    searchIndex(taxoReader, searcher, INFOSTREAM, exp, new String[][] { new String[] { \"A\", \"A\" }}, new int[] { 2, 4 });\n    \n    IOUtils.close(indexReader, taxoReader);\n    \n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef","ca39562b2d7687143fdb601d5de1b8f7b778f1db"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"]},"commit2Childs":{"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["3cc728b07df73b197e6d940d27f9b08b63918f13","ca39562b2d7687143fdb601d5de1b8f7b778f1db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}