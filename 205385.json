{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","sourceNew":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","sourceNew":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1437f4dfa790420339a16dbe1654d19e77e7bdeb","date":1520247209,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy#recursiveTraverseAndPrune(Cell,Shape,int,List[Cell]).mjava","sourceNew":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n\n    if (!(cell instanceof CellCanPrune)) {\n      //Cannot prune so return false\n      return false;\n    }\n\n    //can we prune?\n    if (leaves == ((CellCanPrune)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n\n    if (cell.getLevel() == detailLevel) {\n      cell.setLeaf();//FYI might already be a leaf\n    }\n    if (cell.isLeaf()) {\n      result.add(cell);\n      return true;\n    }\n    if (cell.getLevel() != 0)\n      result.add(cell);\n\n    int leaves = 0;\n    CellIterator subCells = cell.getNextLevelCells(shape);\n    while (subCells.hasNext()) {\n      Cell subCell = subCells.next();\n      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))\n        leaves++;\n    }\n    //can we prune?\n    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {\n      //Optimization: substitute the parent as a leaf instead of adding all\n      // children as leaves\n\n      //remove the leaves\n      do {\n        result.remove(result.size() - 1);//remove last\n      } while (--leaves > 0);\n      //add cell as the leaf\n      cell.setLeaf();\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1437f4dfa790420339a16dbe1654d19e77e7bdeb":["af2638813028b254a88b418ebeafb541afb49653"],"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1437f4dfa790420339a16dbe1654d19e77e7bdeb"]},"commit2Childs":{"1437f4dfa790420339a16dbe1654d19e77e7bdeb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"af2638813028b254a88b418ebeafb541afb49653":["1437f4dfa790420339a16dbe1654d19e77e7bdeb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}