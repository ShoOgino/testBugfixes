{"path":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","commits":[{"id":"04eed55b1981172dbb35e0ae4f9ad47558203ace","date":1283979393,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    Random rand = newRandom();\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory(rand);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(rand, 1, 77777)];\n      final int size = _TestUtil.nextInt(rand, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (rand.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(rand, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (rand.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(rand, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    Random rand = newRandom();\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory(rand);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(rand, 1, 77777)];\n      final int size = _TestUtil.nextInt(rand, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (rand.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(rand, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (rand.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(rand, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f83af14a2a8131b14d7aee6274c740334e0363d3","date":1307579822,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", IOContext.DEFAULT);\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", IOContext.DEFAULT);\n\n      out = dir.createOutput(\"test2\", IOContext.DEFAULT);\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", IOContext.DEFAULT);\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for (int iter = 0; iter < num; iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n      \n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", newIOContext(random));\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while (upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n      \n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n      \n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", newIOContext(random));\n      \n      out = dir.createOutput(\"test2\", newIOContext(random));\n      \n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n      \n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", newIOContext(random));\n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          in2.readBytes(bytes, 0, limit);\n          for (int byteIdx = 0; byteIdx < limit; byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n      \n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", IOContext.DEFAULT);\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", IOContext.DEFAULT);\n\n      out = dir.createOutput(\"test2\", IOContext.DEFAULT);\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", IOContext.DEFAULT);\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for (int iter = 0; iter < num; iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n      \n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", newIOContext(random));\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while (upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n      \n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n      \n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", newIOContext(random));\n      \n      out = dir.createOutput(\"test2\", newIOContext(random));\n      \n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n      \n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", newIOContext(random));\n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          in2.readBytes(bytes, 0, limit);\n          for (int byteIdx = 0; byteIdx < limit; byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n      \n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for (int iter = 0; iter < num; iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n      \n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", newIOContext(random));\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while (upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n      \n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n      \n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", newIOContext(random));\n      \n      out = dir.createOutput(\"test2\", newIOContext(random));\n      \n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n      \n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", newIOContext(random));\n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          in2.readBytes(bytes, 0, limit);\n          for (int byteIdx = 0; byteIdx < limit; byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n      \n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for(int iter=0;iter<num;iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n\n      // make random file\n      IndexOutput out = dir.createOutput(\"test\");\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while(upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n\n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n\n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\");\n\n      out = dir.createOutput(\"test2\");\n\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n\n      // verify\n      IndexInput in2 = dir.openInput(\"test2\");\n      upto = 0;\n      while(upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(_TestUtil.nextInt(random, 1, bytes.length), size-upto);\n          in2.readBytes(bytes, 0, limit);\n          for(int byteIdx=0;byteIdx<limit;byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n\n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestCopyBytes#testCopyBytes().mjava","sourceNew":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for (int iter = 0; iter < num; iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n      \n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", newIOContext(random));\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while (upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n      \n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n      \n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", newIOContext(random));\n      \n      out = dir.createOutput(\"test2\", newIOContext(random));\n      \n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n      \n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", newIOContext(random));\n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          in2.readBytes(bytes, 0, limit);\n          for (int byteIdx = 0; byteIdx < limit; byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n      \n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testCopyBytes() throws Exception {\n    int num = atLeast(10);\n    for (int iter = 0; iter < num; iter++) {\n      Directory dir = newDirectory();\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" dir=\" + dir);\n      }\n      \n      // make random file\n      IndexOutput out = dir.createOutput(\"test\", newIOContext(random));\n      byte[] bytes = new byte[_TestUtil.nextInt(random, 1, 77777)];\n      final int size = _TestUtil.nextInt(random, 1, 1777777);\n      int upto = 0;\n      int byteUpto = 0;\n      while (upto < size) {\n        bytes[byteUpto++] = value(upto);\n        upto++;\n        if (byteUpto == bytes.length) {\n          out.writeBytes(bytes, 0, bytes.length);\n          byteUpto = 0;\n        }\n      }\n      \n      out.writeBytes(bytes, 0, byteUpto);\n      assertEquals(size, out.getFilePointer());\n      out.close();\n      assertEquals(size, dir.fileLength(\"test\"));\n      \n      // copy from test -> test2\n      final IndexInput in = dir.openInput(\"test\", newIOContext(random));\n      \n      out = dir.createOutput(\"test2\", newIOContext(random));\n      \n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          out.writeByte(in.readByte());\n          upto++;\n        } else {\n          final int chunk = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          out.copyBytes(in, chunk);\n          upto += chunk;\n        }\n      }\n      assertEquals(size, upto);\n      out.close();\n      in.close();\n      \n      // verify\n      IndexInput in2 = dir.openInput(\"test2\", newIOContext(random));\n      upto = 0;\n      while (upto < size) {\n        if (random.nextBoolean()) {\n          final byte v = in2.readByte();\n          assertEquals(value(upto), v);\n          upto++;\n        } else {\n          final int limit = Math.min(\n              _TestUtil.nextInt(random, 1, bytes.length), size - upto);\n          in2.readBytes(bytes, 0, limit);\n          for (int byteIdx = 0; byteIdx < limit; byteIdx++) {\n            assertEquals(value(upto), bytes[byteIdx]);\n            upto++;\n          }\n        }\n      }\n      in2.close();\n      \n      dir.deleteFile(\"test\");\n      dir.deleteFile(\"test2\");\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["1f653cfcf159baeaafe5d01682a911e95bba4012","f83af14a2a8131b14d7aee6274c740334e0363d3"],"f83af14a2a8131b14d7aee6274c740334e0363d3":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1f653cfcf159baeaafe5d01682a911e95bba4012"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["04eed55b1981172dbb35e0ae4f9ad47558203ace"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"04eed55b1981172dbb35e0ae4f9ad47558203ace":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["1f653cfcf159baeaafe5d01682a911e95bba4012","f83af14a2a8131b14d7aee6274c740334e0363d3"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["f83af14a2a8131b14d7aee6274c740334e0363d3","b6f9be74ca7baaef11857ad002cad40419979516"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"f83af14a2a8131b14d7aee6274c740334e0363d3":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"1f653cfcf159baeaafe5d01682a911e95bba4012":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","f83af14a2a8131b14d7aee6274c740334e0363d3","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","04eed55b1981172dbb35e0ae4f9ad47558203ace"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"04eed55b1981172dbb35e0ae4f9ad47558203ace":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}