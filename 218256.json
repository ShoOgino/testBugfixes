{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.getNumSubResults());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.getSubResults()) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.getValue(), prevCount>=frn.getValue());\n          prevCount = (int) frn.getValue();\n          String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n          if (VERBOSE) {\n            System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.getNumSubResults(), n>=topResNode.getNumSubResults());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.getSubResults()) {\n            String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n            if (VERBOSE) {\n              System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.getNumSubResults());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.getSubResults()) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.getValue(), prevCount>=frn.getValue());\n          prevCount = (int) frn.getValue();\n          String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n          if (VERBOSE) {\n            System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.getNumSubResults(), n>=topResNode.getNumSubResults());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.getSubResults()) {\n            String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n            if (VERBOSE) {\n              System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"811cdb4a80352766eb0c762e48972707a924e5cd","date":1358767313,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.getNumSubResults());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.getSubResults()) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.getValue(), prevCount>=frn.getValue());\n          prevCount = (int) frn.getValue();\n          String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n          if (VERBOSE) {\n            System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.getNumSubResults(), n>=topResNode.getNumSubResults());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.getSubResults()) {\n            String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n            if (VERBOSE) {\n              System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07155cdd910937cdf6877e48884d5782845c8b8b","date":1358796205,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.getNumSubResults());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.getSubResults()) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.getValue(), prevCount>=frn.getValue());\n          prevCount = (int) frn.getValue();\n          String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n          if (VERBOSE) {\n            System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.getNumSubResults(), n>=topResNode.getNumSubResults());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.getSubResults()) {\n            String key = k+\"--\"+frn.getLabel()+\"==\"+frn.getValue();\n            if (VERBOSE) {\n              System.out.println(frn.getLabel() + \" - \" + frn.getValue() + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"239f79ed06f0979cfe1911ec5fba32b94fda43c1","date":1359553898,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      FacetIndexingParams fip = getFacetIndexingParams(partitionSize);\n      initIndex(fip);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(fip, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(fip, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(fip, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(fip, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      FacetIndexingParams fip = getFacetIndexingParams(partitionSize);\n      initIndex(fip);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(fip, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(fip, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(fip, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(fip, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      initIndex(partitionSize);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(partitionSize, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(partitionSize, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(partitionSize, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(partitionSize, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":null,"sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      FacetIndexingParams fip = getFacetIndexingParams(partitionSize);\n      initIndex(fip);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(fip, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(fip, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(fip, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(fip, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandlerRandom#testTopCountsOrder().mjava","sourceNew":null,"sourceOld":"  /**\n   * Test that indeed top results are returned, ordered same as all results \n   * also when some facets have the same counts.\n   */\n  @Test\n  public void testTopCountsOrder() throws Exception {\n    for (int partitionSize : partitionSizes) {\n      FacetIndexingParams fip = getFacetIndexingParams(partitionSize);\n      initIndex(fip);\n      \n      /*\n       * Try out faceted search in it's most basic form (no sampling nor complement\n       * that is). In this test lots (and lots..) of randomly generated data is\n       * being indexed, and later on an \"over-all\" faceted search is performed. The\n       * results are checked against the DF of each facet by itself\n       */\n      List<FacetResult> facetResults = countFacets(fip, 100000, false);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      /*\n       * Try out faceted search with complements. In this test lots (and lots..) of\n       * randomly generated data is being indexed, and later on, a \"beta\" faceted\n       * search is performed - retrieving ~90% of the documents so complements takes\n       * place in here. The results are checked against the a regular (a.k.a\n       * no-complement, no-sampling) faceted search with the same parameters.\n       */\n      facetResults = countFacets(fip, 100000, true);\n      assertCountsAndCardinality(facetCountsTruth(), facetResults);\n      \n      List<FacetResult> allFacetResults = countFacets(fip, 100000, false);\n      \n      HashMap<String,Integer> all = new HashMap<String,Integer>();\n      int maxNumNodes = 0;\n      int k = 0;\n      for (FacetResult fr : allFacetResults) {\n        FacetResultNode topResNode = fr.getFacetResultNode();\n        maxNumNodes = Math.max(maxNumNodes, topResNode.subResults.size());\n        int prevCount = Integer.MAX_VALUE;\n        int pos = 0;\n        for (FacetResultNode frn: topResNode.subResults) {\n          assertTrue(\"wrong counts order: prev=\"+prevCount+\" curr=\"+frn.value, prevCount>=frn.value);\n          prevCount = (int) frn.value;\n          String key = k+\"--\"+frn.label+\"==\"+frn.value;\n          if (VERBOSE) {\n            System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n          }\n          all.put(key, pos++); // will use this later to verify order of sub-results\n        }\n        k++;\n      }\n      \n      // verify that when asking for less results, they are always of highest counts\n      // also verify that the order is stable\n      for (int n=1; n<maxNumNodes; n++) {\n        if (VERBOSE) {\n          System.out.println(\"-------  verify for \"+n+\" top results\");\n        }\n        List<FacetResult> someResults = countFacets(fip, n, false);\n        k = 0;\n        for (FacetResult fr : someResults) {\n          FacetResultNode topResNode = fr.getFacetResultNode();\n          assertTrue(\"too many results: n=\"+n+\" but got \"+topResNode.subResults.size(), n>=topResNode.subResults.size());\n          int pos = 0;\n          for (FacetResultNode frn: topResNode.subResults) {\n            String key = k+\"--\"+frn.label+\"==\"+frn.value;\n            if (VERBOSE) {\n              System.out.println(frn.label + \" - \" + frn.value + \"  \"+key+\"  \"+pos);\n            }\n            Integer origPos = all.get(key);\n            assertNotNull(\"missing in all results: \"+frn,origPos);\n            assertEquals(\"wrong order of sub-results!\",pos++, origPos.intValue()); // verify order of sub-results\n          }\n          k++;\n        }\n      }\n      \n      closeAll(); // done with this partition\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"61d5f95d14e5b9b046998c51e16709a398c15226":["07155cdd910937cdf6877e48884d5782845c8b8b","239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["811cdb4a80352766eb0c762e48972707a924e5cd"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["239f79ed06f0979cfe1911ec5fba32b94fda43c1","d33e19a97046248623a7591aeaa6547233fd15e2"],"07155cdd910937cdf6877e48884d5782845c8b8b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","811cdb4a80352766eb0c762e48972707a924e5cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"811cdb4a80352766eb0c762e48972707a924e5cd":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["07155cdd910937cdf6877e48884d5782845c8b8b","811cdb4a80352766eb0c762e48972707a924e5cd"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["d33e19a97046248623a7591aeaa6547233fd15e2","61d5f95d14e5b9b046998c51e16709a398c15226","3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07155cdd910937cdf6877e48884d5782845c8b8b":["61d5f95d14e5b9b046998c51e16709a398c15226"],"811cdb4a80352766eb0c762e48972707a924e5cd":["239f79ed06f0979cfe1911ec5fba32b94fda43c1","07155cdd910937cdf6877e48884d5782845c8b8b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["61d5f95d14e5b9b046998c51e16709a398c15226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}