{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","commits":[{"id":"68acf69be1b41192ae2278afc452bb66f6349cba","date":1357657311,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"/dev/null","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      DocValues.Type type = infos.fieldInfo(fieldNumber).getDocValuesType();\n      if (DocValues.isNumber(type) || DocValues.isFloat(type)) {\n        numerics.put(fieldNumber, readNumericEntry(meta));\n      } else if (DocValues.isBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"binary entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n      } else if (DocValues.isSortedBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n        // sorted byte[]: read ords as a numeric dv field\n        if (meta.readVInt() != fieldNumber) {\n          throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n        }\n        ords.put(fieldNumber, readNumericEntry(meta));\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7a738ebbf9537051521dcc7e49f69208f91e2fc","date":1358194026,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/diskdv/DiskDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      DocValues.Type type = infos.fieldInfo(fieldNumber).getDocValuesType();\n      if (DocValues.isNumber(type) || DocValues.isFloat(type)) {\n        numerics.put(fieldNumber, readNumericEntry(meta));\n      } else if (DocValues.isBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"binary entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n      } else if (DocValues.isSortedBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n        // sorted byte[]: read ords as a numeric dv field\n        if (meta.readVInt() != fieldNumber) {\n          throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n        }\n        ords.put(fieldNumber, readNumericEntry(meta));\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      DocValues.Type type = infos.fieldInfo(fieldNumber).getDocValuesType();\n      if (DocValues.isNumber(type) || DocValues.isFloat(type)) {\n        numerics.put(fieldNumber, readNumericEntry(meta));\n      } else if (DocValues.isBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"binary entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n      } else if (DocValues.isSortedBytes(type)) {\n        BinaryEntry b = readBinaryEntry(meta);\n        binaries.put(fieldNumber, b);\n        if (b.minLength != b.maxLength) {\n          if (meta.readVInt() != fieldNumber) {\n            throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n          }\n          // variable length byte[]: read addresses as a numeric dv field\n          numerics.put(fieldNumber, readNumericEntry(meta));\n        }\n        // sorted byte[]: read ords as a numeric dv field\n        if (meta.readVInt() != fieldNumber) {\n          throw new CorruptIndexException(\"sorted entry for field: \" + fieldNumber + \" is corrupt\");\n        }\n        ords.put(fieldNumber, readNumericEntry(meta));\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96b29edfb831f9c0aeeca88ad2293b2a9cd529f6","date":1358196500,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleNormsProducer#readFields(IndexInput,FieldInfos).mjava","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      NumericEntry entry = new NumericEntry();\n      entry.offset = meta.readLong();\n      entry.tableized = meta.readByte() != 0;\n      numerics.put(fieldNumber, entry);\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      NumericEntry entry = new NumericEntry();\n      entry.offset = meta.readLong();\n      entry.tableized = meta.readByte() != 0;\n      numerics.put(fieldNumber, entry);\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b70b267afb5dd221d0389bd4ac1f148661fb827","date":1358203204,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      int fieldType = meta.readByte();\n      if (fieldType == Lucene41SimpleDocValuesConsumer.NUMBER) {\n        NumericEntry entry = new NumericEntry();\n        entry.offset = meta.readLong();\n        entry.tableized = meta.readByte() != 0;\n        numerics.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.BYTES) {\n        BinaryEntry entry = new BinaryEntry();\n        entry.offset = meta.readLong();\n        entry.numBytes = meta.readLong();\n        entry.minLength = meta.readVInt();\n        entry.maxLength = meta.readVInt();\n        binaries.put(fieldNumber, entry);\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      NumericEntry entry = new NumericEntry();\n      entry.offset = meta.readLong();\n      entry.tableized = meta.readByte() != 0;\n      numerics.put(fieldNumber, entry);\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f93c27491251c14ea21df71ebbf6feb9f891e6cb","date":1358211079,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      int fieldType = meta.readByte();\n      if (fieldType == Lucene41SimpleDocValuesConsumer.NUMBER) {\n        NumericEntry entry = new NumericEntry();\n        entry.offset = meta.readLong();\n        entry.tableized = meta.readByte() != 0;\n        numerics.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.BYTES) {\n        BinaryEntry entry = new BinaryEntry();\n        entry.offset = meta.readLong();\n        entry.numBytes = meta.readLong();\n        entry.minLength = meta.readVInt();\n        entry.maxLength = meta.readVInt();\n        binaries.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.FST) {\n        FSTEntry entry = new FSTEntry();\n        entry.offset = meta.readLong();\n        entry.numOrds = meta.readVInt();\n        fsts.put(fieldNumber, entry);\n      } else {\n        throw new CorruptIndexException(\"invalid entry type: \" + fieldType + \", input=\" + meta);\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      int fieldType = meta.readByte();\n      if (fieldType == Lucene41SimpleDocValuesConsumer.NUMBER) {\n        NumericEntry entry = new NumericEntry();\n        entry.offset = meta.readLong();\n        entry.tableized = meta.readByte() != 0;\n        numerics.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.BYTES) {\n        BinaryEntry entry = new BinaryEntry();\n        entry.offset = meta.readLong();\n        entry.numBytes = meta.readLong();\n        entry.minLength = meta.readVInt();\n        entry.maxLength = meta.readVInt();\n        binaries.put(fieldNumber, entry);\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","bugFix":null,"bugIntro":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d7bf953a8ab9ae7d92835bdf9cbe5a268448868f","date":1358522034,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41DocValuesProducer#readFields(IndexInput,FieldInfos).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesProducer#readFields(IndexInput,FieldInfos).mjava","sourceNew":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      int fieldType = meta.readByte();\n      if (fieldType == Lucene41DocValuesConsumer.NUMBER) {\n        NumericEntry entry = new NumericEntry();\n        entry.offset = meta.readLong();\n        entry.tableized = meta.readByte() != 0;\n        numerics.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41DocValuesConsumer.BYTES) {\n        BinaryEntry entry = new BinaryEntry();\n        entry.offset = meta.readLong();\n        entry.numBytes = meta.readLong();\n        entry.minLength = meta.readVInt();\n        entry.maxLength = meta.readVInt();\n        binaries.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41DocValuesConsumer.FST) {\n        FSTEntry entry = new FSTEntry();\n        entry.offset = meta.readLong();\n        entry.numOrds = meta.readVInt();\n        fsts.put(fieldNumber, entry);\n      } else {\n        throw new CorruptIndexException(\"invalid entry type: \" + fieldType + \", input=\" + meta);\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","sourceOld":"  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {\n    int fieldNumber = meta.readVInt();\n    while (fieldNumber != -1) {\n      int fieldType = meta.readByte();\n      if (fieldType == Lucene41SimpleDocValuesConsumer.NUMBER) {\n        NumericEntry entry = new NumericEntry();\n        entry.offset = meta.readLong();\n        entry.tableized = meta.readByte() != 0;\n        numerics.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.BYTES) {\n        BinaryEntry entry = new BinaryEntry();\n        entry.offset = meta.readLong();\n        entry.numBytes = meta.readLong();\n        entry.minLength = meta.readVInt();\n        entry.maxLength = meta.readVInt();\n        binaries.put(fieldNumber, entry);\n      } else if (fieldType == Lucene41SimpleDocValuesConsumer.FST) {\n        FSTEntry entry = new FSTEntry();\n        entry.offset = meta.readLong();\n        entry.numOrds = meta.readVInt();\n        fsts.put(fieldNumber, entry);\n      } else {\n        throw new CorruptIndexException(\"invalid entry type: \" + fieldType + \", input=\" + meta);\n      }\n      fieldNumber = meta.readVInt();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"68acf69be1b41192ae2278afc452bb66f6349cba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5b70b267afb5dd221d0389bd4ac1f148661fb827":["96b29edfb831f9c0aeeca88ad2293b2a9cd529f6"],"d7bf953a8ab9ae7d92835bdf9cbe5a268448868f":["f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["5b70b267afb5dd221d0389bd4ac1f148661fb827"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"96b29edfb831f9c0aeeca88ad2293b2a9cd529f6":["d7a738ebbf9537051521dcc7e49f69208f91e2fc"],"d7a738ebbf9537051521dcc7e49f69208f91e2fc":["68acf69be1b41192ae2278afc452bb66f6349cba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"68acf69be1b41192ae2278afc452bb66f6349cba":["d7a738ebbf9537051521dcc7e49f69208f91e2fc"],"5b70b267afb5dd221d0389bd4ac1f148661fb827":["f93c27491251c14ea21df71ebbf6feb9f891e6cb"],"d7bf953a8ab9ae7d92835bdf9cbe5a268448868f":[],"f93c27491251c14ea21df71ebbf6feb9f891e6cb":["d7bf953a8ab9ae7d92835bdf9cbe5a268448868f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68acf69be1b41192ae2278afc452bb66f6349cba","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"96b29edfb831f9c0aeeca88ad2293b2a9cd529f6":["5b70b267afb5dd221d0389bd4ac1f148661fb827"],"d7a738ebbf9537051521dcc7e49f69208f91e2fc":["96b29edfb831f9c0aeeca88ad2293b2a9cd529f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d7bf953a8ab9ae7d92835bdf9cbe5a268448868f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}