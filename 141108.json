{"path":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","commits":[{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(\"name\", collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["175a04d27a2b736171e7e51ca46a03b2aec094d4","5de0133a64f3e28d38cdf3f25f099bb70d48168a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(NAME, collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(\"name\", collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(NAME, collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(\"name\", collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(Utils.makeMap(NAME, collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(ZkNodeProps.makeMap(NAME, collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","bugFix":null,"bugIntro":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"175a04d27a2b736171e7e51ca46a03b2aec094d4","date":1452534768,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n    boolean lastSlice = false;\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        // TODO TODO TODO!!! if there are no replicas left for the slice, and the slice has no hash range, remove it\n        // if (newReplicas.size() == 0 && slice.getRange() == null) {\n        // if there are no replicas left for the slice remove it\n        if (newReplicas.size() == 0) {\n          slice = null;\n          lastSlice = true;\n        } else {\n          slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n        }\n      }\n\n      if (slice != null) {\n        newSlices.put(slice.getName(), slice);\n      }\n    }\n\n    if (lastSlice) {\n      // remove all empty pre allocated slices\n      for (Slice slice : coll.getSlices()) {\n        if (slice.getReplicas().size() == 0) {\n          newSlices.remove(slice.getName());\n        }\n      }\n    }\n\n    // if there are no slices left in the collection, remove it?\n    if (newSlices.size() == 0) {\n      return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,\n          new ZkNodeProps(Utils.makeMap(NAME, collection)));\n    } else {\n      return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n    }\n  }\n\n","bugFix":["b693a83132c9e45afcd564fd65a25b60ed80388b","24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5de0133a64f3e28d38cdf3f25f099bb70d48168a","date":1493749917,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties(),collection);\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator#removeReplica(ClusterState,ZkNodeProps).mjava","sourceNew":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties(),collection);\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","sourceOld":"  public ZkWriteCommand removeReplica(ClusterState clusterState, ZkNodeProps message) {\n    final String cnn = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n    final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n    final String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!checkCollectionKeyExistence(message)) return ZkStateWriter.NO_OP;\n\n    DocCollection coll = clusterState.getCollectionOrNull(collection);\n    if (coll == null) {\n      // make sure we delete the zk nodes for this collection just to be safe\n      return new ZkWriteCommand(collection, null);\n    }\n\n    Map<String, Slice> newSlices = new LinkedHashMap<>();\n\n    for (Slice slice : coll.getSlices()) {\n      Replica replica = slice.getReplica(cnn);\n      if (replica != null && (baseUrl == null || baseUrl.equals(replica.getBaseUrl()))) {\n        Map<String, Replica> newReplicas = slice.getReplicasCopy();\n        newReplicas.remove(cnn);\n        slice = new Slice(slice.getName(), newReplicas, slice.getProperties());\n      }\n      newSlices.put(slice.getName(), slice);\n    }\n\n    return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["5de0133a64f3e28d38cdf3f25f099bb70d48168a","6681d02f2302c363be938426e68f8dfd090cc1bf"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["175a04d27a2b736171e7e51ca46a03b2aec094d4","5de0133a64f3e28d38cdf3f25f099bb70d48168a"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a","1390137e395d2f07f9ba5b8c43d293befe84d563"],"175a04d27a2b736171e7e51ca46a03b2aec094d4":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"5de0133a64f3e28d38cdf3f25f099bb70d48168a":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["5de0133a64f3e28d38cdf3f25f099bb70d48168a"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","b693a83132c9e45afcd564fd65a25b60ed80388b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"175a04d27a2b736171e7e51ca46a03b2aec094d4":["e9017cf144952056066919f1ebc7897ff9bd71b1","5de0133a64f3e28d38cdf3f25f099bb70d48168a"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["175a04d27a2b736171e7e51ca46a03b2aec094d4"],"5de0133a64f3e28d38cdf3f25f099bb70d48168a":["d3aa683bba99315838c968fefedf3d74f44aa993","e9017cf144952056066919f1ebc7897ff9bd71b1","6681d02f2302c363be938426e68f8dfd090cc1bf"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","e9017cf144952056066919f1ebc7897ff9bd71b1","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}