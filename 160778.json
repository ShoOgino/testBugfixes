{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<InvertedFields> fields = new ArrayList<InvertedFields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final InvertedFields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final InvertedFieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(InvertedFields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<InvertedFields> fields = new ArrayList<InvertedFields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final InvertedFields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final InvertedFieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(InvertedFields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c95a819869502635864dac0a788f874787e3395b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderUtil.Slice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":["06584e6e98d592b34e1329b384182f368d2025e8"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c95a819869502635864dac0a788f874787e3395b","date":1341394787,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":["ccad4bab070f323ce610caa0040346d4a87213dc","06584e6e98d592b34e1329b384182f368d2025e8","e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws CorruptIndexException, IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final MergeState.IndexReaderAndLiveDocs r = mergeState.readers.get(readerIndex);\n      final Fields f = r.reader.fields();\n      final int maxDoc = r.reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55eeb2534cd53d2a985669829df942468ebf5314","date":1354409119,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private final void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    codec.postingsFormat().fieldsConsumer(segmentWriteState).write(mergedFields);\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    final FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState,\n                     new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                     slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<>();\n    final List<ReaderSlice> slices = new ArrayList<>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    codec.postingsFormat().fieldsConsumer(segmentWriteState).write(mergedFields);\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<Fields>();\n    final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    codec.postingsFormat().fieldsConsumer(segmentWriteState).write(mergedFields);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7afb64ff3a701f68b2689cafff6c5bdeb4f67f63","date":1398957288,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<>();\n    final List<ReaderSlice> slices = new ArrayList<>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.write(mergedFields);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<>();\n    final List<ReaderSlice> slices = new ArrayList<>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    codec.postingsFormat().fieldsConsumer(segmentWriteState).write(mergedFields);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22a2e66dfda83847e80095b8693c660742ab3e9c","date":1408628796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    \n    final List<Fields> fields = new ArrayList<>();\n    final List<ReaderSlice> slices = new ArrayList<>();\n\n    int docBase = 0;\n\n    for(int readerIndex=0;readerIndex<mergeState.readers.size();readerIndex++) {\n      final AtomicReader reader = mergeState.readers.get(readerIndex);\n      final Fields f = reader.fields();\n      final int maxDoc = reader.maxDoc();\n      if (f != null) {\n        slices.add(new ReaderSlice(docBase, maxDoc, readerIndex));\n        fields.add(f);\n      }\n      docBase += maxDoc;\n    }\n\n    Fields mergedFields = new MappedMultiFields(mergeState, \n                                                new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                                                slices.toArray(ReaderSlice.EMPTY_ARRAY)));\n\n    FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.write(mergedFields);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81f984bc3fef371bf2393a453ebd7835bcb0ee8d","date":1418246768,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    try (FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState)) {\n      consumer.merge(mergeState);\n    }\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState);\n    boolean success = false;\n    try {\n      consumer.merge(mergeState);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(consumer);\n      } else {\n        IOUtils.closeWhileHandlingException(consumer);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState,NormsProducer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeTerms(SegmentWriteState).mjava","sourceNew":"  private void mergeTerms(SegmentWriteState segmentWriteState, NormsProducer norms) throws IOException {\n    try (FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState)) {\n      consumer.merge(mergeState, norms);\n    }\n  }\n\n","sourceOld":"  private void mergeTerms(SegmentWriteState segmentWriteState) throws IOException {\n    try (FieldsConsumer consumer = codec.postingsFormat().fieldsConsumer(segmentWriteState)) {\n      consumer.merge(mergeState);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c95a819869502635864dac0a788f874787e3395b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"81f984bc3fef371bf2393a453ebd7835bcb0ee8d":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"55eeb2534cd53d2a985669829df942468ebf5314":["c95a819869502635864dac0a788f874787e3395b"],"7afb64ff3a701f68b2689cafff6c5bdeb4f67f63":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["c95a819869502635864dac0a788f874787e3395b","55eeb2534cd53d2a985669829df942468ebf5314"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","c95a819869502635864dac0a788f874787e3395b"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"622a708571e534680618b3c5e0c28ac539a47776":["81f984bc3fef371bf2393a453ebd7835bcb0ee8d"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["7afb64ff3a701f68b2689cafff6c5bdeb4f67f63"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["622a708571e534680618b3c5e0c28ac539a47776"]},"commit2Childs":{"c95a819869502635864dac0a788f874787e3395b":["55eeb2534cd53d2a985669829df942468ebf5314","d4d69c535930b5cce125cff868d40f6373dc27d4","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7afb64ff3a701f68b2689cafff6c5bdeb4f67f63"],"81f984bc3fef371bf2393a453ebd7835bcb0ee8d":["622a708571e534680618b3c5e0c28ac539a47776"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"55eeb2534cd53d2a985669829df942468ebf5314":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"7afb64ff3a701f68b2689cafff6c5bdeb4f67f63":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"622a708571e534680618b3c5e0c28ac539a47776":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["81f984bc3fef371bf2393a453ebd7835bcb0ee8d"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["c95a819869502635864dac0a788f874787e3395b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}