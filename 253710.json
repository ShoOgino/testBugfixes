{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","commits":[{"id":"f13ec1b606a28789743a563929e7c556e8218297","date":1389302034,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = _TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = _TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1e7da8a91a92330e8f04b171b83e655a4a25c31","date":1394125906,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4637747f71df783fc2014ef1f1e0418466e3bed6","date":1394196311,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":["f13ec1b606a28789743a563929e7c556e8218297"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, tempDir, a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1) {\n      @Override\n      protected Directory getDirectory(File path) {\n        return newFSDirectory(path);\n      }\n    };\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = TestUtil.getTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff4227bb146f97aabae888091c19e48c88dbb0db","date":1406758576,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cdab62f058ea765dd33deb05b4f19b7d626c801","date":1406803479,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"379db3ad24c4f0214f30a122265a6d6be003a99d","date":1407537768,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(TEST_VERSION_CURRENT, CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6549d5ea6b7b25525309b981de3ec92b4dff99d1","date":1408666035,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19e497fe4da591a79332da97681b8017d9c61165","date":1409030374,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(TEST_VERSION_CURRENT, newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    File tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f074d711053c296894efa2d36276eff5030e62e","date":1450779998,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n    suggester.close();\n\n    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);\n\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8712eb1280636aa9e2103ef8ad56ec19641709ea","date":1527853961,"type":3,"author":"Alessandro Benedetti","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n    suggester.close();\n\n    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);\n\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n    suggester.close();\n\n    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);\n\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f85ab7c9984664325c8d83527d0c5828b1a06b1","date":1528394250,"type":3,"author":"Alessandro Benedetti","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest#testBlendingType().mjava","sourceNew":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n    suggester.close();\n\n    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);\n\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, \"the\", pl, 1));\n    assertEquals((int) (w * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","sourceOld":"  /**\n   * Verify the different flavours of the blender types\n   */\n  public void testBlendingType() throws IOException {\n\n    BytesRef pl = new BytesRef(\"lake\");\n    long w = 20;\n\n    Input keys[] = new Input[]{\n        new Input(\"top of the lake\", w, pl)\n    };\n\n    Path tempDir = createTempDir(\"BlendedInfixSuggesterTest\");\n    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);\n\n    // BlenderType.LINEAR is used by default (remove position*10%)\n    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * (1 - 0.10 * 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * (1 - 0.10 * 3)), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n\n    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (1 + 2)), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (1 + 3)), getInResults(suggester, \"lake\", pl, 1));\n    suggester.close();\n\n    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word\n    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,\n        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,\n        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);\n\n    suggester.build(new InputArrayIterator(keys));\n\n    assertEquals(10 * w, getInResults(suggester, \"top\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, \"the\", pl, 1));\n    assertEquals(w * (long) (10 * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, \"lake\", pl, 1));\n\n    suggester.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ff4227bb146f97aabae888091c19e48c88dbb0db":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["6613659748fe4411a7dcf85266e55db1f95f7315","4637747f71df783fc2014ef1f1e0418466e3bed6"],"8712eb1280636aa9e2103ef8ad56ec19641709ea":["6f074d711053c296894efa2d36276eff5030e62e"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["4637747f71df783fc2014ef1f1e0418466e3bed6","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["f13ec1b606a28789743a563929e7c556e8218297"],"f13ec1b606a28789743a563929e7c556e8218297":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["379db3ad24c4f0214f30a122265a6d6be003a99d"],"0f85ab7c9984664325c8d83527d0c5828b1a06b1":["8712eb1280636aa9e2103ef8ad56ec19641709ea"],"f4abec28b874149a7223e32cc7a01704c27790de":["19e497fe4da591a79332da97681b8017d9c61165"],"d0d579490a72f2e6297eaa648940611234c57cf1":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"f1e7da8a91a92330e8f04b171b83e655a4a25c31":["6613659748fe4411a7dcf85266e55db1f95f7315"],"19e497fe4da591a79332da97681b8017d9c61165":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"379db3ad24c4f0214f30a122265a6d6be003a99d":["5cdab62f058ea765dd33deb05b4f19b7d626c801"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6f074d711053c296894efa2d36276eff5030e62e":["f4abec28b874149a7223e32cc7a01704c27790de"],"5cdab62f058ea765dd33deb05b4f19b7d626c801":["ff4227bb146f97aabae888091c19e48c88dbb0db"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["6613659748fe4411a7dcf85266e55db1f95f7315","f1e7da8a91a92330e8f04b171b83e655a4a25c31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6f074d711053c296894efa2d36276eff5030e62e"]},"commit2Childs":{"ff4227bb146f97aabae888091c19e48c88dbb0db":["5cdab62f058ea765dd33deb05b4f19b7d626c801"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"8712eb1280636aa9e2103ef8ad56ec19641709ea":["0f85ab7c9984664325c8d83527d0c5828b1a06b1"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ff4227bb146f97aabae888091c19e48c88dbb0db"],"6613659748fe4411a7dcf85266e55db1f95f7315":["96ea64d994d340044e0d57aeb6a5871539d10ca5","f1e7da8a91a92330e8f04b171b83e655a4a25c31","4637747f71df783fc2014ef1f1e0418466e3bed6"],"f13ec1b606a28789743a563929e7c556e8218297":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["19e497fe4da591a79332da97681b8017d9c61165"],"0f85ab7c9984664325c8d83527d0c5828b1a06b1":[],"f4abec28b874149a7223e32cc7a01704c27790de":["6f074d711053c296894efa2d36276eff5030e62e"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"f1e7da8a91a92330e8f04b171b83e655a4a25c31":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"19e497fe4da591a79332da97681b8017d9c61165":["f4abec28b874149a7223e32cc7a01704c27790de"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f13ec1b606a28789743a563929e7c556e8218297"],"379db3ad24c4f0214f30a122265a6d6be003a99d":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["96ea64d994d340044e0d57aeb6a5871539d10ca5","2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"6f074d711053c296894efa2d36276eff5030e62e":["8712eb1280636aa9e2103ef8ad56ec19641709ea","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5cdab62f058ea765dd33deb05b4f19b7d626c801":["379db3ad24c4f0214f30a122265a6d6be003a99d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","0f85ab7c9984664325c8d83527d0c5828b1a06b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}