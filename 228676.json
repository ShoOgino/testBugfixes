{"path":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteBoxPhraseParsingShortInput().mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteBoxPhraseParsingShortInput().mjava","pathOld":"/dev/null","sourceNew":"  public void testWhiteBoxPhraseParsingShortInput() throws Exception {\n    // for input this short, either of these fields should be (mostly) equivilent\n    final Map<String,Integer> fields = new TreeMap<>();\n    fields.put(\"multigrams_body\", 7); \n    fields.put(\"multigrams_body_short\", 3);\n    for (Map.Entry<String,Integer> entry : fields.entrySet()) {\n      try {\n        final int maxQ = entry.getValue();\n        final SchemaField field = h.getCore().getLatestSchema().getField(entry.getKey());\n        assertNotNull(field);\n        \n        // empty input shouldn't break anything\n        assertEquals(0, Phrase.extractPhrases(random().nextBoolean() ? \"\" : \"  \", field, 3, maxQ).size());\n        \n        // input shorter them our index/query phrase sizes shouldn't break anything either....\n        final List<Phrase> phrases = Phrase.extractPhrases(\"brown FOX\", field, 3, maxQ);\n        \n        assertEquals(3, phrases.size());\n        \n        { // length 2\n          final Phrase brown_fox = phrases.get(1);\n          final String debug = brown_fox.toString();\n          \n          assertEquals(debug, \"brown FOX\", brown_fox.getSubSequence());\n          assertEquals(debug, 1, brown_fox.getPositionStart());\n          assertEquals(debug, 3, brown_fox.getPositionEnd());\n          assertEquals(debug, 2, brown_fox.getPositionLength());\n          \n          assertEquals(debug, 0, brown_fox.getOffsetStart());\n          assertEquals(debug, 9, brown_fox.getOffsetEnd());\n          \n          assertEquals(debug, 2, brown_fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, brown_fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, brown_fox, brown_fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 0, brown_fox.getIndexedSuperPhrases().size());\n        }\n        { // length 1\n          final Phrase fox = phrases.get(2);\n          final String debug = fox.toString();\n          \n          assertEquals(debug, \"FOX\", fox.getSubSequence());\n          assertEquals(debug, 2, fox.getPositionStart());\n          assertEquals(debug, 3, fox.getPositionEnd());\n          assertEquals(debug, 1, fox.getPositionLength());\n          \n          assertEquals(debug, 6, fox.getOffsetStart());\n          assertEquals(debug, 9, fox.getOffsetEnd());\n          \n          assertEquals(debug, 1, fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, fox, fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 1, fox.getIndexedSuperPhrases().size());\n        }\n        \n        assertBasicSanityChecks(phrases, 2, 3, maxQ);\n      } catch (AssertionError e) {\n        throw new AssertionError(entry.getKey() + \" => \" + e.getMessage(), e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteBoxPhraseParsingShortInput().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteBoxPhraseParsingShortInput().mjava","sourceNew":"  public void testWhiteBoxPhraseParsingShortInput() throws Exception {\n    // for input this short, either of these fields should be (mostly) equivalent\n    final Map<String,Integer> fields = new TreeMap<>();\n    fields.put(\"multigrams_body\", 7); \n    fields.put(\"multigrams_body_short\", 3);\n    for (Map.Entry<String,Integer> entry : fields.entrySet()) {\n      try {\n        final int maxQ = entry.getValue();\n        final SchemaField field = h.getCore().getLatestSchema().getField(entry.getKey());\n        assertNotNull(field);\n        \n        // empty input shouldn't break anything\n        assertEquals(0, Phrase.extractPhrases(random().nextBoolean() ? \"\" : \"  \", field, 3, maxQ).size());\n        \n        // input shorter them our index/query phrase sizes shouldn't break anything either....\n        final List<Phrase> phrases = Phrase.extractPhrases(\"brown FOX\", field, 3, maxQ);\n        \n        assertEquals(3, phrases.size());\n        \n        { // length 2\n          final Phrase brown_fox = phrases.get(1);\n          final String debug = brown_fox.toString();\n          \n          assertEquals(debug, \"brown FOX\", brown_fox.getSubSequence());\n          assertEquals(debug, 1, brown_fox.getPositionStart());\n          assertEquals(debug, 3, brown_fox.getPositionEnd());\n          assertEquals(debug, 2, brown_fox.getPositionLength());\n          \n          assertEquals(debug, 0, brown_fox.getOffsetStart());\n          assertEquals(debug, 9, brown_fox.getOffsetEnd());\n          \n          assertEquals(debug, 2, brown_fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, brown_fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, brown_fox, brown_fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 0, brown_fox.getIndexedSuperPhrases().size());\n        }\n        { // length 1\n          final Phrase fox = phrases.get(2);\n          final String debug = fox.toString();\n          \n          assertEquals(debug, \"FOX\", fox.getSubSequence());\n          assertEquals(debug, 2, fox.getPositionStart());\n          assertEquals(debug, 3, fox.getPositionEnd());\n          assertEquals(debug, 1, fox.getPositionLength());\n          \n          assertEquals(debug, 6, fox.getOffsetStart());\n          assertEquals(debug, 9, fox.getOffsetEnd());\n          \n          assertEquals(debug, 1, fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, fox, fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 1, fox.getIndexedSuperPhrases().size());\n        }\n        \n        assertBasicSanityChecks(phrases, 2, 3, maxQ);\n      } catch (AssertionError e) {\n        throw new AssertionError(entry.getKey() + \" => \" + e.getMessage(), e);\n      }\n    }\n  }\n\n","sourceOld":"  public void testWhiteBoxPhraseParsingShortInput() throws Exception {\n    // for input this short, either of these fields should be (mostly) equivilent\n    final Map<String,Integer> fields = new TreeMap<>();\n    fields.put(\"multigrams_body\", 7); \n    fields.put(\"multigrams_body_short\", 3);\n    for (Map.Entry<String,Integer> entry : fields.entrySet()) {\n      try {\n        final int maxQ = entry.getValue();\n        final SchemaField field = h.getCore().getLatestSchema().getField(entry.getKey());\n        assertNotNull(field);\n        \n        // empty input shouldn't break anything\n        assertEquals(0, Phrase.extractPhrases(random().nextBoolean() ? \"\" : \"  \", field, 3, maxQ).size());\n        \n        // input shorter them our index/query phrase sizes shouldn't break anything either....\n        final List<Phrase> phrases = Phrase.extractPhrases(\"brown FOX\", field, 3, maxQ);\n        \n        assertEquals(3, phrases.size());\n        \n        { // length 2\n          final Phrase brown_fox = phrases.get(1);\n          final String debug = brown_fox.toString();\n          \n          assertEquals(debug, \"brown FOX\", brown_fox.getSubSequence());\n          assertEquals(debug, 1, brown_fox.getPositionStart());\n          assertEquals(debug, 3, brown_fox.getPositionEnd());\n          assertEquals(debug, 2, brown_fox.getPositionLength());\n          \n          assertEquals(debug, 0, brown_fox.getOffsetStart());\n          assertEquals(debug, 9, brown_fox.getOffsetEnd());\n          \n          assertEquals(debug, 2, brown_fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, brown_fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, brown_fox, brown_fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 0, brown_fox.getIndexedSuperPhrases().size());\n        }\n        { // length 1\n          final Phrase fox = phrases.get(2);\n          final String debug = fox.toString();\n          \n          assertEquals(debug, \"FOX\", fox.getSubSequence());\n          assertEquals(debug, 2, fox.getPositionStart());\n          assertEquals(debug, 3, fox.getPositionEnd());\n          assertEquals(debug, 1, fox.getPositionLength());\n          \n          assertEquals(debug, 6, fox.getOffsetStart());\n          assertEquals(debug, 9, fox.getOffsetEnd());\n          \n          assertEquals(debug, 1, fox.getIndividualIndexedTerms().size());\n          assertEquals(debug, 1, fox.getLargestIndexedSubPhrases().size());\n          assertEquals(debug, fox, fox.getLargestIndexedSubPhrases().get(0));\n          assertEquals(debug, 1, fox.getIndexedSuperPhrases().size());\n        }\n        \n        assertBasicSanityChecks(phrases, 2, 3, maxQ);\n      } catch (AssertionError e) {\n        throw new AssertionError(entry.getKey() + \" => \" + e.getMessage(), e);\n      }\n    }\n  }\n\n","bugFix":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f4251f14d2db68330fc1e6f0495c053a905d560"]},"commit2Childs":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}