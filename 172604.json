{"path":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","commits":[{"id":"85a757d77b8686d261b25acf542b0037bf65d8fa","date":1367436352,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLog4jWatcher() {\n\n    Logger log = LoggerFactory.getLogger(\"testlogger\");\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"testlogger\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5832050525b97d61021a45dac2330a707639600d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"org.apache.solr.logging.TestLogWatcher\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testLog4jWatcher() {\n\n    Logger log = LoggerFactory.getLogger(\"testlogger\");\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"testlogger\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ab8af690923dc6fb1e56000575813136fef82b","date":1535773145,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      boolean foundMsg = false;\n      long last = -1;\n      // In local testing this loop usually succeeds 1-2 tries.\n      for (int msgIdx = 0; msgIdx < 100; ++msgIdx) {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException ie) {\n          ;\n        }\n      }\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"org.apache.solr.logging.TestLogWatcher\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","bugFix":null,"bugIntro":["6e6487ac9e65315d4919099df92185cbcd3b2f84"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e6487ac9e65315d4919099df92185cbcd3b2f84","date":1535995173,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      for (int msgIdx = 0; msgIdx < 100; ++msgIdx) {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException ie) {\n          ;\n        }\n      }\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      boolean foundMsg = false;\n      long last = -1;\n      // In local testing this loop usually succeeds 1-2 tries.\n      for (int msgIdx = 0; msgIdx < 100; ++msgIdx) {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException ie) {\n          ;\n        }\n      }\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","bugFix":["d0ab8af690923dc6fb1e56000575813136fef82b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47095225c619db90e0cf4ca03f23cd70a34d2a09","date":1536287133,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n\n      // Every time you put a message in the queue, you wait for it to come out _before_ creating\n      // a new watcher so it should be fine.\n      if (looper(watcher, null) == false) {\n        fail(\"There should be no messages when a new watcher finally gets registered! In loop: \" + idx);\n      }\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      if (looper(watcher, msg) == false) {\n        fail(\"Should have found message \" + msg + \". In loop: \" + idx);\n      }\n    }\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      for (int msgIdx = 0; msgIdx < 100; ++msgIdx) {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException ie) {\n          ;\n        }\n      }\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","bugFix":null,"bugIntro":["daf113441cc81a27763ec0f467a33d835ae8d88a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c692eaaa4ea31017e43d18209fdea78687586e","date":1536385910,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"org.apache.solr.logging.TestLogWatcher\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n\n      // Every time you put a message in the queue, you wait for it to come out _before_ creating\n      // a new watcher so it should be fine.\n      if (looper(watcher, null) == false) {\n        fail(\"There should be no messages when a new watcher finally gets registered! In loop: \" + idx);\n      }\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      if (looper(watcher, msg) == false) {\n        fail(\"Should have found message \" + msg + \". In loop: \" + idx);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5832050525b97d61021a45dac2330a707639600d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5832050525b97d61021a45dac2330a707639600d","date":1550867222,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        Thread.sleep(10);\n      } while (timeOut.hasTimedOut() == false);\n\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"org.apache.solr.logging.TestLogWatcher\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","bugFix":["85a757d77b8686d261b25acf542b0037bf65d8fa","30c692eaaa4ea31017e43d18209fdea78687586e"],"bugIntro":["daf113441cc81a27763ec0f467a33d835ae8d88a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4","date":1551083645,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        Thread.sleep(10);\n      } while (timeOut.hasTimedOut() == false);\n\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testLog4jWatcher() {\n    LogWatcher watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n    assertEquals(watcher.getLastEvent(), -1);\n\n    log.warn(\"This is a test message\");\n\n    assertTrue(watcher.getLastEvent() > -1);\n\n    SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n    assertEquals(events.size(), 1);\n\n    SolrDocument event = events.get(0);\n    assertEquals(event.get(\"logger\"), \"org.apache.solr.logging.TestLogWatcher\");\n    assertEquals(event.get(\"message\"), \"This is a test message\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce6ac2f8144bf1a8fc35c555924357dd8efefc54","date":1552110006,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      long lastEvent = watcher.getLastEvent();\n      if (lastEvent != -1L) { // Dump some information to try to understand failure.\n        AtomicBoolean ab = new AtomicBoolean();\n        SolrDocumentList events = watcher.getHistory(-1, ab);\n\n        System.out.println(\"Found value is: \" + ab.toString());\n\n        System.out.println(\"Dumping all events in this watcher:\");\n        for (SolrDocument doc : events) {\n          System.out.println(\"   Event:'\" + doc.toString() +\"'\");\n        }\n        fail(\"lastEvent was not -1, was: '\" + lastEvent + \"'\");\n      }\n\n      // Now log a message and ensure that the new watcher sees it.\n      String msg = \"This is a test message: \" + idx;\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        Thread.sleep(10);\n      } while (foundMsg == false && timeOut.hasTimedOut() == false);\n\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n      String msg = \"This is a test message: \" + idx;\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      assertEquals(-1, watcher.getLastEvent());\n\n      // Now log a message and ensure that the new watcher sees it.\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, new AtomicBoolean());\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        Thread.sleep(10);\n      } while (timeOut.hasTimedOut() == false);\n\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","bugFix":null,"bugIntro":["daf113441cc81a27763ec0f467a33d835ae8d88a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"daf113441cc81a27763ec0f467a33d835ae8d88a","date":1552334108,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  // NOTE: Since the superclass logs messages, it's possible that there are one or more\n  //       messages in the queue at the start, especially with asynch logging.\n  //       All we really care about is that new watchers get the new messages, so test for that\n  //       explicitly. See SOLR-12732.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    // Every time through this loop, insure that, of all the test messages that have been logged, only the current\n    // test message is present. NOTE: there may be log messages from the superclass the first time around.\n    List<String> oldMessages = new ArrayList<>(lim);\n    for (int idx = 0; idx < lim; ++idx) {\n\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // Now log a message and ensure that the new watcher sees it.\n      String msg = \"This is a test message: \" + idx;\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundNewMsg = false;\n      boolean foundOldMessage = false;\n      // In local testing this loop usually succeeds 1-2 tries, so it's not very expensive to loop.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          String oneMsg = (String) doc.get(\"message\");\n          if (oneMsg.equals(msg)) {\n            foundNewMsg = true;\n          }\n          // Check that no old messages bled over into this watcher.\n          for (String oldMsg : oldMessages) {\n            if (oneMsg.equals(oldMsg)) {\n              foundOldMessage = true;\n            }\n          }\n        }\n        if (foundNewMsg == false) {\n          Thread.sleep(10);\n        }\n      } while (foundNewMsg == false && timeOut.hasTimedOut() == false);\n\n      if (foundNewMsg == false || foundOldMessage) {\n        System.out.println(\"Dumping all events in failed watcher:\");\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          System.out.println(\"   Event:'\" + doc.toString() + \"'\");\n        }\n        System.out.println(\"Recorded old messages\");\n        for (String oldMsg : oldMessages) {\n          System.out.println(\"    \" + oldMsg);\n        }\n\n        fail(\"Did not find expected message state, dumped current watcher's messages above, last message added: '\" + msg + \"'\");\n      }\n      oldMessages.add(msg);\n    }\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    for (int idx = 0; idx < lim; ++idx) {\n\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // First ensure there's nothing in the new watcher.\n      long lastEvent = watcher.getLastEvent();\n      if (lastEvent != -1L) { // Dump some information to try to understand failure.\n        AtomicBoolean ab = new AtomicBoolean();\n        SolrDocumentList events = watcher.getHistory(-1, ab);\n\n        System.out.println(\"Found value is: \" + ab.toString());\n\n        System.out.println(\"Dumping all events in this watcher:\");\n        for (SolrDocument doc : events) {\n          System.out.println(\"   Event:'\" + doc.toString() +\"'\");\n        }\n        fail(\"lastEvent was not -1, was: '\" + lastEvent + \"'\");\n      }\n\n      // Now log a message and ensure that the new watcher sees it.\n      String msg = \"This is a test message: \" + idx;\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundMsg = false;\n      // In local testing this loop usually succeeds 1-2 tries.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          if (doc.get(\"message\").equals(msg)) {\n            foundMsg = true;\n            break;\n          }\n        }\n        Thread.sleep(10);\n      } while (foundMsg == false && timeOut.hasTimedOut() == false);\n\n      assertTrue(\"Should have found message \" + msg + \" in loop: \" + idx, foundMsg);\n    }\n  }\n\n","bugFix":["ce6ac2f8144bf1a8fc35c555924357dd8efefc54","5832050525b97d61021a45dac2330a707639600d","47095225c619db90e0cf4ca03f23cd70a34d2a09"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","pathOld":"solr/core/src/test/org/apache/solr/logging/TestLogWatcher#testLog4jWatcher().mjava","sourceNew":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  // NOTE: Since the superclass logs messages, it's possible that there are one or more\n  //       messages in the queue at the start, especially with asynch logging.\n  //       All we really care about is that new watchers get the new messages, so test for that\n  //       explicitly. See SOLR-12732.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    @SuppressWarnings({\"rawtypes\"})\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    // Every time through this loop, insure that, of all the test messages that have been logged, only the current\n    // test message is present. NOTE: there may be log messages from the superclass the first time around.\n    List<String> oldMessages = new ArrayList<>(lim);\n    for (int idx = 0; idx < lim; ++idx) {\n\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // Now log a message and ensure that the new watcher sees it.\n      String msg = \"This is a test message: \" + idx;\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundNewMsg = false;\n      boolean foundOldMessage = false;\n      // In local testing this loop usually succeeds 1-2 tries, so it's not very expensive to loop.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          String oneMsg = (String) doc.get(\"message\");\n          if (oneMsg.equals(msg)) {\n            foundNewMsg = true;\n          }\n          // Check that no old messages bled over into this watcher.\n          for (String oldMsg : oldMessages) {\n            if (oneMsg.equals(oldMsg)) {\n              foundOldMessage = true;\n            }\n          }\n        }\n        if (foundNewMsg == false) {\n          Thread.sleep(10);\n        }\n      } while (foundNewMsg == false && timeOut.hasTimedOut() == false);\n\n      if (foundNewMsg == false || foundOldMessage) {\n        System.out.println(\"Dumping all events in failed watcher:\");\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          System.out.println(\"   Event:'\" + doc.toString() + \"'\");\n        }\n        System.out.println(\"Recorded old messages\");\n        for (String oldMsg : oldMessages) {\n          System.out.println(\"    \" + oldMsg);\n        }\n\n        fail(\"Did not find expected message state, dumped current watcher's messages above, last message added: '\" + msg + \"'\");\n      }\n      oldMessages.add(msg);\n    }\n  }\n\n","sourceOld":"  // Create several log watchers and ensure that new messages go to the new watcher.\n  // NOTE: Since the superclass logs messages, it's possible that there are one or more\n  //       messages in the queue at the start, especially with asynch logging.\n  //       All we really care about is that new watchers get the new messages, so test for that\n  //       explicitly. See SOLR-12732.\n  @Test\n  public void testLog4jWatcher() throws InterruptedException {\n    LogWatcher watcher = null;\n    int lim = random().nextInt(3) + 2;\n    // Every time through this loop, insure that, of all the test messages that have been logged, only the current\n    // test message is present. NOTE: there may be log messages from the superclass the first time around.\n    List<String> oldMessages = new ArrayList<>(lim);\n    for (int idx = 0; idx < lim; ++idx) {\n\n      watcher = LogWatcher.newRegisteredLogWatcher(config, null);\n\n      // Now log a message and ensure that the new watcher sees it.\n      String msg = \"This is a test message: \" + idx;\n      log.warn(msg);\n\n      // Loop to give the logger time to process the async message and notify the new watcher.\n      TimeOut timeOut = new TimeOut(10, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n      boolean foundNewMsg = false;\n      boolean foundOldMessage = false;\n      // In local testing this loop usually succeeds 1-2 tries, so it's not very expensive to loop.\n      do {\n        // Returns an empty (but non-null) list even if there are no messages yet.\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          String oneMsg = (String) doc.get(\"message\");\n          if (oneMsg.equals(msg)) {\n            foundNewMsg = true;\n          }\n          // Check that no old messages bled over into this watcher.\n          for (String oldMsg : oldMessages) {\n            if (oneMsg.equals(oldMsg)) {\n              foundOldMessage = true;\n            }\n          }\n        }\n        if (foundNewMsg == false) {\n          Thread.sleep(10);\n        }\n      } while (foundNewMsg == false && timeOut.hasTimedOut() == false);\n\n      if (foundNewMsg == false || foundOldMessage) {\n        System.out.println(\"Dumping all events in failed watcher:\");\n        SolrDocumentList events = watcher.getHistory(-1, null);\n        for (SolrDocument doc : events) {\n          System.out.println(\"   Event:'\" + doc.toString() + \"'\");\n        }\n        System.out.println(\"Recorded old messages\");\n        for (String oldMsg : oldMessages) {\n          System.out.println(\"    \" + oldMsg);\n        }\n\n        fail(\"Did not find expected message state, dumped current watcher's messages above, last message added: '\" + msg + \"'\");\n      }\n      oldMessages.add(msg);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"47095225c619db90e0cf4ca03f23cd70a34d2a09":["6e6487ac9e65315d4919099df92185cbcd3b2f84"],"30c692eaaa4ea31017e43d18209fdea78687586e":["47095225c619db90e0cf4ca03f23cd70a34d2a09"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["85a757d77b8686d261b25acf542b0037bf65d8fa"],"6e6487ac9e65315d4919099df92185cbcd3b2f84":["d0ab8af690923dc6fb1e56000575813136fef82b"],"5832050525b97d61021a45dac2330a707639600d":["30c692eaaa4ea31017e43d18209fdea78687586e"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["daf113441cc81a27763ec0f467a33d835ae8d88a"],"daf113441cc81a27763ec0f467a33d835ae8d88a":["ce6ac2f8144bf1a8fc35c555924357dd8efefc54"],"d0ab8af690923dc6fb1e56000575813136fef82b":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ce6ac2f8144bf1a8fc35c555924357dd8efefc54":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"85a757d77b8686d261b25acf542b0037bf65d8fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["30c692eaaa4ea31017e43d18209fdea78687586e","5832050525b97d61021a45dac2330a707639600d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"]},"commit2Childs":{"47095225c619db90e0cf4ca03f23cd70a34d2a09":["30c692eaaa4ea31017e43d18209fdea78687586e"],"30c692eaaa4ea31017e43d18209fdea78687586e":["5832050525b97d61021a45dac2330a707639600d","0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["d0ab8af690923dc6fb1e56000575813136fef82b"],"6e6487ac9e65315d4919099df92185cbcd3b2f84":["47095225c619db90e0cf4ca03f23cd70a34d2a09"],"5832050525b97d61021a45dac2330a707639600d":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0ab8af690923dc6fb1e56000575813136fef82b":["6e6487ac9e65315d4919099df92185cbcd3b2f84"],"daf113441cc81a27763ec0f467a33d835ae8d88a":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85a757d77b8686d261b25acf542b0037bf65d8fa"],"ce6ac2f8144bf1a8fc35c555924357dd8efefc54":["daf113441cc81a27763ec0f467a33d835ae8d88a"],"85a757d77b8686d261b25acf542b0037bf65d8fa":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["ce6ac2f8144bf1a8fc35c555924357dd8efefc54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}