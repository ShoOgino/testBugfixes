{"path":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = new IndexSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = q.weight(s);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = q.weight(indexSearcher);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = q.weight(indexSearcher);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc1f3f78b299e125f7e60f43b5d457392bea23f","date":1317431015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], ScorerContext.def());\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), ScorerContext.def());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final IndexReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final IndexReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          indexSearcher.close();\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader;\n        lastDoc[0] = -1;\n        liveDocs = context.reader.getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final IndexReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n      indexSearcher.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","6f7fee42303a18cc146043c96f66491311b345d9"],"7b91922b55d15444d554721b352861d028eb8278":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"6f7fee42303a18cc146043c96f66491311b345d9":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6f7fee42303a18cc146043c96f66491311b345d9"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"6f7fee42303a18cc146043c96f66491311b345d9":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["7b91922b55d15444d554721b352861d028eb8278"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","6f7fee42303a18cc146043c96f66491311b345d9","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}