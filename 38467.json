{"path":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","commits":[{"id":"3ca983bc42b1777a3becdc3d28a4a33339475613","date":1341662662,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ENGLISH, \n          \"Scanned %d class file(s) for forbidden method invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden method calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279c7cd47f17e1e8b674a3741ff5f040bc680be","date":1341675760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden method invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden method calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ENGLISH, \n          \"Scanned %d class file(s) for forbidden method invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden method calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab24339150e7c651533a7e57934f12700ead2a6a","date":1341698602,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden method invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden method calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b25adb2dc9f746a899f34ebe5c6c4d5a6b55591","date":1341842077,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r.getName());\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r.getName());\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r.getName(), ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c4d0ac761aadb2f09981941103107c940d08bb4","date":1341917223,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      final ClassLoader loader;\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            log(\"Reading inline API signatures...\", Project.MSG_INFO);\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n    } finally {\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n    }\n\n    long start = System.currentTimeMillis();\n    \n    int checked = 0;\n    int errors = 0;\n    @SuppressWarnings(\"unchecked\")\n    Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n    if (!iter.hasNext()) {\n      throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n    }\n    while (iter.hasNext()) {\n      final Resource r = iter.next();\n      if (!r.isExists()) { \n        throw new BuildException(\"Class file does not exist: \" + r);\n      }\n\n      try {\n        errors += checkClass(r);\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n      }\n      checked++;\n    }\n\n    log(String.format(Locale.ROOT, \n        \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n        checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n        errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n    if (errors > 0) {\n      throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","bugFix":null,"bugIntro":["a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7f73df94cfb3e05fba3b55eaa6677855a369c35","date":1341945151,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            log(\"Reading inline API signatures...\", Project.MSG_INFO);\n            parseApiFile(new StringReader(((StringResource) r).getValue()));\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      final ClassLoader loader;\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            log(\"Reading inline API signatures...\", Project.MSG_INFO);\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n    } finally {\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n    }\n\n    long start = System.currentTimeMillis();\n    \n    int checked = 0;\n    int errors = 0;\n    @SuppressWarnings(\"unchecked\")\n    Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n    if (!iter.hasNext()) {\n      throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n    }\n    while (iter.hasNext()) {\n      final Resource r = iter.next();\n      if (!r.isExists()) { \n        throw new BuildException(\"Class file does not exist: \" + r);\n      }\n\n      try {\n        errors += checkClass(r);\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n      }\n      checked++;\n    }\n\n    log(String.format(Locale.ROOT, \n        \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n        checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n        errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n    if (errors > 0) {\n      throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a2f689686acb2d0b2334af829ebc9f03f0f2f616","date":1342046079,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            log(\"Reading inline API signatures...\", Project.MSG_INFO);\n            parseApiFile(new StringReader(((StringResource) r).getValue()));\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":["7c4d0ac761aadb2f09981941103107c940d08bb4","c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader loader = null;\n    try {\n      if (classpath != null) {\n          classpath.setProject(getProject());\n          loader = getProject().createClassLoader(classpath);\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            parseApiFile(loader, new StringReader(((StringResource) r).getValue()));\n          } else {\n            parseApiFile(loader, new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      long start = System.currentTimeMillis();\n      \n      int checked = 0;\n      int errors = 0;\n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        try {\n          errors += checkClass(r);\n        } catch (IOException ioe) {\n          throw new BuildException(\"IO problem while reading class file \" + r, ioe);\n        }\n        checked++;\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          checked, (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      if (loader != null) loader.cleanup();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff","date":1354378216,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    // the checker is not compatible with JDK 1.8+ (changed class format: 52.0), don't fail just report warning:\n    try {\n      Collections.class.getMethod(\"emptySortedSet\");\n      // this is Java 8 :(\n      log(\"Java 8 or later is currently not supported by this checker. Please run the checks with a previous JDK!\", Project.MSG_WARN);\n      return;\n    } catch (NoSuchMethodException nsme) {\n      // ignore, we are fine!\n    }\n    \n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":["2d7efa3550a021084b8122a948fb2122064498d5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d7efa3550a021084b8122a948fb2122064498d5","date":1354402024,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n      \n      // check if we can load runtime classes (e.g. java.lang.String).\n      // If this fails, we have a newer Java version than ASM supports:\n      try {\n        getClassFromClassLoader(String.class.getName());\n      } catch (IllegalArgumentException iae) {\n        final String msg = String.format(Locale.ROOT, \n          \"Your Java version (%s) is not supported by <%s/>. Please run the checks with a supported JDK!\",\n          System.getProperty(\"java.version\"), getTaskName());\n        if (failOnUnsupportedJava) {\n          throw new BuildException(msg);\n        } else {\n          log(\"WARNING: \" + msg, Project.MSG_WARN);\n          return;\n        }\n      }\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    // the checker is not compatible with JDK 1.8+ (changed class format: 52.0), don't fail just report warning:\n    try {\n      Collections.class.getMethod(\"emptySortedSet\");\n      // this is Java 8 :(\n      log(\"Java 8 or later is currently not supported by this checker. Please run the checks with a previous JDK!\", Project.MSG_WARN);\n      return;\n    } catch (NoSuchMethodException nsme) {\n      // ignore, we are fine!\n    }\n    \n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":["31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n      \n      // check if we can load runtime classes (e.g. java.lang.String).\n      // If this fails, we have a newer Java version than ASM supports:\n      try {\n        getClassFromClassLoader(String.class.getName());\n      } catch (IllegalArgumentException iae) {\n        final String msg = String.format(Locale.ROOT, \n          \"Your Java version (%s) is not supported by <%s/>. Please run the checks with a supported JDK!\",\n          System.getProperty(\"java.version\"), getTaskName());\n        if (failOnUnsupportedJava) {\n          throw new BuildException(msg);\n        } else {\n          log(\"WARNING: \" + msg, Project.MSG_WARN);\n          return;\n        }\n      }\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f65fb5029f5f7fa27e485539ccf9e5a439adfb5","date":1360055735,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n      \n      // check if we can load runtime classes (e.g. java.lang.String).\n      // If this fails, we have a newer Java version than ASM supports:\n      try {\n        getClassFromClassLoader(String.class.getName());\n      } catch (IllegalArgumentException iae) {\n        final String msg = String.format(Locale.ROOT, \n          \"Your Java version (%s) is not supported by <%s/>. Please run the checks with a supported JDK!\",\n          System.getProperty(\"java.version\"), getTaskName());\n        if (failOnUnsupportedJava) {\n          throw new BuildException(msg);\n        } else {\n          log(\"WARNING: \" + msg, Project.MSG_WARN);\n          return;\n        }\n      }\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ForbiddenApisCheckTask#execute().mjava","sourceNew":null,"sourceOld":"  @Override\n  public void execute() throws BuildException {\n    AntClassLoader antLoader = null;\n    try {\n      if (classpath != null) {\n        classpath.setProject(getProject());\n        this.loader = antLoader = getProject().createClassLoader(ClassLoader.getSystemClassLoader(), classpath);\n        // force that loading from this class loader is done first, then parent is asked.\n        // This violates spec, but prevents classes in any system classpath to be used if a local one is available:\n        antLoader.setParentFirst(false);\n      } else {\n        this.loader = ClassLoader.getSystemClassLoader();\n      }\n      classFiles.setProject(getProject());\n      apiSignatures.setProject(getProject());\n      \n      final long start = System.currentTimeMillis();\n      \n      // check if we can load runtime classes (e.g. java.lang.String).\n      // If this fails, we have a newer Java version than ASM supports:\n      try {\n        getClassFromClassLoader(String.class.getName());\n      } catch (IllegalArgumentException iae) {\n        final String msg = String.format(Locale.ROOT, \n          \"Your Java version (%s) is not supported by <%s/>. Please run the checks with a supported JDK!\",\n          System.getProperty(\"java.version\"), getTaskName());\n        if (failOnUnsupportedJava) {\n          throw new BuildException(msg);\n        } else {\n          log(\"WARNING: \" + msg, Project.MSG_WARN);\n          return;\n        }\n      }\n\n      try {\n        @SuppressWarnings(\"unchecked\")\n        Iterator<Resource> iter = (Iterator<Resource>) apiSignatures.iterator();\n        if (!iter.hasNext()) {\n          throw new BuildException(\"You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.\");\n        }\n        while (iter.hasNext()) {\n          final Resource r = iter.next();\n          if (!r.isExists()) { \n            throw new BuildException(\"Resource does not exist: \" + r);\n          }\n          if (r instanceof StringResource) {\n            final String s = ((StringResource) r).getValue();\n            if (s != null && s.trim().length() > 0) {\n              log(\"Reading inline API signatures...\", Project.MSG_INFO);\n              parseApiFile(new StringReader(s));\n            }\n          } else {\n            log(\"Reading API signatures: \" + r, Project.MSG_INFO);\n            parseApiFile(new InputStreamReader(r.getInputStream(), \"UTF-8\"));\n          }\n        }\n      } catch (IOException ioe) {\n        throw new BuildException(\"IO problem while reading files with API signatures.\", ioe);\n      }\n      if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {\n        throw new BuildException(\"No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!\");\n      }\n\n      log(\"Loading classes to check...\", Project.MSG_INFO);\n            \n      @SuppressWarnings(\"unchecked\")\n      Iterator<Resource> iter = (Iterator<Resource>) classFiles.iterator();\n      if (!iter.hasNext()) {\n        throw new BuildException(\"There is no <fileset/> given or the fileset does not contain any class files to check.\");\n      }\n      while (iter.hasNext()) {\n        final Resource r = iter.next();\n        if (!r.isExists()) { \n          throw new BuildException(\"Class file does not exist: \" + r);\n        }\n\n        ClassReader reader = loadClassFromResource(r);\n        classesToCheck.put(reader.getClassName(), new ClassSignatureLookup(reader));\n      }\n\n      log(\"Scanning for API signatures and dependencies...\", Project.MSG_INFO);\n\n      int errors = 0;\n      for (final ClassSignatureLookup c : classesToCheck.values()) {\n        errors += checkClass(c.reader);\n      }\n\n      log(String.format(Locale.ROOT, \n          \"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).\",\n          classesToCheck.size(), classpathClassCache.size(), (System.currentTimeMillis() - start) / 1000.0, errors),\n          errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);\n\n      if (errors > 0) {\n        throw new BuildException(\"Check for forbidden API calls failed, see log.\");\n      }\n    } finally {\n      this.loader = null;\n      if (antLoader != null) antLoader.cleanup();\n      antLoader = null;\n      classesToCheck.clear();\n      classpathClassCache.clear();\n      forbiddenFields.clear();\n      forbiddenMethods.clear();\n      forbiddenClasses.clear();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7f73df94cfb3e05fba3b55eaa6677855a369c35":["7c4d0ac761aadb2f09981941103107c940d08bb4"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["407687e67faf6e1f02a211ca078d8e3eed631027","8f65fb5029f5f7fa27e485539ccf9e5a439adfb5"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a2f689686acb2d0b2334af829ebc9f03f0f2f616","2d7efa3550a021084b8122a948fb2122064498d5"],"31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff":["a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"a2f689686acb2d0b2334af829ebc9f03f0f2f616":["c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["3ca983bc42b1777a3becdc3d28a4a33339475613"],"2acf500f78aa12b92e371fd89c719291986b6b90":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0b25adb2dc9f746a899f34ebe5c6c4d5a6b55591"],"0b25adb2dc9f746a899f34ebe5c6c4d5a6b55591":["ab24339150e7c651533a7e57934f12700ead2a6a"],"8f65fb5029f5f7fa27e485539ccf9e5a439adfb5":["2d7efa3550a021084b8122a948fb2122064498d5"],"46d8ada1fff8d18cb197c38c7983225162599948":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2acf500f78aa12b92e371fd89c719291986b6b90"],"aba371508186796cc6151d8223a5b4e16d02e26e":["46d8ada1fff8d18cb197c38c7983225162599948","a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"2d7efa3550a021084b8122a948fb2122064498d5":["31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ab24339150e7c651533a7e57934f12700ead2a6a":["9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"3ca983bc42b1777a3becdc3d28a4a33339475613":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8f65fb5029f5f7fa27e485539ccf9e5a439adfb5"],"7c4d0ac761aadb2f09981941103107c940d08bb4":["2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"c7f73df94cfb3e05fba3b55eaa6677855a369c35":["a2f689686acb2d0b2334af829ebc9f03f0f2f616"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff":["2d7efa3550a021084b8122a948fb2122064498d5"],"a2f689686acb2d0b2334af829ebc9f03f0f2f616":["407687e67faf6e1f02a211ca078d8e3eed631027","31b83cc1e18cc44ef19e52ad8554b02ed3ab4aff","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["ab24339150e7c651533a7e57934f12700ead2a6a"],"2acf500f78aa12b92e371fd89c719291986b6b90":["46d8ada1fff8d18cb197c38c7983225162599948","7c4d0ac761aadb2f09981941103107c940d08bb4"],"0b25adb2dc9f746a899f34ebe5c6c4d5a6b55591":["2acf500f78aa12b92e371fd89c719291986b6b90"],"8f65fb5029f5f7fa27e485539ccf9e5a439adfb5":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46d8ada1fff8d18cb197c38c7983225162599948":["aba371508186796cc6151d8223a5b4e16d02e26e"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"2d7efa3550a021084b8122a948fb2122064498d5":["407687e67faf6e1f02a211ca078d8e3eed631027","8f65fb5029f5f7fa27e485539ccf9e5a439adfb5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","3ca983bc42b1777a3becdc3d28a4a33339475613"],"ab24339150e7c651533a7e57934f12700ead2a6a":["0b25adb2dc9f746a899f34ebe5c6c4d5a6b55591"],"3ca983bc42b1777a3becdc3d28a4a33339475613":["9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"7c4d0ac761aadb2f09981941103107c940d08bb4":["c7f73df94cfb3e05fba3b55eaa6677855a369c35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}