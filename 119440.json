{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","commits":[{"id":"0028dcaa058de495a7b164a874c48c6da01708f7","date":1534188111,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlier\", true);\n          t.put(\"lowOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlier\", true);\n          t.put(\"highOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlier\", true);\n          t.put(\"lowOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlier\", true);\n          t.put(\"highOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f16908806e473fa1b428038ab1be037a49695398","date":1534254634,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlier\", true);\n          t.put(\"lowOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlier\", true);\n          t.put(\"highOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlier\", true);\n          t.put(\"lowOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlier\", true);\n          t.put(\"highOutlierValue\", n);\n          t.put(\"cumulativeProbablity\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","date":1591579911,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList<>();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList<>();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/OutliersEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList<>();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple());\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList<>();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public Object doWork(Object... values) throws IOException{\n\n    if(values.length < 4) {\n      throw new IOException(\"The outliers function requires 4 parameters\");\n    }\n\n    Object dist = values[0];\n    List<Number> vec = null;\n    if(values[1] instanceof List) {\n      vec = (List<Number>)values[1];\n    } else {\n      throw new IOException(\"The second parameter of the outliers function is the numeric array to be tested for outliers.\");\n    }\n\n    double low = 0.0;\n\n    if(values[2] instanceof Number) {\n      low = ((Number)values[2]).doubleValue();\n    } else {\n      throw new IOException(\"The third parameter of the outliers function is a number for the low outlier threshold.\");\n    }\n\n    double hi = 0.0;\n\n    if(values[3] instanceof Number) {\n      hi = ((Number)values[3]).doubleValue();\n    } else {\n      throw new IOException(\"The fourth parameter of the outliers function is a number for the high outlier threshold\");\n    }\n\n    List<Tuple> tuples = null;\n\n    if(values.length ==5) {\n      if(values[4] instanceof List) {\n        tuples = (List<Tuple>) values[4];\n      } else {\n        throw new IOException(\"The optional fifth parameter of the outliers function is an array of Tuples that are paired with the numeric array of values to be tested.\");\n      }\n    } else {\n      tuples = new ArrayList<>();\n      for(int i=0; i<vec.size(); i++) {\n        tuples.add(new Tuple(new HashMap()));\n      }\n    }\n\n    List<Tuple> outliers = new ArrayList<>();\n\n    if(dist instanceof IntegerDistribution) {\n\n      IntegerDistribution d = (IntegerDistribution) dist;\n\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.intValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n\n    } else if(dist instanceof AbstractRealDistribution) {\n\n      AbstractRealDistribution d = (AbstractRealDistribution)dist;\n      for(int i=0; i<vec.size(); i++) {\n\n        Number n = vec.get(i);\n        Tuple t = tuples.get(i);\n\n        double cumProb = d.cumulativeProbability(n.doubleValue());\n        if(low >= 0 && cumProb <= low) {\n          t.put(\"lowOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n\n        }\n\n        if(hi >= 0 && cumProb >= hi) {\n          t.put(\"highOutlierValue_d\", n);\n          t.put(\"cumulativeProbablity_d\", cumProb);\n          outliers.add(t);\n        }\n      }\n\n      return outliers;\n    } else {\n      throw new IOException(\"The first parameter of the outliers function must be a real or integer probability distribution\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["f16908806e473fa1b428038ab1be037a49695398"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f16908806e473fa1b428038ab1be037a49695398":["0028dcaa058de495a7b164a874c48c6da01708f7"],"0028dcaa058de495a7b164a874c48c6da01708f7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"804a8d5358fe7b7563b85ee7838714d720b89272":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["804a8d5358fe7b7563b85ee7838714d720b89272"]},"commit2Childs":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0028dcaa058de495a7b164a874c48c6da01708f7"],"f16908806e473fa1b428038ab1be037a49695398":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"0028dcaa058de495a7b164a874c48c6da01708f7":["f16908806e473fa1b428038ab1be037a49695398"],"804a8d5358fe7b7563b85ee7838714d720b89272":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}