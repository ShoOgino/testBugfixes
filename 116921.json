{"path":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","commits":[{"id":"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1","date":1064527311,"type":1,"author":"Dmitry Serebrennikov","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms().mjava","sourceNew":"  private final void openNorms(Directory useDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed)\n        norms.put(fi.name,\n                  new Norm(useDir.openFile(segment + \".f\" + fi.number)));\n    }\n  }\n\n","sourceOld":"  private final void openNorms() throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed)\n\tnorms.put(fi.name,\n\t\t  new Norm(directory.openFile(segment + \".f\" + fi.number)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53df68381fe22c8eaf758533d0d5e1db43b925ac","date":1071529482,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        String fileName = segment + \".f\" + fi.number;\n        // look first for re-written file, then in compound format\n        Directory d = directory().fileExists(fileName) ? directory() : cfsDir;\n        norms.put(fi.name, new Norm(d.openFile(fileName)));\n      }\n    }\n  }\n\n","sourceOld":"  private final void openNorms(Directory useDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed)\n        norms.put(fi.name,\n                  new Norm(useDir.openFile(segment + \".f\" + fi.number)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f653aecb322b74d99e6ecdb93765e453a3d7aa71","date":1082107025,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        String fileName = segment + \".f\" + fi.number;\n        // look first for re-written file, then in compound format\n        Directory d = directory().fileExists(fileName) ? directory() : cfsDir;\n        norms.put(fi.name, new Norm(d.openFile(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        String fileName = segment + \".f\" + fi.number;\n        // look first for re-written file, then in compound format\n        Directory d = directory().fileExists(fileName) ? directory() : cfsDir;\n        norms.put(fi.name, new Norm(d.openFile(fileName)));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6263f219dcdfc6e861ecffaecf5e1e195f1aaaa7","date":1092245915,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openFile(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        String fileName = segment + \".f\" + fi.number;\n        // look first for re-written file, then in compound format\n        Directory d = directory().fileExists(fileName) ? directory() : cfsDir;\n        norms.put(fi.name, new Norm(d.openFile(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e971ba25509e21a130fef61f0687be0446ca27a0","date":1095369217,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openFile(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e5d88b55f1b57feab6da94a5c635a224539bd2a","date":1095877947,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private final void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950f3c7592cb559e2534e5089c78833250e156a3","date":1130557968,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","sourceOld":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        // look first if there are separate norms in compound format\n        String fileName = segment + \".s\" + fi.number;\n        Directory d = directory();\n        if(!d.fileExists(fileName)){\n            fileName = segment + \".f\" + fi.number;\n            d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8969a184df55d25d61e85be785987fbf830d4028","date":1168143561,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir) throws IOException {\n    long nextNormSeek = SegmentMerger.NORMS_HEADER.length; //skip header (header unused for now)\n    int maxDoc = maxDoc();\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        long normSeek = (fileName.endsWith(\".\" + IndexFileNames.NORMS_EXTENSION) ? nextNormSeek : 0);\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number, normSeek));\n        nextNormSeek += maxDoc; // increment also if some norms are separate\n      }\n    }\n  }\n\n","sourceOld":"  private void openNorms(Directory cfsDir) throws IOException {\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"111f5f9f92c974cb15ad5a47e0caec190ca207b7","date":1172978580,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir) throws IOException {\n    long nextNormSeek = SegmentMerger.NORMS_HEADER.length; //skip header (header unused for now)\n    int maxDoc = maxDoc();\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        \n        // singleNormFile means multiple norms share this file\n        boolean singleNormFile = fileName.endsWith(\".\" + IndexFileNames.NORMS_EXTENSION);\n        IndexInput normInput = null;\n        long normSeek;\n\n        if (singleNormFile) {\n          normSeek = nextNormSeek;\n          if (singleNormStream==null) {\n            singleNormStream = d.openInput(fileName);\n          }\n          // All norms in the .nrm file can share a single IndexInput since\n          // they are only used in a synchronized context.\n          // If this were to change in the future, a clone could be done here.\n          normInput = singleNormStream;\n        } else {\n          normSeek = 0;\n          normInput = d.openInput(fileName);\n        }\n\n        norms.put(fi.name, new Norm(normInput, fi.number, normSeek));\n        nextNormSeek += maxDoc; // increment also if some norms are separate\n      }\n    }\n  }\n\n","sourceOld":"  private void openNorms(Directory cfsDir) throws IOException {\n    long nextNormSeek = SegmentMerger.NORMS_HEADER.length; //skip header (header unused for now)\n    int maxDoc = maxDoc();\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        long normSeek = (fileName.endsWith(\".\" + IndexFileNames.NORMS_EXTENSION) ? nextNormSeek : 0);\n        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number, normSeek));\n        nextNormSeek += maxDoc; // increment also if some norms are separate\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c7843edbf325fe98ea91515ee3ff56ab40a9594d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6dba7919de4ff4ed6ff17f90619203772722f08","date":1180451647,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory,int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#openNorms(Directory).mjava","sourceNew":"  private void openNorms(Directory cfsDir, int readBufferSize) throws IOException {\n    long nextNormSeek = SegmentMerger.NORMS_HEADER.length; //skip header (header unused for now)\n    int maxDoc = maxDoc();\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        \n        // singleNormFile means multiple norms share this file\n        boolean singleNormFile = fileName.endsWith(\".\" + IndexFileNames.NORMS_EXTENSION);\n        IndexInput normInput = null;\n        long normSeek;\n\n        if (singleNormFile) {\n          normSeek = nextNormSeek;\n          if (singleNormStream==null) {\n            singleNormStream = d.openInput(fileName, readBufferSize);\n          }\n          // All norms in the .nrm file can share a single IndexInput since\n          // they are only used in a synchronized context.\n          // If this were to change in the future, a clone could be done here.\n          normInput = singleNormStream;\n        } else {\n          normSeek = 0;\n          normInput = d.openInput(fileName);\n        }\n\n        norms.put(fi.name, new Norm(normInput, fi.number, normSeek));\n        nextNormSeek += maxDoc; // increment also if some norms are separate\n      }\n    }\n  }\n\n","sourceOld":"  private void openNorms(Directory cfsDir) throws IOException {\n    long nextNormSeek = SegmentMerger.NORMS_HEADER.length; //skip header (header unused for now)\n    int maxDoc = maxDoc();\n    for (int i = 0; i < fieldInfos.size(); i++) {\n      FieldInfo fi = fieldInfos.fieldInfo(i);\n      if (fi.isIndexed && !fi.omitNorms) {\n        Directory d = directory();\n        String fileName = si.getNormFileName(fi.number);\n        if (!si.hasSeparateNorms(fi.number)) {\n          d = cfsDir;\n        }\n        \n        // singleNormFile means multiple norms share this file\n        boolean singleNormFile = fileName.endsWith(\".\" + IndexFileNames.NORMS_EXTENSION);\n        IndexInput normInput = null;\n        long normSeek;\n\n        if (singleNormFile) {\n          normSeek = nextNormSeek;\n          if (singleNormStream==null) {\n            singleNormStream = d.openInput(fileName);\n          }\n          // All norms in the .nrm file can share a single IndexInput since\n          // they are only used in a synchronized context.\n          // If this were to change in the future, a clone could be done here.\n          normInput = singleNormStream;\n        } else {\n          normSeek = 0;\n          normInput = d.openInput(fileName);\n        }\n\n        norms.put(fi.name, new Norm(normInput, fi.number, normSeek));\n        nextNormSeek += maxDoc; // increment also if some norms are separate\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e971ba25509e21a130fef61f0687be0446ca27a0":["6263f219dcdfc6e861ecffaecf5e1e195f1aaaa7"],"950f3c7592cb559e2534e5089c78833250e156a3":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"53df68381fe22c8eaf758533d0d5e1db43b925ac":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"6263f219dcdfc6e861ecffaecf5e1e195f1aaaa7":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["53df68381fe22c8eaf758533d0d5e1db43b925ac"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["950f3c7592cb559e2534e5089c78833250e156a3"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["e971ba25509e21a130fef61f0687be0446ca27a0"],"f6dba7919de4ff4ed6ff17f90619203772722f08":["111f5f9f92c974cb15ad5a47e0caec190ca207b7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"111f5f9f92c974cb15ad5a47e0caec190ca207b7":["8969a184df55d25d61e85be785987fbf830d4028"],"8969a184df55d25d61e85be785987fbf830d4028":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6dba7919de4ff4ed6ff17f90619203772722f08"]},"commit2Childs":{"e971ba25509e21a130fef61f0687be0446ca27a0":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"950f3c7592cb559e2534e5089c78833250e156a3":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"53df68381fe22c8eaf758533d0d5e1db43b925ac":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"6263f219dcdfc6e861ecffaecf5e1e195f1aaaa7":["e971ba25509e21a130fef61f0687be0446ca27a0"],"8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1":["53df68381fe22c8eaf758533d0d5e1db43b925ac"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["6263f219dcdfc6e861ecffaecf5e1e195f1aaaa7"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["8969a184df55d25d61e85be785987fbf830d4028"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["950f3c7592cb559e2534e5089c78833250e156a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fb95844e4ba5160067c64c5eb1cd8a09f7a94f1"],"f6dba7919de4ff4ed6ff17f90619203772722f08":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"111f5f9f92c974cb15ad5a47e0caec190ca207b7":["f6dba7919de4ff4ed6ff17f90619203772722f08"],"8969a184df55d25d61e85be785987fbf830d4028":["111f5f9f92c974cb15ad5a47e0caec190ca207b7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}