{"path":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","commits":[{"id":"733e01764d06768700a194141bccb026ff24bb29","date":1357643774,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"/dev/null","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 64 * _TestUtil.nextInt(random(), 1, 1 << 12);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      DataInput in = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      if (random().nextBoolean()) {\n        byte[] buf = new byte[(int) fp];\n        in.readBytes(buf, 0, (int) fp);\n        ((IndexInput) in).close();\n        in = new ByteArrayDataInput(buf);\n      }\n      final BlockPackedReader reader = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], reader.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = reader.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, reader.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReader reader2 = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        reader2.skip(skip);\n        i += skip;\n        assertEquals(i, reader2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], reader2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof IndexInput) {\n        ((IndexInput) in).close();\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"/dev/null","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 64 * _TestUtil.nextInt(random(), 1, 1 << 12);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      DataInput in = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      if (random().nextBoolean()) {\n        byte[] buf = new byte[(int) fp];\n        in.readBytes(buf, 0, (int) fp);\n        ((IndexInput) in).close();\n        in = new ByteArrayDataInput(buf);\n      }\n      final BlockPackedReader reader = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], reader.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = reader.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, reader.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReader reader2 = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        reader2.skip(skip);\n        i += skip;\n        assertEquals(i, reader2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], reader2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof IndexInput) {\n        ((IndexInput) in).close();\n      }\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37b84753dc1f66eba4973779932885fe42cde001","date":1358812051,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << _TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      assertEquals(in1.getFilePointer(), in1.length());\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 64 * _TestUtil.nextInt(random(), 1, 1 << 12);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      DataInput in = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      if (random().nextBoolean()) {\n        byte[] buf = new byte[(int) fp];\n        in.readBytes(buf, 0, (int) fp);\n        ((IndexInput) in).close();\n        in = new ByteArrayDataInput(buf);\n      }\n      final BlockPackedReader reader = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], reader.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = reader.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, reader.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReader reader2 = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        reader2.skip(skip);\n        i += skip;\n        assertEquals(i, reader2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], reader2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof IndexInput) {\n        ((IndexInput) in).close();\n      }\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"025d2f86befdf728996c337b074538439a26636c","date":1359107420,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << _TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << _TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      assertEquals(in1.getFilePointer(), in1.length());\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << _TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 64 * _TestUtil.nextInt(random(), 1, 1 << 12);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      DataInput in = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      if (random().nextBoolean()) {\n        byte[] buf = new byte[(int) fp];\n        in.readBytes(buf, 0, (int) fp);\n        ((IndexInput) in).close();\n        in = new ByteArrayDataInput(buf);\n      }\n      final BlockPackedReader reader = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], reader.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = reader.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, reader.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReader reader2 = new BlockPackedReader(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        reader2.skip(skip);\n        i += skip;\n        assertEquals(i, reader2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], reader2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        reader2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof IndexInput) {\n        ((IndexInput) in).close();\n      }\n      dir.close();\n    }\n  }\n\n","bugFix":["733e01764d06768700a194141bccb026ff24bb29"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << _TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + _TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(_TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = _TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3","date":1401710950,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize, PackedInts.COMPACT);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8106bc60c7452250f84c65cdb43ab6b1d8eb1534","date":1401906364,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize, PackedInts.COMPACT);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it.next();\n      });\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it2.skip(1);\n      });\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it.next();\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      try {\n        it2.skip(1);\n        assertTrue(false);\n      } catch (IOException e) {\n        // OK\n      }\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["733e01764d06768700a194141bccb026ff24bb29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"617d6d4150e0fb2acef8980ce51e3b8e628fb200","date":1580326292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts#testBlockPackedReaderWriter().mjava","sourceNew":"  public void testBlockPackedReaderWriter() throws IOException {\n    Random random = random();\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random, 6, 18);\n      final int valueCount;\n      if (TEST_NIGHTLY) {\n        valueCount = random.nextInt(1 << 18);\n      } else {\n        valueCount = random.nextInt(1 << 15);\n      }\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely(random) ? random.nextInt(256) : rarely(random) ? -5 : random.nextLong();\n          bpv = random.nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random.nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random, 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random.nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random.nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random, 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it.next();\n      });\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random, 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it2.skip(1);\n      });\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testBlockPackedReaderWriter() throws IOException {\n    final int iters = atLeast(2);\n    for (int iter = 0; iter < iters; ++iter) {\n      final int blockSize = 1 << TestUtil.nextInt(random(), 6, 18);\n      final int valueCount = random().nextInt(1 << 18);\n      final long[] values = new long[valueCount];\n      long minValue = 0;\n      int bpv = 0;\n      for (int i = 0; i < valueCount; ++i) {\n        if (i % blockSize == 0) {\n          minValue = rarely() ? random().nextInt(256) : rarely() ? -5 : random().nextLong();\n          bpv = random().nextInt(65);\n        }\n        if (bpv == 0) {\n          values[i] = minValue;\n        } else if (bpv == 64) {\n          values[i] = random().nextLong();\n        } else {\n          values[i] = minValue + TestUtil.nextLong(random(), 0, (1L << bpv) - 1);\n        }\n      }\n  \n      final Directory dir = newDirectory();\n      final IndexOutput out = dir.createOutput(\"out.bin\", IOContext.DEFAULT);\n      final BlockPackedWriter writer = new BlockPackedWriter(out, blockSize);\n      for (int i = 0; i < valueCount; ++i) {\n        assertEquals(i, writer.ord());\n        writer.add(values[i]);\n      }\n      assertEquals(valueCount, writer.ord());\n      writer.finish();\n      assertEquals(valueCount, writer.ord());\n      final long fp = out.getFilePointer();\n      out.close();\n\n      IndexInput in1 = dir.openInput(\"out.bin\", IOContext.DEFAULT);\n      byte[] buf = new byte[(int) fp];\n      in1.readBytes(buf, 0, (int) fp);\n      in1.seek(0L);\n      ByteArrayDataInput in2 = new ByteArrayDataInput(buf);\n      final DataInput in = random().nextBoolean() ? in1 : in2;\n      final BlockPackedReaderIterator it = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      for (int i = 0; i < valueCount; ) {\n        if (random().nextBoolean()) {\n          assertEquals(\"\" + i, values[i], it.next());\n          ++i;\n        } else {\n          final LongsRef nextValues = it.next(TestUtil.nextInt(random(), 1, 1024));\n          for (int j = 0; j < nextValues.length; ++j) {\n            assertEquals(\"\" + (i + j), values[i + j], nextValues.longs[nextValues.offset + j]);\n          }\n          i += nextValues.length;\n        }\n        assertEquals(i, it.ord());\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it.next();\n      });\n\n      if (in instanceof ByteArrayDataInput) {\n        ((ByteArrayDataInput) in).setPosition(0);\n      } else {\n        ((IndexInput) in).seek(0L);\n      }\n      final BlockPackedReaderIterator it2 = new BlockPackedReaderIterator(in, PackedInts.VERSION_CURRENT, blockSize, valueCount);\n      int i = 0;\n      while (true) {\n        final int skip = TestUtil.nextInt(random(), 0, valueCount - i);\n        it2.skip(skip);\n        i += skip;\n        assertEquals(i, it2.ord());\n        if (i == valueCount) {\n          break;\n        } else {\n          assertEquals(values[i], it2.next());\n          ++i;\n        }\n      }\n      assertEquals(fp, in instanceof ByteArrayDataInput ? ((ByteArrayDataInput) in).getPosition() : ((IndexInput) in).getFilePointer());\n      expectThrows(IOException.class, () -> {\n        it2.skip(1);\n      });\n\n      in1.seek(0L);\n      final BlockPackedReader reader = new BlockPackedReader(in1, PackedInts.VERSION_CURRENT, blockSize, valueCount, random().nextBoolean());\n      assertEquals(in1.getFilePointer(), in1.length());\n      for (i = 0; i < valueCount; ++i) {\n        assertEquals(\"i=\" + i, values[i], reader.get(i));\n      }\n      in1.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["733e01764d06768700a194141bccb026ff24bb29","025d2f86befdf728996c337b074538439a26636c"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"733e01764d06768700a194141bccb026ff24bb29":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"37b84753dc1f66eba4973779932885fe42cde001":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"05fe562aa248790944d43cdd478f512572835ba0":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"025d2f86befdf728996c337b074538439a26636c":["37b84753dc1f66eba4973779932885fe42cde001"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["05fe562aa248790944d43cdd478f512572835ba0"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","733e01764d06768700a194141bccb026ff24bb29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"]},"commit2Childs":{"d4d69c535930b5cce125cff868d40f6373dc27d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"733e01764d06768700a194141bccb026ff24bb29":["d4d69c535930b5cce125cff868d40f6373dc27d4","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["733e01764d06768700a194141bccb026ff24bb29","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"37b84753dc1f66eba4973779932885fe42cde001":["025d2f86befdf728996c337b074538439a26636c"],"025d2f86befdf728996c337b074538439a26636c":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"05fe562aa248790944d43cdd478f512572835ba0":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["05fe562aa248790944d43cdd478f512572835ba0"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["37b84753dc1f66eba4973779932885fe42cde001"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}