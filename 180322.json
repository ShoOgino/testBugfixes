{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b","date":1373283040,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":["4d4f1b2c5601680b01c4bb95a43fe6fb73f03103"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getDate(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<String, Object>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925df739d8e5dfb8970b87f95aaa606aec04f50c","date":1403423333,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information except for BigDecimal and BigInteger\n            // which cannot be serialized by JavaBin/XML. See SOLR-6165\n            Object value = resultSet.getObject(colName);\n            if (value instanceof BigDecimal || value instanceof BigInteger) {\n              result.put(colName, value.toString());\n            } else {\n              result.put(colName, value);\n            }\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information\n            result.put(colName, resultSet.getObject(colName));\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dfb0649722008c1c976c2992bb9cce634dd2a44","date":1454246079,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow(ResultSet,boolean,List[String],Map[String,Integer]).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    protected Map<String,Object> getARow(ResultSet resultSet, boolean convertType, List<String> colNames,\n        Map<String,Integer> fieldNameVsType) {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information except for BigDecimal and BigInteger\n            // which cannot be serialized by JavaBin/XML. See SOLR-6165\n            Object value = resultSet.getObject(colName);\n            if (value instanceof BigDecimal || value instanceof BigInteger) {\n              result.put(colName, value.toString());\n            } else {\n              result.put(colName, value);\n            }\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information except for BigDecimal and BigInteger\n            // which cannot be serialized by JavaBin/XML. See SOLR-6165\n            Object value = resultSet.getObject(colName);\n            if (value instanceof BigDecimal || value instanceof BigInteger) {\n              result.put(colName, value.toString());\n            } else {\n              result.put(colName, value);\n            }\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow(ResultSet,boolean,List[String],Map[String,Integer]).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource.ResultSetIterator#getARow().mjava","sourceNew":"    protected Map<String,Object> getARow(ResultSet resultSet, boolean convertType, List<String> colNames,\n        Map<String,Integer> fieldNameVsType) {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information except for BigDecimal and BigInteger\n            // which cannot be serialized by JavaBin/XML. See SOLR-6165\n            Object value = resultSet.getObject(colName);\n            if (value instanceof BigDecimal || value instanceof BigInteger) {\n              result.put(colName, value.toString());\n            } else {\n              result.put(colName, value);\n            }\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","sourceOld":"    private Map<String, Object> getARow() {\n      if (resultSet == null)\n        return null;\n      Map<String, Object> result = new HashMap<>();\n      for (String colName : colNames) {\n        try {\n          if (!convertType) {\n            // Use underlying database's type information except for BigDecimal and BigInteger\n            // which cannot be serialized by JavaBin/XML. See SOLR-6165\n            Object value = resultSet.getObject(colName);\n            if (value instanceof BigDecimal || value instanceof BigInteger) {\n              result.put(colName, value.toString());\n            } else {\n              result.put(colName, value);\n            }\n            continue;\n          }\n\n          Integer type = fieldNameVsType.get(colName);\n          if (type == null)\n            type = Types.VARCHAR;\n          switch (type) {\n            case Types.INTEGER:\n              result.put(colName, resultSet.getInt(colName));\n              break;\n            case Types.FLOAT:\n              result.put(colName, resultSet.getFloat(colName));\n              break;\n            case Types.BIGINT:\n              result.put(colName, resultSet.getLong(colName));\n              break;\n            case Types.DOUBLE:\n              result.put(colName, resultSet.getDouble(colName));\n              break;\n            case Types.DATE:\n              result.put(colName, resultSet.getTimestamp(colName));\n              break;\n            case Types.BOOLEAN:\n              result.put(colName, resultSet.getBoolean(colName));\n              break;\n            case Types.BLOB:\n              result.put(colName, resultSet.getBytes(colName));\n              break;\n            default:\n              result.put(colName, resultSet.getString(colName));\n              break;\n          }\n        } catch (SQLException e) {\n          logError(\"Error reading data \", e);\n          wrapAndThrow(SEVERE, e, \"Error reading data from database\");\n        }\n      }\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b"],"6dfb0649722008c1c976c2992bb9cce634dd2a44":["925df739d8e5dfb8970b87f95aaa606aec04f50c"],"a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b":["c26f00b574427b55127e869b935845554afde1fa"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["c26f00b574427b55127e869b935845554afde1fa","a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["925df739d8e5dfb8970b87f95aaa606aec04f50c","6dfb0649722008c1c976c2992bb9cce634dd2a44"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dfb0649722008c1c976c2992bb9cce634dd2a44"],"925df739d8e5dfb8970b87f95aaa606aec04f50c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["925df739d8e5dfb8970b87f95aaa606aec04f50c"],"a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"6dfb0649722008c1c976c2992bb9cce634dd2a44":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0c5a98d3a49f05ff6367c6cf378e87cc2eba59b","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","c26f00b574427b55127e869b935845554afde1fa"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"925df739d8e5dfb8970b87f95aaa606aec04f50c":["6dfb0649722008c1c976c2992bb9cce634dd2a44","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}