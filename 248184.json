{"path":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"/dev/null","sourceNew":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val = toInternal(externalVal);\n    if (val==null) return null;\n    Field f =  new Field(field.getName(), val, field.stored(), field.indexed(), isTokenized());\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c7040334a42400ca67824559be90a1f2f2c9e63","date":1142276541,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val = toInternal(externalVal);\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val = toInternal(externalVal);\n    if (val==null) return null;\n    Field f =  new Field(field.getName(), val, field.stored(), field.indexed(), isTokenized());\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c73023b4fbbcf25a8b75cd13a421f65b4ca7970","date":1145371109,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val = toInternal(externalVal);\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f80211c8197bb79dae092b6ea66a4a839be2add","date":1149580420,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  // used for adding a document when a field needs to be created from a type and a string\n  // by default, the indexed value is the same as the stored value (taken from toInternal())\n  // Having a different representation for external, internal, and indexed would present quite\n  // a few problems given the current Lucene architecture.  An analyzer for adding docs would\n  // need to translate internal->indexed while an analyzer for querying would need to\n  // translate external->indexed.\n  //\n  // The only other alternative to having internal==indexed would be to have\n  // internal==external.\n  // In this case, toInternal should convert to the indexed representation,\n  // toExternal() should do nothing, and createField() should *not* call toInternal,\n  // but use the external value and set tokenized=true to get Lucene to convert\n  // to the internal(indexed) form.\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"643874bf353956224e8a9402dd956ccf9c20815a","date":1150480129,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    Field.TermVector ftv = Field.TermVector.NO;\n    if (field.storeTermPositions() && field.storeTermOffsets())\n      ftv = Field.TermVector.WITH_POSITIONS_OFFSETS;\n    else if (field.storeTermPositions())\n      ftv = Field.TermVector.WITH_POSITIONS;\n    else if (field.storeTermOffsets())\n      ftv = Field.TermVector.WITH_OFFSETS;            \n    else if (field.storeTermVector())\n      ftv = Field.TermVector.YES;\n\n    Field f =  new Field(field.getName(),val,\n        field.stored() ? Field.Store.YES : Field.Store.NO ,\n        field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : \n                           Field.Index.UN_TOKENIZED) : Field.Index.NO,\n        ftv);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    Field f =  new Field(field.getName(),val,\n            field.stored() ? Field.Store.YES : Field.Store.NO ,\n            field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : Field.Index.UN_TOKENIZED)\n                    : Field.Index.NO);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b51f7d9bf6817181cc522f0b19fd3b515a6fc689","date":1157569889,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    Field.TermVector ftv = Field.TermVector.NO;\n    if (field.storeTermPositions() && field.storeTermOffsets())\n      ftv = Field.TermVector.WITH_POSITIONS_OFFSETS;\n    else if (field.storeTermPositions())\n      ftv = Field.TermVector.WITH_POSITIONS;\n    else if (field.storeTermOffsets())\n      ftv = Field.TermVector.WITH_OFFSETS;            \n    else if (field.storeTermVector())\n      ftv = Field.TermVector.YES;\n\n    Field f =  new Field(field.getName(),val,\n        field.stored() ? Field.Store.YES : Field.Store.NO ,\n        field.indexed() ? (isTokenized() ? Field.Index.TOKENIZED : \n                           Field.Index.UN_TOKENIZED) : Field.Index.NO,\n        ftv);\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a387fc4d48708013611d08ecb03b4d49efe249d6","date":1178647412,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.finest(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.finest(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException(500, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.finest(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.finest(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1a4c3e86c634e830c1a7217c6bc2b5dc709259f","date":1235359663,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTf(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":["d72e3710bede9618eb9b2b5c6936369f3d3f9579"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc1b28aad2f60efdbcf8cc3f357beea77ba5fba9","date":1235455657,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTf(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (NumberFormatException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTf(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d72e3710bede9618eb9b2b5c6936369f3d3f9579","date":1239534189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTermFreqAndPositions(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTf(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":["d1a4c3e86c634e830c1a7217c6bc2b5dc709259f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07058770c66507f0f25d5ef5ca652d06602b2663","date":1248469298,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTermFreqAndPositions(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n        return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTermFreqAndPositions(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abec2fd822be07fc74ef5ba3609b9c5625a87d6d","date":1261659802,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   *\n   *\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    if (!field.indexed() && !field.stored()) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    return createField(field.getName(), val, getFieldStore(field, val),\n            getFieldIndex(field, val), getFieldTermVec(field, val), field.omitNorms(),\n            field.omitTf(), boost);\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n    if (!field.indexed() && !field.stored()) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n\n\n    Field f = new Field(field.getName(),\n                        val,\n                        getFieldStore(field, val),\n                        getFieldIndex(field, val),\n                        getFieldTermVec(field, val));\n    f.setOmitNorms(field.omitNorms());\n    f.setOmitTermFreqAndPositions(field.omitTf());\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","pathOld":"src/java/org/apache/solr/schema/FieldType#createField(SchemaField,String,float).mjava","sourceNew":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   *\n   *\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    if (!field.indexed() && !field.stored()) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    return createField(field.getName(), val, getFieldStore(field, val),\n            getFieldIndex(field, val), getFieldTermVec(field, val), field.omitNorms(),\n            field.omitTf(), boost);\n  }\n\n","sourceOld":"  /**\n   * Used for adding a document when a field needs to be created from a\n   * type and a string.\n   *\n   * <p>\n   * By default, the indexed value is the same as the stored value\n   * (taken from toInternal()).   Having a different representation for\n   * external, internal, and indexed would present quite a few problems\n   * given the current Lucene architecture.  An analyzer for adding docs\n   * would need to translate internal->indexed while an analyzer for\n   * querying would need to translate external-&gt;indexed.\n   * </p>\n   * <p>\n   * The only other alternative to having internal==indexed would be to have\n   * internal==external.   In this case, toInternal should convert to\n   * the indexed representation, toExternal() should do nothing, and\n   * createField() should *not* call toInternal, but use the external\n   * value and set tokenized=true to get Lucene to convert to the\n   * internal(indexed) form.\n   * </p>\n   *\n   * :TODO: clean up and clarify this explanation.\n   *\n   * @see #toInternal\n   *\n   *\n   */\n  public Field createField(SchemaField field, String externalVal, float boost) {\n    if (!field.indexed() && !field.stored()) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    String val;\n    try {\n      val = toInternal(externalVal);\n    } catch (RuntimeException e) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"Error while creating field '\" + field + \"' from value '\" + externalVal + \"'\", e, false);\n    }\n    if (val==null) return null;\n\n    return createField(field.getName(), val, getFieldStore(field, val),\n            getFieldIndex(field, val), getFieldTermVec(field, val), field.omitNorms(),\n            field.omitTf(), boost);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["07058770c66507f0f25d5ef5ca652d06602b2663"],"07058770c66507f0f25d5ef5ca652d06602b2663":["d72e3710bede9618eb9b2b5c6936369f3d3f9579"],"fc1b28aad2f60efdbcf8cc3f357beea77ba5fba9":["d1a4c3e86c634e830c1a7217c6bc2b5dc709259f"],"d72e3710bede9618eb9b2b5c6936369f3d3f9579":["fc1b28aad2f60efdbcf8cc3f357beea77ba5fba9"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"a387fc4d48708013611d08ecb03b4d49efe249d6":["b51f7d9bf6817181cc522f0b19fd3b515a6fc689"],"7c7040334a42400ca67824559be90a1f2f2c9e63":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"643874bf353956224e8a9402dd956ccf9c20815a":["2f80211c8197bb79dae092b6ea66a4a839be2add"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["a387fc4d48708013611d08ecb03b4d49efe249d6"],"4c73023b4fbbcf25a8b75cd13a421f65b4ca7970":["7c7040334a42400ca67824559be90a1f2f2c9e63"],"b51f7d9bf6817181cc522f0b19fd3b515a6fc689":["643874bf353956224e8a9402dd956ccf9c20815a"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"d1a4c3e86c634e830c1a7217c6bc2b5dc709259f":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"2f80211c8197bb79dae092b6ea66a4a839be2add":["4c73023b4fbbcf25a8b75cd13a421f65b4ca7970"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"abec2fd822be07fc74ef5ba3609b9c5625a87d6d":["ad94625fb8d088209f46650c8097196fec67f00c"],"07058770c66507f0f25d5ef5ca652d06602b2663":["abec2fd822be07fc74ef5ba3609b9c5625a87d6d"],"fc1b28aad2f60efdbcf8cc3f357beea77ba5fba9":["d72e3710bede9618eb9b2b5c6936369f3d3f9579"],"d72e3710bede9618eb9b2b5c6936369f3d3f9579":["07058770c66507f0f25d5ef5ca652d06602b2663"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a387fc4d48708013611d08ecb03b4d49efe249d6":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"7c7040334a42400ca67824559be90a1f2f2c9e63":["4c73023b4fbbcf25a8b75cd13a421f65b4ca7970"],"643874bf353956224e8a9402dd956ccf9c20815a":["b51f7d9bf6817181cc522f0b19fd3b515a6fc689"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["d1a4c3e86c634e830c1a7217c6bc2b5dc709259f"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"4c73023b4fbbcf25a8b75cd13a421f65b4ca7970":["2f80211c8197bb79dae092b6ea66a4a839be2add"],"b51f7d9bf6817181cc522f0b19fd3b515a6fc689":["a387fc4d48708013611d08ecb03b4d49efe249d6"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["7c7040334a42400ca67824559be90a1f2f2c9e63"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"d1a4c3e86c634e830c1a7217c6bc2b5dc709259f":["fc1b28aad2f60efdbcf8cc3f357beea77ba5fba9"],"2f80211c8197bb79dae092b6ea66a4a839be2add":["643874bf353956224e8a9402dd956ccf9c20815a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}