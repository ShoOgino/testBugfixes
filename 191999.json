{"path":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f598c898a474a16f5313a79aa0f0870baa52df2","date":1328889626,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n\n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();  // only used if box==true\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      return result;\n    }\n\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3859e567816d5987602f2a7ae2469fcdf17f745e","date":1329895924,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n    \n    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(options.units.earthRadius());\n    SpatialContext ctx = new SimpleSpatialContext(options.units,distCalc,null);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, options.distance, ctx);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e47768b261c28e7e6032060e8331475c81057953","date":1331681297,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n    \n    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(options.units.earthRadius());\n    SpatialContext ctx = new SimpleSpatialContext(options.units,distCalc,null);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, options.distance, ctx);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidGeoException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n\n    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;\n    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;\n    //Get the distance\n\n    double[] tmp = new double[2];\n    //these calculations aren't totally accurate, but it should be good enough\n    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.\n    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);\n    //This returns the point as radians, but we need degrees b/c that is what the field is stored as\n    double ur_lat = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp\n    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);\n    double ur_lon = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);\n    double ll_lat = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;\n    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);\n    double ll_lon = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;\n    \n\n    //TODO: can we reuse our bearing calculations?\n    double angDist = DistanceUtils.angularDistance(options.distance,\n            options.radius);//in radians\n\n    double latMin = -90.0, latMax = 90.0, lonMin = -180.0, lonMax = 180.0;\n    double lon2Min = -180.0, lon2Max = 180.0;  // optional second longitude restriction\n\n    // for the poles, do something slightly different - a polar \"cap\".\n    // Also, note point[LAT] is in radians, but ur and ll are in degrees\n    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { // we cross the north pole\n      //we don't need a longitude boundary at all\n      latMin = Math.min(ll_lat, ur_lat);\n    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) { // we cross the south pole\n      latMax = Math.max(ll_lat, ur_lat);\n    } else {\n      // set the latitude restriction as normal\n      latMin = ll_lat;\n      latMax = ur_lat;\n\n      if (ll_lon > ur_lon) {\n         // we crossed the +-180 deg longitude... need to make\n        // range queries of (-180 TO ur) OR (ll TO 180)\n        lonMin = -180;\n        lonMax = ur_lon;\n        lon2Min = ll_lon;\n        lon2Max = 180;\n      } else {\n        lonMin = ll_lon;\n        lonMax = ur_lon;\n      }\n    }\n\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8726333bca804ff1ebd79d1310561641b5dfcb9e","date":1331697951,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(options.units.earthRadius());\n    SpatialContext ctx = new SimpleSpatialContext(options.units,distCalc,null);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, options.distance, ctx);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LON);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LONG];\n    \n    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(options.units.earthRadius());\n    SpatialContext ctx = new SimpleSpatialContext(options.units,distCalc,null);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, options.distance, ctx);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LONG);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LON);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(options.units.earthRadius());\n    SpatialContext ctx = new SimpleSpatialContext(options.units,distCalc,null);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, options.distance, ctx);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LON);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    IndexSchema schema = parser.getReq().getSchema();\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT, schema);\n    SchemaField lonField = subField(options.field, LON, schema);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT);\n    SchemaField lonField = subField(options.field, LON);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003","date":1390592414,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    Point point = SpatialUtils.parsePointSolrException(options.pointStr, SpatialContext.GEO);\n\n    // lat & lon in degrees\n    double latCenter = point.getY();\n    double lonCenter = point.getX();\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    IndexSchema schema = parser.getReq().getSchema();\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latSF = subField(options.field, LAT, schema);\n    SchemaField lonSF = subField(options.field, LON, schema);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latSF.getType().getRangeQuery(parser, latSF,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latSF.getType().getValueSource(latSF, parser);\n    spatial.lonSource = lonSF.getType().getValueSource(lonSF, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    double[] point = null;\n    try {\n      point = ParseUtils.parseLatitudeLongitude(options.pointStr);\n    } catch (InvalidShapeException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n\n    // lat & lon in degrees\n    double latCenter = point[LAT];\n    double lonCenter = point[LON];\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    IndexSchema schema = parser.getReq().getSchema();\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latField = subField(options.field, LAT, schema);\n    SchemaField lonField = subField(options.field, LON, schema);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latField.getType().getRangeQuery(parser, latField,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonField.getType().getRangeQuery(parser, lonField,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latField.getType().getValueSource(latField, parser);\n    spatial.lonSource = lonField.getType().getValueSource(lonField, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/LatLonType#createSpatialQuery(QParser,SpatialOptions).mjava","sourceNew":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    Point point = SpatialUtils.parsePointSolrException(options.pointStr, SpatialContext.GEO);\n\n    // lat & lon in degrees\n    double latCenter = point.getY();\n    double lonCenter = point.getX();\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    IndexSchema schema = parser.getReq().getSchema();\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latSF = subField(options.field, LAT, schema);\n    SchemaField lonSF = subField(options.field, LON, schema);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery.Builder result = new BooleanQuery.Builder();\n\n      Query latRange = latSF.getType().getRangeQuery(parser, latSF,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery.Builder bothLons = new BooleanQuery.Builder();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons.build();\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result.build();\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latSF.getType().getValueSource(latSF, parser);\n    spatial.lonSource = lonSF.getType().getValueSource(lonSF, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","sourceOld":"  @Override\n  public Query createSpatialQuery(QParser parser, SpatialOptions options) {\n    Point point = SpatialUtils.parsePointSolrException(options.pointStr, SpatialContext.GEO);\n\n    // lat & lon in degrees\n    double latCenter = point.getY();\n    double lonCenter = point.getX();\n    \n    double distDeg = DistanceUtils.dist2Degrees(options.distance, options.radius);\n    Rectangle bbox = DistanceUtils.calcBoxByDistFromPtDEG(latCenter, lonCenter, distDeg, SpatialContext.GEO, null);\n    double latMin = bbox.getMinY();\n    double latMax = bbox.getMaxY();\n    double lonMin, lonMax, lon2Min, lon2Max;\n    if (bbox.getCrossesDateLine()) {\n       lonMin = -180;\n       lonMax = bbox.getMaxX();\n       lon2Min = bbox.getMinX();\n       lon2Max = 180;\n    } else {\n       lonMin = bbox.getMinX();\n       lonMax = bbox.getMaxX();\n       lon2Min = -180;\n       lon2Max = 180;\n    }\n    \n    IndexSchema schema = parser.getReq().getSchema();\n    \n    // Now that we've figured out the ranges, build them!\n    SchemaField latSF = subField(options.field, LAT, schema);\n    SchemaField lonSF = subField(options.field, LON, schema);\n\n    SpatialDistanceQuery spatial = new SpatialDistanceQuery();\n\n\n    if (options.bbox) {\n      BooleanQuery result = new BooleanQuery();\n\n      Query latRange = latSF.getType().getRangeQuery(parser, latSF,\n                String.valueOf(latMin),\n                String.valueOf(latMax),\n                true, true);\n      result.add(latRange, BooleanClause.Occur.MUST);\n\n      if (lonMin != -180 || lonMax != 180) {\n        Query lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lonMin),\n                String.valueOf(lonMax),\n                true, true);\n        if (lon2Min != -180 || lon2Max != 180) {\n          // another valid longitude range\n          BooleanQuery bothLons = new BooleanQuery();\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = lonSF.getType().getRangeQuery(parser, lonSF,\n                String.valueOf(lon2Min),\n                String.valueOf(lon2Max),\n                true, true);\n          bothLons.add(lonRange, BooleanClause.Occur.SHOULD);\n\n          lonRange = bothLons;\n        }\n\n        result.add(lonRange, BooleanClause.Occur.MUST);\n      }\n\n      spatial.bboxQuery = result;\n    }\n\n\n    spatial.origField = options.field.getName();\n    spatial.latSource = latSF.getType().getValueSource(latSF, parser);\n    spatial.lonSource = lonSF.getType().getValueSource(lonSF, parser);\n    spatial.latMin = latMin;\n    spatial.latMax = latMax;\n    spatial.lonMin = lonMin;\n    spatial.lonMax = lonMax;\n    spatial.lon2Min = lon2Min;\n    spatial.lon2Max = lon2Max;\n    spatial.lon2 = lon2Min != -180 || lon2Max != 180;\n\n    spatial.latCenter = latCenter;\n    spatial.lonCenter = lonCenter;\n    spatial.dist = options.distance;\n    spatial.planetRadius = options.radius;\n\n    spatial.calcDist = !options.bbox;\n\n    return spatial;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"da956410d7a790f567af4e7e94584fb0930212f2":["8726333bca804ff1ebd79d1310561641b5dfcb9e"],"8726333bca804ff1ebd79d1310561641b5dfcb9e":["e47768b261c28e7e6032060e8331475c81057953"],"08970e5b8411182a29412c177eff67ec1110095b":["da956410d7a790f567af4e7e94584fb0930212f2"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["08970e5b8411182a29412c177eff67ec1110095b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f598c898a474a16f5313a79aa0f0870baa52df2":["c26f00b574427b55127e869b935845554afde1fa"],"e47768b261c28e7e6032060e8331475c81057953":["0f598c898a474a16f5313a79aa0f0870baa52df2","3859e567816d5987602f2a7ae2469fcdf17f745e"],"3859e567816d5987602f2a7ae2469fcdf17f745e":["0f598c898a474a16f5313a79aa0f0870baa52df2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["0f598c898a474a16f5313a79aa0f0870baa52df2"],"da956410d7a790f567af4e7e94584fb0930212f2":["08970e5b8411182a29412c177eff67ec1110095b"],"8726333bca804ff1ebd79d1310561641b5dfcb9e":["da956410d7a790f567af4e7e94584fb0930212f2"],"08970e5b8411182a29412c177eff67ec1110095b":["6bc65e9e84ac8f81b0861d2c7d8f56715adbf003"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"6bc65e9e84ac8f81b0861d2c7d8f56715adbf003":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"0f598c898a474a16f5313a79aa0f0870baa52df2":["e47768b261c28e7e6032060e8331475c81057953","3859e567816d5987602f2a7ae2469fcdf17f745e"],"e47768b261c28e7e6032060e8331475c81057953":["8726333bca804ff1ebd79d1310561641b5dfcb9e"],"3859e567816d5987602f2a7ae2469fcdf17f745e":["e47768b261c28e7e6032060e8331475c81057953"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}