{"path":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","commits":[{"id":"f1d5408c3fa04da2652aa3db3f21d700f7111cef","date":1360854465,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75acb84fc2a64c745d0d4afec664f5e4b2218e73","date":1360954824,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b41f996b22bd5518650f897d050088ff808ec03","date":1360969107,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = _TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = _TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = _TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = _TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = _TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = _TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        doc.add(newStringField(\"string\", s, Field.Store.NO));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        // Can only use sort missing if the DVFormat\n        // supports docsWithField:\n        sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n        missingIsNull = defaultCodecSupportsDocsWithField();\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n        sortMissingLast = random().nextBoolean();\n        missingIsNull = true;\n      }\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"400558e34d57baf6a8e8c42d60fc1a87b5acb596","date":1405940665,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    testRandomStringSort(SortField.Type.STRING);\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75acb84fc2a64c745d0d4afec664f5e4b2218e73":["f1d5408c3fa04da2652aa3db3f21d700f7111cef"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["75acb84fc2a64c745d0d4afec664f5e4b2218e73","7615b855702e008d91a95a2578bf05d27372f599"],"6613659748fe4411a7dcf85266e55db1f95f7315":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"3b41f996b22bd5518650f897d050088ff808ec03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","75acb84fc2a64c745d0d4afec664f5e4b2218e73"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f1d5408c3fa04da2652aa3db3f21d700f7111cef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7615b855702e008d91a95a2578bf05d27372f599":["75acb84fc2a64c745d0d4afec664f5e4b2218e73"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"]},"commit2Childs":{"75acb84fc2a64c745d0d4afec664f5e4b2218e73":["27ab7b234eab0cbc020836989b96ed430e1065bb","3b41f996b22bd5518650f897d050088ff808ec03","7615b855702e008d91a95a2578bf05d27372f599"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["400558e34d57baf6a8e8c42d60fc1a87b5acb596","56572ec06f1407c066d6b7399413178b33176cd8"],"3b41f996b22bd5518650f897d050088ff808ec03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b41f996b22bd5518650f897d050088ff808ec03","f1d5408c3fa04da2652aa3db3f21d700f7111cef"],"f1d5408c3fa04da2652aa3db3f21d700f7111cef":["75acb84fc2a64c745d0d4afec664f5e4b2218e73"],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","3b41f996b22bd5518650f897d050088ff808ec03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}