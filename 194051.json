{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1","date":1517395742,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            });\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            });\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            });\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          targetNode = Assign.identifyNodes(ocmh.cloudManager,\n              clusterState,\n              new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()),\n              sourceReplica.getStr(COLLECTION_PROP),\n              message,\n              Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)),\n              replicaType == Replica.Type.NRT ? 1: 0,\n              replicaType == Replica.Type.TLOG ? 1 : 0,\n              replicaType == Replica.Type.PULL ? 1 : 0\n          ).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                    sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding \" + key + \", \" + watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for \" + addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapperRef = new AtomicReference<>();\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n          sessionWrapperRef.set(PolicyHelper.getLastSessionWrapper(true));\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n      PolicyHelper.SessionWrapper sw = sessionWrapperRef.get();\n      if (sw != null) sw.release();\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState, cloudConfig,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState, cloudConfig,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":3,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(ocmh.cloudManager, clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(ocmh.cloudManager, clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["e7b17e79a71117668ecbf8d3417c876e41396565"],"c526352db87264a72a7a9ad68c1b769b81e54305":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["e7b17e79a71117668ecbf8d3417c876e41396565","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"4abf821a41a2fdca2a1dea148999931d22e20529":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1":["b94236357aaa22b76c10629851fe4e376e0cea82"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1","deea3439de4f487ae553317e50d5d641ca386374"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"deea3439de4f487ae553317e50d5d641ca386374":["135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"b94236357aaa22b76c10629851fe4e376e0cea82":["135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1"],"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"3f504512a03d978990cbff30db0522b354e846db":["c526352db87264a72a7a9ad68c1b769b81e54305"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["4abf821a41a2fdca2a1dea148999931d22e20529"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["3f504512a03d978990cbff30db0522b354e846db"],"135a17bf08af5eaa5db73b2de6d1e36ea2ecafa1":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}