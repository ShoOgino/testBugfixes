{"path":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","commits":[{"id":"7dcb0432bcb41451b41e9aaaabe99f5d208258fe","date":1493203108,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n\n        return new Partition(tempFile.getName(), part.count);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36a23c6fa37610e466602f47f4ddf1e7a8e702e5","date":1493213774,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","sourceNew":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n\n        return new Partition(tempFile.getName(), part.count);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7ef0a4739aaf193215e05da4f8f8054d4099141","date":1499937638,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","sourceNew":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/OfflineSorter.SortPartitionTask#call().mjava","sourceNew":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public Partition call() throws IOException {\n      try (IndexOutput tempFile = dir.createTempOutput(tempFileNamePrefix, \"sort\", IOContext.DEFAULT);\n           ByteSequencesWriter out = getWriter(tempFile, part.buffer.size());) {\n      \n        BytesRef spare;\n\n        long startMS = System.currentTimeMillis();\n        BytesRefIterator iter = part.buffer.iterator(comparator);\n        sortInfo.sortTimeMS.addAndGet(System.currentTimeMillis() - startMS);\n\n        int count = 0;\n        while ((spare = iter.next()) != null) {\n          assert spare.length <= Short.MAX_VALUE;\n          out.write(spare);\n          count++;\n        }\n\n        assert count == part.count;\n\n        CodecUtil.writeFooter(out.out);\n        part.buffer.clear();\n\n        return new Partition(tempFile.getName(), part.count);\n      } finally {\n        if (partitionsInRAM != null) {\n          partitionsInRAM.release();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["e9017cf144952056066919f1ebc7897ff9bd71b1","a7ef0a4739aaf193215e05da4f8f8054d4099141"],"a7ef0a4739aaf193215e05da4f8f8054d4099141":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7ef0a4739aaf193215e05da4f8f8054d4099141"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","7dcb0432bcb41451b41e9aaaabe99f5d208258fe"],"a7ef0a4739aaf193215e05da4f8f8054d4099141":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"36a23c6fa37610e466602f47f4ddf1e7a8e702e5":["e9017cf144952056066919f1ebc7897ff9bd71b1","a7ef0a4739aaf193215e05da4f8f8054d4099141"],"7dcb0432bcb41451b41e9aaaabe99f5d208258fe":["36a23c6fa37610e466602f47f4ddf1e7a8e702e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}