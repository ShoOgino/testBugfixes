{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":["b17c5c53627893d93f9261826cc6d9c447c5ee3a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec1f7d2f42d19b4ca07d5685b650ef589be4763f","date":1354814273,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);\n      if (seekStat == TermsEnum.SeekStatus.END)\n        break;\n      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        //If the next indexed term is the leaf marker, then add all of them\n        BytesRef nextCellTerm = termsEnum.next();\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          termsEnum.next();//move pointer to avoid potential redundant addDocs() below\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              //TODO should put more thought into implications of box vs point\n              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c659c37800c0dfd82fa025b5834f4ab065903d11","date":1361851047,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter#getDocIdSet(AtomicReaderContext,Bits).mjava","sourceNew":null,"sourceOld":"  @Override\n  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {\n    AtomicReader reader = ctx.reader();\n    OpenBitSet bits = new OpenBitSet(reader.maxDoc());\n    Terms terms = reader.terms(fieldName);\n    if (terms == null)\n      return null;\n    TermsEnum termsEnum = terms.iterator(null);\n    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls\n    Node scanCell = null;\n\n    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we\n    //  always advance forward through the termsEnum index.\n    LinkedList<Node> cells = new LinkedList<Node>(\n        grid.getWorldNode().getSubCells(queryShape) );\n\n    //This is a recursive algorithm that starts with one or more \"big\" cells, and then recursively dives down into the\n    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto\n    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given\n    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and\n    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either\n    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't\n    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),\n    // seeing which ones are within the query shape.\n    while(!cells.isEmpty()) {\n      final Node cell = cells.removeFirst();\n      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());\n      if (!termsEnum.seekExact(cellTerm, true))\n        continue;\n      if (cell.getLevel() == detailLevel || cell.isLeaf()) {\n        docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n        addDocs(docsEnum,bits);\n      } else {//any other intersection\n        assert cell.getLevel() < detailLevel; //assertions help clarify logic\n        assert !cell.isLeaf();\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        BytesRef nextCellTerm = termsEnum.next();\n        if (nextCellTerm == null)\n          break;\n        assert StringHelper.startsWith(nextCellTerm, cellTerm);\n        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          addDocs(docsEnum,bits);\n          //increment pointer to avoid potential redundant addDocs() below\n          nextCellTerm = termsEnum.next();\n          if (nextCellTerm == null)\n            break;\n        }\n\n        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.\n        // Scanning is a performance optimization trade-off.\n        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n        if (!scan) {\n          //Divide & conquer\n          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning\n        } else {\n          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.\n          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {\n            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);\n            int termLevel = scanCell.getLevel();\n            if (termLevel > detailLevel)\n              continue;\n            if (termLevel == detailLevel || scanCell.isLeaf()) {\n              Shape cShape;\n              //if this cell represents a point, use the cell center vs the box\n              // (points never have isLeaf())\n              if (termLevel == grid.getMaxLevels() && !scanCell.isLeaf())\n                cShape = scanCell.getCenter();\n              else\n                cShape = scanCell.getShape();\n              if(queryShape.relate(cShape) == SpatialRelation.DISJOINT)\n                continue;\n\n              docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n              addDocs(docsEnum,bits);\n            }\n          }//term loop\n        }\n      }\n    }//cell loop\n\n    return bits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["ec1f7d2f42d19b4ca07d5685b650ef589be4763f"],"da956410d7a790f567af4e7e94584fb0930212f2":["02331260bb246364779cb6f04919ca47900d01bb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["da956410d7a790f567af4e7e94584fb0930212f2","ec1f7d2f42d19b4ca07d5685b650ef589be4763f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["b89678825b68eccaf09e6ab71675fc0b0af1e099","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["b89678825b68eccaf09e6ab71675fc0b0af1e099","02331260bb246364779cb6f04919ca47900d01bb"],"ec1f7d2f42d19b4ca07d5685b650ef589be4763f":["da956410d7a790f567af4e7e94584fb0930212f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"02331260bb246364779cb6f04919ca47900d01bb":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c659c37800c0dfd82fa025b5834f4ab065903d11"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"da956410d7a790f567af4e7e94584fb0930212f2":["407687e67faf6e1f02a211ca078d8e3eed631027","ec1f7d2f42d19b4ca07d5685b650ef589be4763f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"ec1f7d2f42d19b4ca07d5685b650ef589be4763f":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640","407687e67faf6e1f02a211ca078d8e3eed631027"],"02331260bb246364779cb6f04919ca47900d01bb":["da956410d7a790f567af4e7e94584fb0930212f2","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c659c37800c0dfd82fa025b5834f4ab065903d11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}