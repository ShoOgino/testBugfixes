{"path":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"/dev/null","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiTermsEnum#reset(TermsEnumIndex[]).mjava","sourceNew":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","sourceOld":"  /** The terms array must be newly created TermsEnum, ie\n   *  {@link TermsEnum#next} has not yet been called. */\n  public TermsEnum reset(TermsEnumIndex[] termsEnumsIndex) throws IOException {\n    assert termsEnumsIndex.length <= top.length;\n    numSubs = 0;\n    numTop = 0;\n    termComp = null;\n    queue.clear();\n    for(int i=0;i<termsEnumsIndex.length;i++) {\n\n      final TermsEnumIndex termsEnumIndex = termsEnumsIndex[i];\n      assert termsEnumIndex != null;\n\n      // init our term comp\n      if (termComp == null) {\n        queue.termComp = termComp = termsEnumIndex.termsEnum.getComparator();\n      } else {\n        // We cannot merge sub-readers that have\n        // different TermComps\n        final Comparator<BytesRef> subTermComp = termsEnumIndex.termsEnum.getComparator();\n        if (subTermComp != null && !subTermComp.equals(termComp)) {\n          throw new IllegalStateException(\"sub-readers have different BytesRef.Comparators: \" + subTermComp + \" vs \" + termComp + \"; cannot merge\");\n        }\n      }\n\n      final BytesRef term = termsEnumIndex.termsEnum.next();\n      if (term != null) {\n        final TermsEnumWithSlice entry = subs[termsEnumIndex.subIndex];\n        entry.reset(termsEnumIndex.termsEnum, term);\n        queue.add(entry);\n        currentSubs[numSubs++] = entry;\n      } else {\n        // field has no terms\n      }\n    }\n\n    if (queue.size() == 0) {\n      return TermsEnum.EMPTY;\n    } else {\n      return this;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3242a09f703274d3b9283f2064a1a33064b53a1b":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3242a09f703274d3b9283f2064a1a33064b53a1b":[],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3242a09f703274d3b9283f2064a1a33064b53a1b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}