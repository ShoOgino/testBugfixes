{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,boolean).mjava","commits":[{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned\n   * and specify {@code true} to store BKD off-heap ({@code false} otherwise)\n   */\n  public BKDReader(IndexInput in, boolean offHeap) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    IndexInput slice = in.slice(\"packedIndex\", in.getFilePointer(), numBytes);\n    if (offHeap) {\n      packedIndex = new BKDOffHeapInput(slice);\n    } else {\n      packedIndex = new BKDOnHeapInput(slice, numBytes);\n    }\n\n    this.in = in;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,IndexInput,IndexInput,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#BKDReader(IndexInput,boolean).mjava","sourceNew":"  /**\n   * Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned\n   * and specify {@code true} to store BKD off-heap ({@code false} otherwise)\n   */\n  public BKDReader(IndexInput metaIn, IndexInput indexIn, IndexInput dataIn, boolean offHeap) throws IOException {\n    version = CodecUtil.checkHeader(metaIn, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = metaIn.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = metaIn.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = metaIn.readVInt();\n    bytesPerDim = metaIn.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = metaIn.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    metaIn.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    metaIn.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, metaIn);\n      }\n    }\n    \n    pointCount = metaIn.readVLong();\n    docCount = metaIn.readVInt();\n\n    int numIndexBytes = metaIn.readVInt();\n    long indexStartPointer;\n    if (version >= BKDWriter.VERSION_META_FILE) {\n      minLeafBlockFP = metaIn.readLong();\n      indexStartPointer = metaIn.readLong();\n    } else {\n      indexStartPointer = indexIn.getFilePointer();\n      minLeafBlockFP = indexIn.readVLong();\n      indexIn.seek(indexStartPointer);\n    }\n    IndexInput slice = indexIn.slice(\"packedIndex\", indexStartPointer, numIndexBytes);\n    if (offHeap) {\n      packedIndex = new BKDOffHeapInput(slice);\n    } else {\n      packedIndex = new BKDOnHeapInput(slice, numIndexBytes);\n    }\n\n    this.in = dataIn;\n  }\n\n","sourceOld":"  /**\n   * Caller must pre-seek the provided {@link IndexInput} to the index location that {@link BKDWriter#finish} returned\n   * and specify {@code true} to store BKD off-heap ({@code false} otherwise)\n   */\n  public BKDReader(IndexInput in, boolean offHeap) throws IOException {\n    version = CodecUtil.checkHeader(in, BKDWriter.CODEC_NAME, BKDWriter.VERSION_START, BKDWriter.VERSION_CURRENT);\n    numDataDims = in.readVInt();\n    if (version >= BKDWriter.VERSION_SELECTIVE_INDEXING) {\n      numIndexDims = in.readVInt();\n    } else {\n      numIndexDims = numDataDims;\n    }\n    maxPointsInLeafNode = in.readVInt();\n    bytesPerDim = in.readVInt();\n    packedBytesLength = numDataDims * bytesPerDim;\n    packedIndexBytesLength = numIndexDims * bytesPerDim;\n\n    // Read index:\n    numLeaves = in.readVInt();\n    assert numLeaves > 0;\n    leafNodeOffset = numLeaves;\n\n    minPackedValue = new byte[packedIndexBytesLength];\n    maxPackedValue = new byte[packedIndexBytesLength];\n\n    in.readBytes(minPackedValue, 0, packedIndexBytesLength);\n    in.readBytes(maxPackedValue, 0, packedIndexBytesLength);\n\n    for(int dim=0;dim<numIndexDims;dim++) {\n      if (Arrays.compareUnsigned(minPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim, maxPackedValue, dim * bytesPerDim, dim * bytesPerDim + bytesPerDim) > 0) {\n        throw new CorruptIndexException(\"minPackedValue \" + new BytesRef(minPackedValue) + \" is > maxPackedValue \" + new BytesRef(maxPackedValue) + \" for dim=\" + dim, in);\n      }\n    }\n    \n    pointCount = in.readVLong();\n    docCount = in.readVInt();\n\n    int numBytes = in.readVInt();\n    IndexInput slice = in.slice(\"packedIndex\", in.getFilePointer(), numBytes);\n    if (offHeap) {\n      packedIndex = new BKDOffHeapInput(slice);\n    } else {\n      packedIndex = new BKDOnHeapInput(slice, numBytes);\n    }\n\n    this.in = in;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"]},"commit2Childs":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}