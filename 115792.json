{"path":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","commits":[{"id":"2428b3de33c400750a32591679fd9ee6d6d706dc","date":1395315031,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, sampleDocs, docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["437e65c578cab603d9201916b0e285f3d68aff45"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","sourceNew":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new FixedBitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, sampleDocs, docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","sourceNew":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new FixedBitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"437e65c578cab603d9201916b0e285f3d68aff45","date":1427831677,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","sourceNew":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["2428b3de33c400750a32591679fd9ee6d6d706dc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/RandomSamplingFacetsCollector#createSample(MatchingDocs).mjava","sourceNew":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  /** Create a sampled of the given hits. */\n  private MatchingDocs createSample(MatchingDocs docs) {\n    int maxdoc = docs.context.reader().maxDoc();\n    \n    // TODO: we could try the WAH8DocIdSet here as well, as the results will be sparse\n    FixedBitSet sampleDocs = new FixedBitSet(maxdoc);\n    \n    int binSize = (int) (1.0 / samplingRate);\n    \n    try {\n      int counter = 0;\n      int limit, randomIndex;\n      if (leftoverBin != NOT_CALCULATED) {\n        limit = leftoverBin;\n        // either NOT_CALCULATED, which means we already sampled from that bin,\n        // or the next document to sample\n        randomIndex = leftoverIndex;\n      } else {\n        limit = binSize;\n        randomIndex = random.nextInt(binSize);\n      }\n      final DocIdSetIterator it = docs.bits.iterator();\n      for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n        if (counter == randomIndex) {\n          sampleDocs.set(doc);\n        }\n        counter++;\n        if (counter >= limit) {\n          counter = 0;\n          limit = binSize;\n          randomIndex = random.nextInt(binSize);\n        }\n      }\n      \n      if (counter == 0) {\n        // we either exhausted the bin and the iterator at the same time, or\n        // this segment had no results. in the latter case we might want to\n        // carry leftover to the next segment as is, but that complicates the\n        // code and doesn't seem so important.\n        leftoverBin = leftoverIndex = NOT_CALCULATED;\n      } else {\n        leftoverBin = limit - counter;\n        if (randomIndex > counter) {\n          // the document to sample is in the next bin\n          leftoverIndex = randomIndex - counter;\n        } else if (randomIndex < counter) {\n          // we sampled a document from the bin, so just skip over remaining\n          // documents in the bin in the next segment.\n          leftoverIndex = NOT_CALCULATED;\n        }\n      }\n      \n      return new MatchingDocs(docs.context, new BitDocIdSet(sampleDocs), docs.totalHits, null);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80c55596a764e2d397e982828e75fcac5ce430a0":["2428b3de33c400750a32591679fd9ee6d6d706dc"],"437e65c578cab603d9201916b0e285f3d68aff45":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"2428b3de33c400750a32591679fd9ee6d6d706dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"fab172655716b96f7e42376116235017a922de3a":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","437e65c578cab603d9201916b0e285f3d68aff45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["437e65c578cab603d9201916b0e285f3d68aff45"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2428b3de33c400750a32591679fd9ee6d6d706dc"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"2428b3de33c400750a32591679fd9ee6d6d706dc":["80c55596a764e2d397e982828e75fcac5ce430a0"],"437e65c578cab603d9201916b0e285f3d68aff45":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["437e65c578cab603d9201916b0e285f3d68aff45","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}