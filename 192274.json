{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","commits":[{"id":"2e11e54ce6015434b2aaadb49ca5071dbe7be50c","date":1489404389,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0","date":1490749780,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08807474e48bac766abf10459c3c25e4a5e4d7cc","date":1490873946,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":["5048c558f8802f1689d38203111379406b171418","415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Issuing well ordered update: {}\", update.getDocuments());\n      }\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new SolrNamedThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"08807474e48bac766abf10459c3c25e4a5e4d7cc":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"08807474e48bac766abf10459c3c25e4a5e4d7cc":[],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["08807474e48bac766abf10459c3c25e4a5e4d7cc","02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["08807474e48bac766abf10459c3c25e4a5e4d7cc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}