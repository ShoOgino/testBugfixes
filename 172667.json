{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","commits":[{"id":"28a3c4e2d35aa13e94434a7c3de075def163b47e","date":1355674116,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        recoveryExecutor.shutdownNow();\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0699c7fc8f43390f016d487a967f4e20a5354d4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        recoveryExecutor.shutdownNow();\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f4821d05931759774f7fd656e31d449de2d1436","date":1355887327,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80ba0e0ced6273399ff97caaf301445b9fd24895","date":1356802943,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":["0699c7fc8f43390f016d487a967f4e20a5354d4f","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","bugFix":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"bugIntro":["0699c7fc8f43390f016d487a967f4e20a5354d4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0699c7fc8f43390f016d487a967f4e20a5354d4f","date":1430221811,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n    }\n  }\n\n","bugFix":["28a3c4e2d35aa13e94434a7c3de075def163b47e","80ba0e0ced6273399ff97caaf301445b9fd24895","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659","date":1440978271,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownNowAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      if (bufferTlog != null) {\n        // should not delete bufferTlog on close, existing bufferTlog is a sign for skip peerSync\n        bufferTlog.deleteOnClose = false;\n        bufferTlog.decref();\n        bufferTlog.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      if (bufferTlog != null) {\n        // should not delete bufferTlog on close, existing bufferTlog is a sign for skip peerSync\n        bufferTlog.deleteOnClose = false;\n        bufferTlog.decref();\n        bufferTlog.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      if (bufferTlog != null) {\n        // should not delete bufferTlog on close, existing bufferTlog is a sign for skip peerSync\n        bufferTlog.deleteOnClose = false;\n        bufferTlog.decref();\n        bufferTlog.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#close(boolean,boolean).mjava","sourceNew":"  public void close(boolean committed, boolean deleteOnClose) {\n    recoveryExecutor.shutdown(); // no new tasks\n\n    synchronized (this) {\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      if (bufferTlog != null) {\n        // should not delete bufferTlog on close, existing bufferTlog is a sign for skip peerSync\n        bufferTlog.deleteOnClose = false;\n        bufferTlog.decref();\n        bufferTlog.forceClose();\n      }\n\n    }\n\n    try {\n      ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n  }\n\n","sourceOld":"  public void close(boolean committed, boolean deleteOnClose) {\n    synchronized (this) {\n      recoveryExecutor.shutdown(); // no new tasks\n\n      // Don't delete the old tlogs, we want to be able to replay from them and retrieve old versions\n\n      doClose(prevTlog, committed);\n      doClose(tlog, committed);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n\n      if (bufferTlog != null) {\n        // should not delete bufferTlog on close, existing bufferTlog is a sign for skip peerSync\n        bufferTlog.deleteOnClose = false;\n        bufferTlog.decref();\n        bufferTlog.forceClose();\n      }\n\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(recoveryExecutor);\n      } catch (Exception e) {\n        SolrException.log(log, e);\n      }\n    }\n  }\n\n","bugFix":["b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659","0699c7fc8f43390f016d487a967f4e20a5354d4f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","80ba0e0ced6273399ff97caaf301445b9fd24895"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["1455c941cc4ce652efc776fc23471b0e499246f6"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["7f4821d05931759774f7fd656e31d449de2d1436"],"a69439d0df009e0bb0038d1e427159f449dd670d":["28a3c4e2d35aa13e94434a7c3de075def163b47e"],"b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659":["0699c7fc8f43390f016d487a967f4e20a5354d4f"],"1455c941cc4ce652efc776fc23471b0e499246f6":["b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659"],"0699c7fc8f43390f016d487a967f4e20a5354d4f":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"7f4821d05931759774f7fd656e31d449de2d1436":["a69439d0df009e0bb0038d1e427159f449dd670d"],"28a3c4e2d35aa13e94434a7c3de075def163b47e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659","1455c941cc4ce652efc776fc23471b0e499246f6"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"f592209545c71895260367152601e9200399776d":["b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"80ba0e0ced6273399ff97caaf301445b9fd24895":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a69439d0df009e0bb0038d1e427159f449dd670d":["7f4821d05931759774f7fd656e31d449de2d1436"],"b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659":["1455c941cc4ce652efc776fc23471b0e499246f6","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"1455c941cc4ce652efc776fc23471b0e499246f6":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"7f4821d05931759774f7fd656e31d449de2d1436":["80ba0e0ced6273399ff97caaf301445b9fd24895"],"28a3c4e2d35aa13e94434a7c3de075def163b47e":["a69439d0df009e0bb0038d1e427159f449dd670d"],"0699c7fc8f43390f016d487a967f4e20a5354d4f":["b9248e8833b6ab03d4e0ebbeaa8b26d8798e7659"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","28a3c4e2d35aa13e94434a7c3de075def163b47e"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["0699c7fc8f43390f016d487a967f4e20a5354d4f"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}