{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","commits":[{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":1,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/StreamingUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    server.requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                        .getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n\n            String path = ClientUtils.TEXT_XML.equals(server.requestWriter\n                .getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new HttpPost(server.getBaseURL() + path);\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info( \"starting runner: {}\" , this );\n      PostMethod method = null;\n      try {\n        while (!queue.isEmpty())  {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250, TimeUnit.MILLISECONDS);\n            if (updateRequest == null) break;\n            RequestEntity request = new RequestEntity() {\n              // we don't know the length\n              public long getContentLength() { return -1; }\n              public String getContentType() { return requestWriter.getUpdateContentType(); }\n              public boolean isRepeatable()  { return false; }\n\n              public void writeRequest(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false) + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n                  out.flush();\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n\n            String path = ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new PostMethod(_baseURL+path );\n            method.setRequestEntity( request );\n            method.setFollowRedirects( false );\n            method.addRequestHeader( \"User-Agent\", AGENT );\n            \n            int statusCode = getHttpClient().executeMethod(method);\n            log.info(\"Status for: \" + updateRequest.getDocuments().get(0).getFieldValue(\"id\") + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append( method.getStatusLine().getReasonPhrase() );\n              msg.append( \"\\n\\n\" );\n              msg.append( method.getStatusText() );\n              msg.append( \"\\n\\n\" );\n              msg.append(\"request: \").append(method.getURI());\n              handleError( new Exception( msg.toString() ) );\n            }\n          } finally {\n            try {\n              // make sure to release the connection\n              if(method != null)\n                method.releaseConnection();\n            }\n            catch( Exception ex ){}\n          }\n        }\n      }\n      catch (Throwable e) {\n        handleError( e );\n      }\n      finally {\n\n        // remove it from the list of running things unless we are the last runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no runners to handle it.\n        // This case has been further handled by using offer instead of put, and using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n           // keep this runner alive\n           scheduler.execute(this);\n          } else {\n            runners.remove( this );\n          }\n        }\n\n        log.info( \"finished: {}\" , this );\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa449cfca84dac88c4179c4b771dd9d1e80e8348","date":1334340256,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            final boolean isXml = ClientUtils.TEXT_XML.equals(server.requestWriter\n                .getUpdateContentType());\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            final String path = isXml ? \"/update\" : \"/update/javabin\";\n\n            method = new HttpPost(server.getBaseURL() + path\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    server.requestWriter.write(req, out);\n                    if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                        .getUpdateContentType())) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (ClientUtils.TEXT_XML.equals(server.requestWriter\n                      .getUpdateContentType())) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n\n            String path = ClientUtils.TEXT_XML.equals(server.requestWriter\n                .getUpdateContentType()) ? \"/update\" : \"/update/javabin\";\n\n            method = new HttpPost(server.getBaseURL() + path);\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            final boolean isXml = ClientUtils.TEXT_XML.equals(server.requestWriter\n                .getUpdateContentType());\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            final String path = isXml ? \"/update\" : \"/update/javabin\";\n\n            method = new HttpPost(server.getBaseURL() + path\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["945902ae43d8dd7e920418efe36981403c2ee669"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"448a213c5dfd8b9baaf143dcbf9e633d8d7d1d5e","date":1341842777,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed0dd3d82be806ac8ab4e15bf5b89310270c0210","date":1349302029,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" waitFlush=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      // info is ok since this should only happen once for each thread\n      log.info(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(250, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  e.printStackTrace();\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            log.info(\"Status for: \"\n                + updateRequest.getDocuments().get(0).getFieldValue(\"id\")\n                + \" is \" + statusCode);\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new Exception(msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.info(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ed88f2d1f6a64c8b31ace51541448a0b2f29606","date":1390186799,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n\n        // remove it from the list of running things unless we are the last\n        // runner and the queue is full...\n        // in which case, the next queue.put() would block and there would be no\n        // runners to handle it.\n        // This case has been further handled by using offer instead of put, and\n        // using a retry loop\n        // to avoid blocking forever (see request()).\n        synchronized (runners) {\n          if (runners.size() == 1 && queue.remainingCapacity() == 0) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d3d365762604952e436b51980101dfc84cc1b3e","date":1396298116,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(\"UTF-8\")); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(\"UTF-8\");\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(\"UTF-8\"));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d22d0f5940f155267b250876fa797ff69e8e6e7","date":1400540695,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"945902ae43d8dd7e920418efe36981403c2ee669","date":1405459741,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;\n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = queue.poll(250,\n                TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n\n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }\n                  UpdateRequest req = updateRequest;\n                  while (req != null) {\n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n            \n            \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\");\n              msg.append(\"\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":["042e4d934397657ba04c82b46cc5665076bc5c58","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b594b1b209efe245c2227a83c4f1a08e8054d5eb","date":1411504154,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    server.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+server.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n              handleError(new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString()));\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrClient.Runner#run().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.Runner#run().mjava","sourceNew":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = client.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    client.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, client.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, client.parser.getVersion());\n\n            method = new HttpPost(client.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrClient.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = client.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    client.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+ client.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      runnerLock.lock();\n\n      log.debug(\"starting runner: {}\", this);\n      HttpPost method = null;\n      HttpResponse response = null;            \n      try {\n        while (!queue.isEmpty()) {\n          try {\n            final UpdateRequest updateRequest = \n                queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n            if (updateRequest == null)\n              break;\n                       \n            String contentType = server.requestWriter.getUpdateContentType();\n            final boolean isXml = ClientUtils.TEXT_XML.equals(contentType);\n\n            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());\n\n            EntityTemplate template = new EntityTemplate(new ContentProducer() {\n\n              @Override\n              public void writeTo(OutputStream out) throws IOException {\n                try {\n                  if (isXml) {\n                    out.write(\"<stream>\".getBytes(StandardCharsets.UTF_8)); // can be anything\n                  }                                    \n                  UpdateRequest req = updateRequest;\n                  while (req != null) {                                        \n                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());\n                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {\n                      queue.add(req); // params are different, push back to queue\n                      break;\n                    }\n                    \n                    server.requestWriter.write(req, out);\n                    if (isXml) {\n                      // check for commit or optimize\n                      SolrParams params = req.getParams();\n                      if (params != null) {\n                        String fmt = null;\n                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {\n                          fmt = \"<optimize waitSearcher=\\\"%s\\\" />\";\n                        } else if (params.getBool(UpdateParams.COMMIT, false)) {\n                          fmt = \"<commit waitSearcher=\\\"%s\\\" />\";\n                        }\n                        if (fmt != null) {\n                          byte[] content = String.format(Locale.ROOT,\n                              fmt,\n                              params.getBool(UpdateParams.WAIT_SEARCHER, false)\n                                  + \"\").getBytes(StandardCharsets.UTF_8);\n                          out.write(content);\n                        }\n                      }\n                    }\n                    out.flush();\n                    req = queue.poll(pollQueueTime, TimeUnit.MILLISECONDS);\n                  }\n                  \n                  if (isXml) {\n                    out.write(\"</stream>\".getBytes(StandardCharsets.UTF_8));\n                  }\n\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                  log.warn(\"\", e);\n                }\n              }\n            });\n            \n            // The parser 'wt=' and 'version=' params are used instead of the\n            // original params\n            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);\n            requestParams.set(CommonParams.WT, server.parser.getWriterType());\n            requestParams.set(CommonParams.VERSION, server.parser.getVersion());\n\n            method = new HttpPost(server.getBaseURL() + \"/update\"\n                + ClientUtils.toQueryString(requestParams, false));\n            method.setEntity(template);\n            method.addHeader(\"User-Agent\", HttpSolrServer.AGENT);\n            method.addHeader(\"Content-Type\", contentType);\n                        \n            response = server.getHttpClient().execute(method);\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n              StringBuilder msg = new StringBuilder();\n              msg.append(response.getStatusLine().getReasonPhrase());\n              msg.append(\"\\n\\n\\n\\n\");\n              msg.append(\"request: \").append(method.getURI());\n\n              SolrException solrExc = new SolrException(ErrorCode.getErrorCode(statusCode), msg.toString());\n              // parse out the metadata from the SolrException\n              try {\n                NamedList<Object> resp =\n                    server.parser.processResponse(response.getEntity().getContent(),\n                        response.getEntity().getContentType().getValue());\n                NamedList<Object> error = (NamedList<Object>) resp.get(\"error\");\n                if (error != null)\n                  solrExc.setMetadata((NamedList<String>) error.get(\"metadata\"));\n              } catch (Exception exc) {\n                // don't want to fail to report error if parsing the response fails\n                log.warn(\"Failed to parse error response from \"+server.getBaseURL()+\" due to: \"+exc);\n              }\n\n              handleError(solrExc);\n            } else {\n              onSuccess(response);\n            }\n          } finally {\n            try {\n              if (response != null) {\n                response.getEntity().getContent().close();\n              }\n            } catch (Exception ex) {\n              log.warn(\"\", ex);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        if (e instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) e;\n        }\n        handleError(e);\n      } finally {\n        synchronized (runners) {\n          if (runners.size() == 1 && !queue.isEmpty()) {\n            // keep this runner alive\n            scheduler.execute(this);\n          } else {\n            runners.remove(this);\n            if (runners.isEmpty())\n              runners.notifyAll();\n          }\n        }\n\n        log.debug(\"finished: {}\", this);\n        runnerLock.unlock();\n      }\n    }\n\n","bugFix":null,"bugIntro":["50e202028300f452744bbd0e537a0f5c0cf044b6"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606","9d3d365762604952e436b51980101dfc84cc1b3e"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["ed0dd3d82be806ac8ab4e15bf5b89310270c0210","7530de27b87b961b51f01bd1299b7004d46e8823"],"945902ae43d8dd7e920418efe36981403c2ee669":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["7530de27b87b961b51f01bd1299b7004d46e8823"],"fa449cfca84dac88c4179c4b771dd9d1e80e8348":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bafca15d8e408346a67f4282ad1143b88023893b":["b594b1b209efe245c2227a83c4f1a08e8054d5eb"],"b594b1b209efe245c2227a83c4f1a08e8054d5eb":["945902ae43d8dd7e920418efe36981403c2ee669"],"2acf500f78aa12b92e371fd89c719291986b6b90":["042e4d934397657ba04c82b46cc5665076bc5c58","448a213c5dfd8b9baaf143dcbf9e633d8d7d1d5e"],"b7605579001505896d48b07160075a5c8b8e128e":["9d3d365762604952e436b51980101dfc84cc1b3e","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"7d89d7e4e5101347833eea558851bf4209218619":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606"],"ed0dd3d82be806ac8ab4e15bf5b89310270c0210":["2acf500f78aa12b92e371fd89c719291986b6b90"],"46d8ada1fff8d18cb197c38c7983225162599948":["042e4d934397657ba04c82b46cc5665076bc5c58","2acf500f78aa12b92e371fd89c719291986b6b90"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["9d3d365762604952e436b51980101dfc84cc1b3e"],"448a213c5dfd8b9baaf143dcbf9e633d8d7d1d5e":["042e4d934397657ba04c82b46cc5665076bc5c58"],"042e4d934397657ba04c82b46cc5665076bc5c58":["fa449cfca84dac88c4179c4b771dd9d1e80e8348"],"1ed88f2d1f6a64c8b31ace51541448a0b2f29606":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["042e4d934397657ba04c82b46cc5665076bc5c58","2acf500f78aa12b92e371fd89c719291986b6b90"],"9d3d365762604952e436b51980101dfc84cc1b3e":["7d89d7e4e5101347833eea558851bf4209218619"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"7530de27b87b961b51f01bd1299b7004d46e8823":["ed0dd3d82be806ac8ab4e15bf5b89310270c0210"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"945902ae43d8dd7e920418efe36981403c2ee669":["b594b1b209efe245c2227a83c4f1a08e8054d5eb"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"fa449cfca84dac88c4179c4b771dd9d1e80e8348":["042e4d934397657ba04c82b46cc5665076bc5c58"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["fa449cfca84dac88c4179c4b771dd9d1e80e8348"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b594b1b209efe245c2227a83c4f1a08e8054d5eb":["bafca15d8e408346a67f4282ad1143b88023893b"],"2acf500f78aa12b92e371fd89c719291986b6b90":["ed0dd3d82be806ac8ab4e15bf5b89310270c0210","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"b7605579001505896d48b07160075a5c8b8e128e":[],"7d89d7e4e5101347833eea558851bf4209218619":["9d3d365762604952e436b51980101dfc84cc1b3e"],"ed0dd3d82be806ac8ab4e15bf5b89310270c0210":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["945902ae43d8dd7e920418efe36981403c2ee669","b7605579001505896d48b07160075a5c8b8e128e"],"448a213c5dfd8b9baaf143dcbf9e633d8d7d1d5e":["2acf500f78aa12b92e371fd89c719291986b6b90"],"042e4d934397657ba04c82b46cc5665076bc5c58":["2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","448a213c5dfd8b9baaf143dcbf9e633d8d7d1d5e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"1ed88f2d1f6a64c8b31ace51541448a0b2f29606":["5eb2511ababf862ea11e10761c70ee560cd84510","7d89d7e4e5101347833eea558851bf4209218619"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"9d3d365762604952e436b51980101dfc84cc1b3e":["5eb2511ababf862ea11e10761c70ee560cd84510","b7605579001505896d48b07160075a5c8b8e128e","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["1ed88f2d1f6a64c8b31ace51541448a0b2f29606"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b7605579001505896d48b07160075a5c8b8e128e","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}