{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean).mjava","commits":[{"id":"01f1a345a808c3a24ce12b4540ab4847c0dac9b0","date":1459948931,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    double accumulatedAngle = 0.0;\n    for (int i = 0; i < pointCount; i++) {\n      final int remainingEdgeCount = pointCount - i;\n      final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n      if (remainingEdgeCount == 1) {\n        angles[i] = remainingAngle;\n      } else {\n        // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n        double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n        if (maximumAngle > Math.PI) {\n          maximumAngle = Math.PI;\n        }\n        // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n        // 180 degrees.  And since we have three points to start with, we already know that.\n        final double minimumAngle = MINIMUM_EDGE_ANGLE;\n        // Pick the angle\n        final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n        angles[i] = angle;\n        accumulatedAngle += angle;\n      }\n      // Pick the arc distance randomly\n      arcDistance[i] = random().nextDouble() * (Math.PI * 0.5 - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n    }\n    if (clockwiseDesired) {\n      // Reverse the signs\n      for (int i = 0; i < pointCount; i++) {\n        angles[i] = -angles[i];\n      }\n    }\n    \n    // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n    final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n    \n    // Create the geo3d polygon, so we can test out our poles.\n    GeoPolygon poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n    \n    // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n    // going to use Geo3D to help us select those given the points we just made.\n    \n    final int holeCount = TestUtil.nextInt(random(), 0, 2);\n    \n    final Polygon[] holes = new Polygon[holeCount];\n    \n    for (int i = 0; i < holeCount; i++) {\n      // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n      // We try indefinitely to find a good pole...\n      while (true) {\n        final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n        if (!poly.isWithin(poleChoice)) {\n          continue;\n        }\n        // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n        // After that we give up and pick a new pole.\n        boolean foundOne = false;\n        for (int j = 0; j < 100; j++) {\n          final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired);\n          // Verify that the inside polygon is OK.  If not, discard and repeat.\n          if (!verifyPolygon(pm, insidePoly, poly)) {\n            continue;\n          }\n          holes[i] = insidePoly;\n          foundOne = true;\n        }\n        if (foundOne) {\n          break;\n        }\n      }\n    }\n    \n    // Finally, build the polygon and return it\n    final double[] lats = new double[polyPoints.size() + 1];\n    final double[] lons = new double[polyPoints.size() + 1];\n      \n    for (int i = 0; i < polyPoints.size(); i++) {\n      lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n      lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n    }\n    lats[polyPoints.size()] = lats[0];\n    lons[polyPoints.size()] = lons[0];\n    return new Polygon(lats, lons, holes);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean).mjava","sourceNew":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    double accumulatedAngle = 0.0;\n    for (int i = 0; i < pointCount; i++) {\n      final int remainingEdgeCount = pointCount - i;\n      final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n      if (remainingEdgeCount == 1) {\n        angles[i] = remainingAngle;\n      } else {\n        // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n        double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n        if (maximumAngle > Math.PI) {\n          maximumAngle = Math.PI;\n        }\n        // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n        // 180 degrees.  And since we have three points to start with, we already know that.\n        final double minimumAngle = MINIMUM_EDGE_ANGLE;\n        // Pick the angle\n        final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n        angles[i] = angle;\n        accumulatedAngle += angle;\n      }\n      // Pick the arc distance randomly\n      arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n    }\n    if (clockwiseDesired) {\n      // Reverse the signs\n      for (int i = 0; i < pointCount; i++) {\n        angles[i] = -angles[i];\n      }\n    }\n    \n    // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n    final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n    \n    // Create the geo3d polygon, so we can test out our poles.\n    GeoPolygon poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n    \n    // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n    // going to use Geo3D to help us select those given the points we just made.\n    \n    final int holeCount = TestUtil.nextInt(random(), 0, 2);\n    \n    final Polygon[] holes = new Polygon[holeCount];\n    \n    for (int i = 0; i < holeCount; i++) {\n      // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n      // We try indefinitely to find a good pole...\n      while (true) {\n        final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n        if (!poly.isWithin(poleChoice)) {\n          continue;\n        }\n        // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n        // After that we give up and pick a new pole.\n        boolean foundOne = false;\n        for (int j = 0; j < 100; j++) {\n          final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired);\n          // Verify that the inside polygon is OK.  If not, discard and repeat.\n          if (!verifyPolygon(pm, insidePoly, poly)) {\n            continue;\n          }\n          holes[i] = insidePoly;\n          foundOne = true;\n        }\n        if (foundOne) {\n          break;\n        }\n      }\n    }\n    \n    // Finally, build the polygon and return it\n    final double[] lats = new double[polyPoints.size() + 1];\n    final double[] lons = new double[polyPoints.size() + 1];\n      \n    for (int i = 0; i < polyPoints.size(); i++) {\n      lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n      lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n    }\n    lats[polyPoints.size()] = lats[0];\n    lons[polyPoints.size()] = lons[0];\n    return new Polygon(lats, lons, holes);\n  }\n\n","sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    double accumulatedAngle = 0.0;\n    for (int i = 0; i < pointCount; i++) {\n      final int remainingEdgeCount = pointCount - i;\n      final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n      if (remainingEdgeCount == 1) {\n        angles[i] = remainingAngle;\n      } else {\n        // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n        double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n        if (maximumAngle > Math.PI) {\n          maximumAngle = Math.PI;\n        }\n        // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n        // 180 degrees.  And since we have three points to start with, we already know that.\n        final double minimumAngle = MINIMUM_EDGE_ANGLE;\n        // Pick the angle\n        final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n        angles[i] = angle;\n        accumulatedAngle += angle;\n      }\n      // Pick the arc distance randomly\n      arcDistance[i] = random().nextDouble() * (Math.PI * 0.5 - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n    }\n    if (clockwiseDesired) {\n      // Reverse the signs\n      for (int i = 0; i < pointCount; i++) {\n        angles[i] = -angles[i];\n      }\n    }\n    \n    // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n    final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n    \n    // Create the geo3d polygon, so we can test out our poles.\n    GeoPolygon poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n    \n    // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n    // going to use Geo3D to help us select those given the points we just made.\n    \n    final int holeCount = TestUtil.nextInt(random(), 0, 2);\n    \n    final Polygon[] holes = new Polygon[holeCount];\n    \n    for (int i = 0; i < holeCount; i++) {\n      // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n      // We try indefinitely to find a good pole...\n      while (true) {\n        final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n        if (!poly.isWithin(poleChoice)) {\n          continue;\n        }\n        // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n        // After that we give up and pick a new pole.\n        boolean foundOne = false;\n        for (int j = 0; j < 100; j++) {\n          final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired);\n          // Verify that the inside polygon is OK.  If not, discard and repeat.\n          if (!verifyPolygon(pm, insidePoly, poly)) {\n            continue;\n          }\n          holes[i] = insidePoly;\n          foundOne = true;\n        }\n        if (foundOne) {\n          break;\n        }\n      }\n    }\n    \n    // Finally, build the polygon and return it\n    final double[] lats = new double[polyPoints.size() + 1];\n    final double[] lons = new double[polyPoints.size() + 1];\n      \n    for (int i = 0; i < polyPoints.size(); i++) {\n      lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n      lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n    }\n    lats[polyPoints.size()] = lats[0];\n    lons[polyPoints.size()] = lons[0];\n    return new Polygon(lats, lons, holes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4426b4db58382f44a19bd3bbd62c69df9e9fa84a","date":1459983420,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#makePoly(PlanetModel,GeoPoint,boolean).mjava","sourceNew":null,"sourceOld":"  /** Cook up a random Polygon that makes sense, with possible nested polygon within.\n    * This is part of testing more complex polygons with nested holes.  Picking random points\n    * doesn't do it because it's almost impossible to come up with nested ones of the proper \n    * clockwise/counterclockwise rotation that way.\n    */\n  protected Polygon makePoly(final PlanetModel pm, final GeoPoint pole, final boolean clockwiseDesired) {\n    // Polygon edges will be arranged around the provided pole, and holes will each have a pole selected within the parent\n    // polygon.\n    final int pointCount = TestUtil.nextInt(random(), 3, 10);\n    // The point angles we pick next.  The only requirement is that they are not all on one side of the pole.\n    // We arrange that by picking the next point within what's left of the remaining angle, but never more than 180 degrees,\n    // and never less than what is needed to insure that the remaining point choices are less than 180 degrees always.\n    // These are all picked in the context of the pole,\n    final double[] angles = new double[pointCount];\n    final double[] arcDistance = new double[pointCount];\n    double accumulatedAngle = 0.0;\n    for (int i = 0; i < pointCount; i++) {\n      final int remainingEdgeCount = pointCount - i;\n      final double remainingAngle = 2.0 * Math.PI - accumulatedAngle;\n      if (remainingEdgeCount == 1) {\n        angles[i] = remainingAngle;\n      } else {\n        // The maximum angle is 180 degrees, or what's left when you give a minimal amount to each edge.\n        double maximumAngle = remainingAngle - (remainingEdgeCount-1) * MINIMUM_EDGE_ANGLE;\n        if (maximumAngle > Math.PI) {\n          maximumAngle = Math.PI;\n        }\n        // The minimum angle is MINIMUM_EDGE_ANGLE, or enough to be sure nobody afterwards needs more than\n        // 180 degrees.  And since we have three points to start with, we already know that.\n        final double minimumAngle = MINIMUM_EDGE_ANGLE;\n        // Pick the angle\n        final double angle = random().nextDouble() * (maximumAngle - minimumAngle) + minimumAngle;\n        angles[i] = angle;\n        accumulatedAngle += angle;\n      }\n      // Pick the arc distance randomly\n      arcDistance[i] = random().nextDouble() * (Math.PI - MINIMUM_ARC_ANGLE) + MINIMUM_ARC_ANGLE;\n    }\n    if (clockwiseDesired) {\n      // Reverse the signs\n      for (int i = 0; i < pointCount; i++) {\n        angles[i] = -angles[i];\n      }\n    }\n    \n    // Now, use the pole's information plus angles and arcs to create GeoPoints in the right order.\n    final List<GeoPoint> polyPoints = convertToPoints(pm, pole, angles, arcDistance);\n    \n    // Create the geo3d polygon, so we can test out our poles.\n    GeoPolygon poly = GeoPolygonFactory.makeGeoPolygon(pm, polyPoints, null);\n    \n    // Next, do some holes.  No more than 2 of these.  The poles for holes must always be within the polygon, so we're\n    // going to use Geo3D to help us select those given the points we just made.\n    \n    final int holeCount = TestUtil.nextInt(random(), 0, 2);\n    \n    final Polygon[] holes = new Polygon[holeCount];\n    \n    for (int i = 0; i < holeCount; i++) {\n      // Choose a pole.  The poly has to be within the polygon, but it also cannot be on the polygon edge.\n      // We try indefinitely to find a good pole...\n      while (true) {\n        final GeoPoint poleChoice = new GeoPoint(pm, toRadians(randomLat()), toRadians(randomLon()));\n        if (!poly.isWithin(poleChoice)) {\n          continue;\n        }\n        // We have a pole within the polygon.  Now try 100 times to build a polygon that does not intersect the outside ring.\n        // After that we give up and pick a new pole.\n        boolean foundOne = false;\n        for (int j = 0; j < 100; j++) {\n          final Polygon insidePoly = makePoly(pm, poleChoice, !clockwiseDesired);\n          // Verify that the inside polygon is OK.  If not, discard and repeat.\n          if (!verifyPolygon(pm, insidePoly, poly)) {\n            continue;\n          }\n          holes[i] = insidePoly;\n          foundOne = true;\n        }\n        if (foundOne) {\n          break;\n        }\n      }\n    }\n    \n    // Finally, build the polygon and return it\n    final double[] lats = new double[polyPoints.size() + 1];\n    final double[] lons = new double[polyPoints.size() + 1];\n      \n    for (int i = 0; i < polyPoints.size(); i++) {\n      lats[i] = polyPoints.get(i).getLatitude() * 180.0 / Math.PI;\n      lons[i] = polyPoints.get(i).getLongitude() * 180.0 / Math.PI;\n    }\n    lats[polyPoints.size()] = lats[0];\n    lons[polyPoints.size()] = lons[0];\n    return new Polygon(lats, lons, holes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"01f1a345a808c3a24ce12b4540ab4847c0dac9b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4426b4db58382f44a19bd3bbd62c69df9e9fa84a":["a75c862521bb895a29958e7bc5cb188597205a08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4426b4db58382f44a19bd3bbd62c69df9e9fa84a"],"a75c862521bb895a29958e7bc5cb188597205a08":["01f1a345a808c3a24ce12b4540ab4847c0dac9b0"]},"commit2Childs":{"01f1a345a808c3a24ce12b4540ab4847c0dac9b0":["a75c862521bb895a29958e7bc5cb188597205a08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["01f1a345a808c3a24ce12b4540ab4847c0dac9b0"],"4426b4db58382f44a19bd3bbd62c69df9e9fa84a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a75c862521bb895a29958e7bc5cb188597205a08":["4426b4db58382f44a19bd3bbd62c69df9e9fa84a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}