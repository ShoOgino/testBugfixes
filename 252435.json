{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLongitudeQuantization().mjava","commits":[{"id":"bd6e28813bd3665a7c29cc07d0f32db701300168","date":1459966694,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLongitudeQuantization().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -180.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LONGITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLongitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLongitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LONGITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLongitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLongitudeQuantization().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -180.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LONGITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLongitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLongitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LONGITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLongitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","date":1460056040,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoEncodingUtils#testLongitudeQuantization().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLongitudeQuantization().mjava","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    final double LONGITUDE_DECODE = 360.0D/(0x1L<<32);\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = MIN_LON_INCL + (encoded - (long)Integer.MIN_VALUE) * LONGITUDE_DECODE;\n      double decoded = decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encodeLongitude(decoded));\n      assertEquals(encoded, encodeLongitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LONGITUDE_DECODE;\n        assertEquals(max, decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, encodeLongitude(max));\n        assertEquals(encoded+1, encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   encodeLongitude(minEdge));\n        assertEquals(encoded+1, encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   encodeLongitude(maxEdge));\n        assertEquals(encoded+1, encodeLongitudeCeil(maxEdge));\n\n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded, encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -180.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LONGITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLongitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLongitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LONGITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLongitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09f15823cf5eb6e807005579e875e117d8598f95","date":1460066385,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoEncodingUtils#testLongitudeQuantization().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint#testLongitudeQuantization().mjava","sourceNew":"  /**\n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    final double LONGITUDE_DECODE = 360.0D/(0x1L<<32);\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = MIN_LON_INCL + (encoded - (long)Integer.MIN_VALUE) * LONGITUDE_DECODE;\n      double decoded = decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, encodeLongitude(decoded));\n      assertEquals(encoded, encodeLongitudeCeil(decoded));\n      // test within the range\n      if (encoded != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LONGITUDE_DECODE;\n        assertEquals(max, decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, encodeLongitude(max));\n        assertEquals(encoded+1, encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   encodeLongitude(minEdge));\n        assertEquals(encoded+1, encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   encodeLongitude(maxEdge));\n        assertEquals(encoded+1, encodeLongitudeCeil(maxEdge));\n\n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded, encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * step through some integers, ensuring they decode to their expected double values.\n   * double values start at -180 and increase by LONGITUDE_DECODE for each integer.\n   * check edge cases within the double range and a random doubles within the range too.\n   */\n  public void testLongitudeQuantization() throws Exception {\n    Random random = random();\n    for (int i = 0; i < 10000; i++) {\n      int encoded = random.nextInt();\n      double min = -180.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LONGITUDE_DECODE;\n      double decoded = LatLonPoint.decodeLongitude(encoded);\n      // should exactly equal expected value\n      assertEquals(min, decoded, 0.0D);\n      // should round-trip\n      assertEquals(encoded, LatLonPoint.encodeLongitude(decoded));\n      assertEquals(encoded, LatLonPoint.encodeLongitudeCeil(decoded));\n      // test within the range\n      if (i != Integer.MAX_VALUE) {\n        // this is the next representable value\n        // all double values between [min .. max) should encode to the current integer\n        // all double values between (min .. max] should encodeCeil to the next integer.\n        double max = min + LatLonPoint.LONGITUDE_DECODE;\n        assertEquals(max, LatLonPoint.decodeLongitude(encoded+1), 0.0D);\n        assertEquals(encoded+1, LatLonPoint.encodeLongitude(max));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(max));\n\n        // first and last doubles in range that will be quantized\n        double minEdge = Math.nextUp(min);\n        double maxEdge = Math.nextDown(max);\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(minEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(minEdge));\n        assertEquals(encoded,   LatLonPoint.encodeLongitude(maxEdge));\n        assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(maxEdge));\n        \n        // check random values within the double range\n        long minBits = NumericUtils.doubleToSortableLong(minEdge);\n        long maxBits = NumericUtils.doubleToSortableLong(maxEdge);\n        for (int j = 0; j < 100; j++) {\n          double value = NumericUtils.sortableLongToDouble(TestUtil.nextLong(random, minBits, maxBits));\n          // round down\n          assertEquals(encoded,   LatLonPoint.encodeLongitude(value));\n          // round up\n          assertEquals(encoded+1, LatLonPoint.encodeLongitudeCeil(value));\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b6284684320a9808c41a5e43de958b2da22f89bd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bd6e28813bd3665a7c29cc07d0f32db701300168"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd6e28813bd3665a7c29cc07d0f32db701300168":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["b6284684320a9808c41a5e43de958b2da22f89bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09f15823cf5eb6e807005579e875e117d8598f95"],"09f15823cf5eb6e807005579e875e117d8598f95":["b6284684320a9808c41a5e43de958b2da22f89bd","ed48f9723ad1b29c351ea43b5a2c8f90c3a45737"]},"commit2Childs":{"b6284684320a9808c41a5e43de958b2da22f89bd":["ed48f9723ad1b29c351ea43b5a2c8f90c3a45737","09f15823cf5eb6e807005579e875e117d8598f95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b6284684320a9808c41a5e43de958b2da22f89bd","bd6e28813bd3665a7c29cc07d0f32db701300168"],"bd6e28813bd3665a7c29cc07d0f32db701300168":["b6284684320a9808c41a5e43de958b2da22f89bd"],"ed48f9723ad1b29c351ea43b5a2c8f90c3a45737":["09f15823cf5eb6e807005579e875e117d8598f95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"09f15823cf5eb6e807005579e875e117d8598f95":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}