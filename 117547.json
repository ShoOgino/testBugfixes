{"path":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    Similarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.computeNorm(state)  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e8d5a6ffbfa3405d234a87c833741eabed98d13","date":1326725835,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + similarity.decodeNormValue(similarity.computeNorm(state))  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b","date":1328532481,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState();\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    purgeFieldCache(FieldCache.DEFAULT);   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e2893fd5349134af382d33ccc3d84840394c6c1","date":1353682567,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0837ab0472feecb3a54260729d845f839e1cbd72","date":1358283639,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    Norm norm = new Norm();\n    similarity.computeNorm(state, norm);\n    float nrm = similarity.decodeNormValue(norm.field().numericValue().byteValue());\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='6.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":["e1720d203cff791bcdef2bae580cf24e8906b4d8","9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e28b14e7783d24ca69089f13ddadadbd2afdcb29","date":1399840701,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    // nocommit: split test if needed\n    // FieldCache.DEFAULT.purgeAllCaches();   // hide FC insanity\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10d98d3c84fcfdd2089a56054f4cf7186a57265d","date":1400053445,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    // nocommit: split test if needed\n    // FieldCache.DEFAULT.purgeAllCaches();   // hide FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n\n\n    FieldCache.DEFAULT.purgeAllCaches();   // avoid FC insanity\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new ClassicSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new DefaultSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49dd2950028d6b59839f54d3801d77f769fa22ef","date":1447264120,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    TFIDFSimilarity similarity = new ClassicSimilarity();\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(0,6)  + \"'\");\n     assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(nofield_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(0)  + \"'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}idf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.idf(3,6)  + \"'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}tf(a_t,cow)\", \"fq\",\"id:6\"),\n        \"//float[@name='score']='\" + similarity.tf(5)  + \"'\");\n    FieldInvertState state = new FieldInvertState(\"a_t\");\n    state.setBoost(1.0f);\n    state.setLength(4);\n    long norm = similarity.computeNorm(state);\n    float nrm = similarity.decodeNormValue((byte) norm);\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}norm(a_t)\", \"fq\",\"id:2\"),\n        \"//float[@name='score']='\" + nrm  + \"'\");  // sqrt(4)==2 and is exactly representable when quantized to a byte\n\n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71f63026529f3c1f03cfdd664910873ab2369ae","date":1497543264,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/float[.='120.0']\"\n           ,\"*//doc[2]/float[.='121.0']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb","date":1512565563,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='-1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da56d90379fbe988bf847d3482efa685803c5193","date":1544607230,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=1 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'1.0'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efff98a8632f3c2f5b05f961e22a67f122db81e0","date":1550955355,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n\n    // test a query that doesn't specify nested query val\n    assertQEx(\"Should fail because of missing qq\",\n        \"Missing param qq while parsing function 'query($qq)'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing sortfunc in sort\",\n        \"Can't determine a Sort Order (asc or desc) in sort spec '{!func v=$sortfunc} desc'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing qq in boost\",\n        \"Nested local params must have value in v parameter.  got 'query({!dismax v=$qq})\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query({!dismax v=$qq})\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as empty value is specified for v\",\n        \"Nested function query returned null for 'query({!v=})'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=})\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as v's value contains only spaces\",\n        \"Nested function query returned null for 'query({!v=   })'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=   })\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // no field specified in ord()\n    assertQEx(\"Should fail as no field is specified in ord func\",\n        \"Expected identifier instead of 'null' for function 'ord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"ord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as no field is specified in rord func\",\n        \"Expected identifier instead of 'null' for function 'rord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"rord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // test parseFloat\n    assertQEx(\"Should fail as less args are specified for recip func\",\n        \"Expected float instead of 'null' for function 'recip(1,2)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as invalid value is specified for recip func\",\n        \"Expected float instead of 'f' for function 'recip(1,2,3,f)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2,3,f)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    // this should pass\n    assertQ(req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1, 2, 3, 4)\"));\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4","date":1551083645,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n\n    // test a query that doesn't specify nested query val\n    assertQEx(\"Should fail because of missing qq\",\n        \"Missing param qq while parsing function 'query($qq)'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing sortfunc in sort\",\n        \"Can't determine a Sort Order (asc or desc) in sort spec '{!func v=$sortfunc} desc'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing qq in boost\",\n        \"Nested local params must have value in v parameter.  got 'query({!dismax v=$qq})\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query({!dismax v=$qq})\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as empty value is specified for v\",\n        \"Nested function query returned null for 'query({!v=})'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=})\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as v's value contains only spaces\",\n        \"Nested function query returned null for 'query({!v=   })'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=   })\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // no field specified in ord()\n    assertQEx(\"Should fail as no field is specified in ord func\",\n        \"Expected identifier instead of 'null' for function 'ord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"ord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as no field is specified in rord func\",\n        \"Expected identifier instead of 'null' for function 'rord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"rord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // test parseFloat\n    assertQEx(\"Should fail as less args are specified for recip func\",\n        \"Expected float instead of 'null' for function 'recip(1,2)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as invalid value is specified for recip func\",\n        \"Expected float instead of 'f' for function 'recip(1,2,3,f)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2,3,f)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    // this should pass\n    assertQ(req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1, 2, 3, 4)\"));\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bfbf198e7b508d265bd0866ac8449bf67579fed","date":1562734075,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/function/TestFunctionQuery#testGeneral().mjava","sourceNew":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n\n    // test a query that doesn't specify nested query val\n    assertQEx(\"Should fail because of missing qq\",\n        \"Missing param qq while parsing function 'query($qq)'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing sortfunc in sort\",\n        \"Can't determine a Sort Order (asc or desc) in sort spec '{!func v=$sortfunc} desc'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing qq in boost\",\n        \"Nested local params must have value in v parameter.  got 'query({!dismax v=$qq})\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query({!dismax v=$qq})\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as empty value is specified for v\",\n        \"Nested function query returned null for 'query({!v=})'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=})\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as v's value contains only spaces\",\n        \"Nested function query returned null for 'query({!v=   })'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=   })\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // no field specified in ord()\n    assertQEx(\"Should fail as no field is specified in ord func\",\n        \"Expected identifier instead of 'null' for function 'ord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"ord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as no field is specified in rord func\",\n        \"Expected identifier instead of 'null' for function 'rord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"rord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // test parseFloat\n    assertQEx(\"Should fail as less args are specified for recip func\",\n        \"Expected float instead of 'null' for function 'recip(1,2)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as invalid value is specified for recip func\",\n        \"Expected float instead of 'f' for function 'recip(1,2,3,f)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2,3,f)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    // this should pass\n    assertQ(req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1, 2, 3, 4)\"));\n\n    // for undefined field NPE shouldn't be thrown\n    assertQEx(\"Should Fail as the field is undefined\", \"undefined field a\",\n        req(\"q\", \"*:*\", \"fl\", \"x:payload(a,b)\"), SolrException.ErrorCode.BAD_REQUEST);\n  }\n\n","sourceOld":"  @Test\n  public void testGeneral() throws Exception {\n    clearIndex();\n    \n    assertU(adoc(\"id\",\"1\", \"a_tdt\",\"2009-08-31T12:10:10.123Z\", \"b_tdt\",\"2009-08-31T12:10:10.124Z\"));\n    assertU(adoc(\"id\",\"2\", \"a_t\",\"how now brown cow\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"3\", \"a_t\",\"brown cow\"));\n    assertU(adoc(\"id\",\"4\"));\n    assertU(commit()); // create more than one segment\n    assertU(adoc(\"id\",\"5\"));\n    assertU(adoc(\"id\",\"6\", \"a_t\",\"cow cow cow cow cow\"));\n    assertU(commit());\n\n    // test relevancy functions\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}numdocs()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}maxdoc()\", \"fq\",\"id:6\"), \"//float[@name='score']='6.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq('a_t','cow')\", \"fq\",\"id:6\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq($field,$value)\", \"fq\",\"id:6\", \"field\",\"a_t\", \"value\",\"cow\"), \"//float[@name='score']='3.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(a_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n\n    // make sure it doesn't get a NPE if no terms are present in a field.\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}termfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}docfreq(nofield_t,cow)\", \"fq\",\"id:6\"), \"//float[@name='score']='0.0'\");\n    \n    // test that ord and rord are working on a global index basis, not just\n    // at the segment level (since Lucene 2.9 has switched to per-segment searching)\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ord(id)\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(ord(id))\", \"fq\",\"id:6\"), \"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}rord(id)\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}top(rord(id))\", \"fq\",\"id:1\"),\"//float[@name='score']='5.0'\");\n\n\n    // test that we can subtract dates to millisecond precision\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(a_tdt,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(b_tdt,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,2009-08-31T12:10:10.124Z)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.124Z,a_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z,b_tdt)\", \"fq\",\"id:1\"), \"//float[@name='score']='1.0'\");\n\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(2009-08-31T12:10:10.125Z/SECOND,2009-08-31T12:10:10.124Z/SECOND)\", \"fq\",\"id:1\"), \"//float[@name='score']='0.0'\");\n\n    // test that we can specify \"NOW\"\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}ms(NOW)\", \"NOW\",\"1000\"), \"//float[@name='score']='1000.0'\");\n\n\n    for (int i=100; i<112; i++) {\n      assertU(adoc(\"id\",\"\"+i, \"text\",\"batman\"));\n    }\n    assertU(commit());\n    assertU(adoc(\"id\",\"120\", \"text\",\"batman superman\"));   // in a smaller segment\n    assertU(adoc(\"id\",\"121\", \"text\",\"superman junkterm\"));\n    assertU(commit());\n\n    // superman has a higher df (thus lower idf) in one segment, but reversed in the complete index\n    String q =\"{!func}query($qq)\";\n    String fq=\"id:120\"; \n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n    // test weighting through a function range query\n    assertQ(req(\"fl\",\"*,score\", \"fq\",fq,  \"q\", \"{!frange l=0.6 u=10}query($qq)\", \"qq\",\"text:superman\"), \"//*[@numFound='1']\");\n\n    // test weighting through a complex function\n    q =\"{!func}sub(div(sum(0.0,product(1,query($qq))),1),0)\";\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:batman\", \"fq\",fq), \"//float[@name='score']<'0.6'\");\n    assertQ(req(\"fl\",\"*,score\",\"q\", q, \"qq\",\"text:superman\", \"fq\",fq), \"//float[@name='score']>'0.6'\");\n\n\n    // test full param dereferencing\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}add($v1,$v2)\", \"v1\",\"add($v3,$v4)\", \"v2\",\"1\", \"v3\",\"2\", \"v4\",\"5\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='8.0'\");\n\n    // test ability to parse multiple values\n    assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}dist(2,vector(1,1),$pt)\", \"pt\",\"3,1\"\n        , \"fq\",\"id:1\"), \"//float[@name='score']='2.0'\");\n\n    // test that extra stuff after a function causes an error\n    try {\n      assertQ(req(\"fl\",\"*,score\",\"q\", \"{!func}10 wow dude ignore_exception\"));\n      fail();\n    } catch (Exception e) {\n      // OK\n    }\n\n    // test that sorting by function query weights correctly.  superman should sort higher than batman due to idf of the whole index\n\n    assertQ(req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\", \"qq\",\"text:(batman OR superman)\")\n           ,\"*//doc[1]/str[.='120']\"\n           ,\"*//doc[2]/str[.='121']\"\n    );\n\n    // test a query that doesn't specify nested query val\n    assertQEx(\"Should fail because of missing qq\",\n        \"Missing param qq while parsing function 'query($qq)'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing sortfunc in sort\",\n        \"Can't determine a Sort Order (asc or desc) in sort spec '{!func v=$sortfunc} desc'\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"sort\",\"{!func v=$sortfunc} desc\", \"sortfunc\",\"query($qq)\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail because of missing qq in boost\",\n        \"Nested local params must have value in v parameter.  got 'query({!dismax v=$qq})\",\n        req(\"q\", \"*:*\", \"fq\",\"id:120 OR id:121\", \"defType\",\"edismax\", \"boost\",\"query({!dismax v=$qq})\"),\n        SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as empty value is specified for v\",\n        \"Nested function query returned null for 'query({!v=})'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=})\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as v's value contains only spaces\",\n        \"Nested function query returned null for 'query({!v=   })'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\", \"boost\",\"query({!v=   })\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // no field specified in ord()\n    assertQEx(\"Should fail as no field is specified in ord func\",\n        \"Expected identifier instead of 'null' for function 'ord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"ord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as no field is specified in rord func\",\n        \"Expected identifier instead of 'null' for function 'rord()'\",\n        req(\"q\", \"*:*\", \"defType\",\"edismax\",\"boost\",\"rord()\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n\n    // test parseFloat\n    assertQEx(\"Should fail as less args are specified for recip func\",\n        \"Expected float instead of 'null' for function 'recip(1,2)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    assertQEx(\"Should fail as invalid value is specified for recip func\",\n        \"Expected float instead of 'f' for function 'recip(1,2,3,f)'\",\n        req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1,2,3,f)\"), SolrException.ErrorCode.BAD_REQUEST\n    );\n    // this should pass\n    assertQ(req(\"q\", \"*:*\",\"defType\",\"edismax\", \"boost\",\"recip(1, 2, 3, 4)\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2bfbf198e7b508d265bd0866ac8449bf67579fed":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"49dd2950028d6b59839f54d3801d77f769fa22ef":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9507caf22f292ac0e5e59f62db4275adf4511"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["49dd2950028d6b59839f54d3801d77f769fa22ef"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"56572ec06f1407c066d6b7399413178b33176cd8":["19275ba31e621f6da1b83bf13af75233876fd3d4","93dd449115a9247533e44bab47e8429e5dccbc6d"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"10d98d3c84fcfdd2089a56054f4cf7186a57265d":["e28b14e7783d24ca69089f13ddadadbd2afdcb29"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0837ab0472feecb3a54260729d845f839e1cbd72":["6e2893fd5349134af382d33ccc3d84840394c6c1"],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["d4d69c535930b5cce125cff868d40f6373dc27d4","19275ba31e621f6da1b83bf13af75233876fd3d4"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["49dd2950028d6b59839f54d3801d77f769fa22ef","a71f63026529f3c1f03cfdd664910873ab2369ae"],"9e8d5a6ffbfa3405d234a87c833741eabed98d13":["c26f00b574427b55127e869b935845554afde1fa"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["5da0b42730b6b99b31389ef94cb97384e83b9ede","0837ab0472feecb3a54260729d845f839e1cbd72"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["19275ba31e621f6da1b83bf13af75233876fd3d4","10d98d3c84fcfdd2089a56054f4cf7186a57265d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"da56d90379fbe988bf847d3482efa685803c5193":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["da56d90379fbe988bf847d3482efa685803c5193"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["da56d90379fbe988bf847d3482efa685803c5193","efff98a8632f3c2f5b05f961e22a67f122db81e0"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["49dd2950028d6b59839f54d3801d77f769fa22ef","a71f63026529f3c1f03cfdd664910873ab2369ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2bfbf198e7b508d265bd0866ac8449bf67579fed"]},"commit2Childs":{"2bfbf198e7b508d265bd0866ac8449bf67579fed":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"49dd2950028d6b59839f54d3801d77f769fa22ef":["a71f63026529f3c1f03cfdd664910873ab2369ae","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"c26f00b574427b55127e869b935845554afde1fa":["9e8d5a6ffbfa3405d234a87c833741eabed98d13"],"a71f63026529f3c1f03cfdd664910873ab2369ae":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["56572ec06f1407c066d6b7399413178b33176cd8","e28b14e7783d24ca69089f13ddadadbd2afdcb29","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","93dd449115a9247533e44bab47e8429e5dccbc6d"],"1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["49dd2950028d6b59839f54d3801d77f769fa22ef"],"10d98d3c84fcfdd2089a56054f4cf7186a57265d":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["c26f00b574427b55127e869b935845554afde1fa"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["6e2893fd5349134af382d33ccc3d84840394c6c1","d4d69c535930b5cce125cff868d40f6373dc27d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"0837ab0472feecb3a54260729d845f839e1cbd72":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["10d98d3c84fcfdd2089a56054f4cf7186a57265d"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"6e2893fd5349134af382d33ccc3d84840394c6c1":["0837ab0472feecb3a54260729d845f839e1cbd72"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["da56d90379fbe988bf847d3482efa685803c5193"],"28288370235ed02234a64753cdbf0c6ec096304a":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["19275ba31e621f6da1b83bf13af75233876fd3d4","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"9e8d5a6ffbfa3405d234a87c833741eabed98d13":["1ab42b0756bdd98ac6a6767b5a77d10d9ba12b4b"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","81d0720146de53dd3a4a023d2a3d1089d86d748d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["f0b9507caf22f292ac0e5e59f62db4275adf4511"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["f0b9507caf22f292ac0e5e59f62db4275adf4511"],"da56d90379fbe988bf847d3482efa685803c5193":["efff98a8632f3c2f5b05f961e22a67f122db81e0","0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"efff98a8632f3c2f5b05f961e22a67f122db81e0":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["2bfbf198e7b508d265bd0866ac8449bf67579fed"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}