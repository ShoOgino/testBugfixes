{"path":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   */\n  public LevenshteinAutomata(String input) {\n    this.input = input;\n    this.word = input.toCharArray();\n    \n    // calculate the alphabet\n    SortedSet<Character> set = new TreeSet<Character>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new char[set.size()];\n    Iterator<Character> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new char[alphabet.length + 2];\n    rangeUpper = new char[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      char higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = (char) lower;\n        rangeUpper[numRanges] = (char) (higher - 1);\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= 0xFFFF) {\n      rangeLower[numRanges] = (char) lower;\n      rangeUpper[numRanges] = '\\uFFFF';\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        new Lev1ParametricDescription(input.length()),\n        new Lev2ParametricDescription(input.length()),\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   */\n  public LevenshteinAutomata(String input) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        new Lev1ParametricDescription(word.length),\n        new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   */\n  public LevenshteinAutomata(String input) {\n    this.input = input;\n    this.word = input.toCharArray();\n    \n    // calculate the alphabet\n    SortedSet<Character> set = new TreeSet<Character>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new char[set.size()];\n    Iterator<Character> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new char[alphabet.length + 2];\n    rangeUpper = new char[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      char higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = (char) lower;\n        rangeUpper[numRanges] = (char) (higher - 1);\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= 0xFFFF) {\n      rangeLower[numRanges] = (char) lower;\n      rangeUpper[numRanges] = '\\uFFFF';\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        new Lev1ParametricDescription(input.length()),\n        new Lev2ParametricDescription(input.length()),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab","date":1324934316,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   */\n  public LevenshteinAutomata(String input) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        new Lev1ParametricDescription(word.length),\n        new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"]},"commit2Childs":{"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}