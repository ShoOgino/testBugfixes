{"path":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","commits":[{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (dir.fileExists(getNormFileName(i))) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8969a184df55d25d61e85be785987fbf830d4028","date":1168143561,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (dir.fileExists(getNormFileName(i))) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051","date":1173376751,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b685e89f45e34ea31f9ca89912e4f29038818ff6","date":1173986546,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >\n      // 0 (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] > 0) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == 0) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f33fc116e28d7704378c9dd333711753bd0c9706","date":1248010179,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  public boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eaea03be31988a41275d45a429ac71ff0ad740fb","date":1254612554,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  public boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.listAll();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": listAll() returned null\");\n\n        final IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          String fileName = result[i];\n          if (filter.accept(null, fileName) && fileName.startsWith(pattern) && Character.isDigit(fileName.charAt(patternLength)))\n              return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  public boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.list();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": list() returned null\");\n        \n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))\n            return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfo#hasSeparateNorms().mjava","sourceNew":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  public boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.listAll();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": listAll() returned null\");\n\n        final IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          String fileName = result[i];\n          if (filter.accept(null, fileName) && fileName.startsWith(pattern) && Character.isDigit(fileName.charAt(patternLength)))\n              return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns true if any fields in this segment have separate norms.\n   */\n  public boolean hasSeparateNorms()\n    throws IOException {\n    if (normGen == null) {\n      if (!preLockless) {\n        // This means we were created w/ LOCKLESS code and no\n        // norms are written yet:\n        return false;\n      } else {\n        // This means this segment was saved with pre-LOCKLESS\n        // code.  So we must fallback to the original\n        // directory list check:\n        String[] result = dir.listAll();\n        if (result == null)\n          throw new IOException(\"cannot read directory \" + dir + \": listAll() returned null\");\n\n        final IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n        String pattern;\n        pattern = name + \".s\";\n        int patternLength = pattern.length();\n        for(int i = 0; i < result.length; i++){\n          String fileName = result[i];\n          if (filter.accept(null, fileName) && fileName.startsWith(pattern) && Character.isDigit(fileName.charAt(patternLength)))\n              return true;\n        }\n        return false;\n      }\n    } else {\n      // This means this segment was saved with LOCKLESS\n      // code so we first check whether any normGen's are >= 1\n      // (meaning they definitely have separate norms):\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] >= YES) {\n          return true;\n        }\n      }\n      // Next we look for any == 0.  These cases were\n      // pre-LOCKLESS and must be checked in directory:\n      for(int i=0;i<normGen.length;i++) {\n        if (normGen[i] == CHECK_DIR) {\n          if (hasSeparateNorms(i)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eaea03be31988a41275d45a429ac71ff0ad740fb":["f33fc116e28d7704378c9dd333711753bd0c9706"],"f33fc116e28d7704378c9dd333711753bd0c9706":["b685e89f45e34ea31f9ca89912e4f29038818ff6"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b685e89f45e34ea31f9ca89912e4f29038818ff6":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["8969a184df55d25d61e85be785987fbf830d4028"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8969a184df55d25d61e85be785987fbf830d4028":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["eaea03be31988a41275d45a429ac71ff0ad740fb"]},"commit2Childs":{"eaea03be31988a41275d45a429ac71ff0ad740fb":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"f33fc116e28d7704378c9dd333711753bd0c9706":["eaea03be31988a41275d45a429ac71ff0ad740fb"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["8969a184df55d25d61e85be785987fbf830d4028"],"b685e89f45e34ea31f9ca89912e4f29038818ff6":["f33fc116e28d7704378c9dd333711753bd0c9706"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["b685e89f45e34ea31f9ca89912e4f29038818ff6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"8969a184df55d25d61e85be785987fbf830d4028":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}