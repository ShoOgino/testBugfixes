{"path":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","commits":[{"id":"400558e34d57baf6a8e8c42d60fc1a87b5acb596","date":1405940665,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"/dev/null","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8249072f13ea4354ab7635c2d7a59cc682806dab","402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.shutdown();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad2a673349939e48652bf304cccf673c3412198f","date":1409585169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      // Can only use sort missing if the DVFormat\n      // supports docsWithField:\n      sortMissingLast = defaultCodecSupportsDocsWithField() && random().nextBoolean();\n      missingIsNull = defaultCodecSupportsDocsWithField();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          if (br == null && missingIsNull == false) {\n            br = new BytesRef();\n          }\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n        if (br == null && missingIsNull == false) {\n          br = new BytesRef();\n        }\n\n        // Normally, the old codecs (that don't support\n        // docsWithField via doc values) will always return\n        // an empty BytesRef for the missing case; however,\n        // if all docs in a given segment were missing, in\n        // that case it will return null!  So we must map\n        // null here, too:\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        if (br2 == null && missingIsNull == false) {\n          br2 = new BytesRef();\n        }\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8249072f13ea4354ab7635c2d7a59cc682806dab","date":1429649774,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq.build(), f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      final boolean missingIsNull;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq, f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(new ConstantScoreQuery(f),\n                      hitCount, sort, random.nextBoolean(), random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      int queryType = random.nextInt(2);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery.Builder bq = new BooleanQuery.Builder();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(new FilteredQuery(bq.build(), f), hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d52e48927ca4ef3655a261f2230b968b6fdf3608","date":1444652107,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(new ConstantScoreQuery(f),\n                      hitCount, sort, random.nextBoolean(), random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort(SortField.Type).mjava","sourceNew":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, false);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  private void testRandomStringSort(SortField.Type type) throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<>();\n    final int maxLength = TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final Document doc = new Document();\n\n      // 10% of the time, the document is missing the value:\n      final BytesRef br;\n      if (random().nextInt(10) != 7) {\n        final String s;\n        if (random.nextBoolean()) {\n          s = TestUtil.randomSimpleString(random, maxLength);\n        } else {\n          s = TestUtil.randomUnicodeString(random, maxLength);\n        }\n\n        if (!allowDups) {\n          if (seen.contains(s)) {\n            continue;\n          }\n          seen.add(s);\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": s=\" + s);\n        }\n\n        br = new BytesRef(s);\n        doc.add(new SortedDocValuesField(\"stringdv\", br));\n        docValues.add(br);\n\n      } else {\n        br = null;\n        if (VERBOSE) {\n          System.out.println(\"  \" + numDocs + \": <missing>\");\n        }\n        docValues.add(null);\n      }\n\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      doc.add(new StoredField(\"id\", numDocs));\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n\n      final TopFieldDocs hits;\n      final SortField sf;\n      final boolean sortMissingLast;\n      sf = new SortField(\"stringdv\", type, reverse);\n      sortMissingLast = random().nextBoolean();\n\n      if (sortMissingLast) {\n        sf.setMissingValue(SortField.STRING_LAST);\n      }\n      \n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);\n      hits = s.search(f, hitCount, sort, random.nextBoolean());\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse + \"; sortMissingLast=\" + sortMissingLast + \" sort=\" + sort);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues, new Comparator<BytesRef>() {\n          @Override\n          public int compare(BytesRef a, BytesRef b) {\n            if (a == null) {\n              if (b == null) {\n                return 0;\n              }\n              if (sortMissingLast) {\n                return 1;\n              } else {\n                return -1;\n              }\n            } else if (b == null) {\n              if (sortMissingLast) {\n                return -1;\n              } else {\n                return 1;\n              }\n            } else {\n              return a.compareTo(b);\n            }\n          }\n        });\n\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          BytesRef br = expected.get(idx);\n          System.out.println(\"    \" + idx + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()));\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          BytesRef br = (BytesRef) fd.fields[0];\n\n          System.out.println(\"    \" + hitIDX + \": \" + (br == null ? \"<missing>\" : br.utf8ToString()) + \" id=\" + s.doc(fd.doc).get(\"id\"));\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        BytesRef br = expected.get(hitIDX);\n\n        BytesRef br2 = (BytesRef) fd.fields[0];\n        \n        assertEquals(br, br2);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["d0ef034a4f10871667ae75181537775ddcf8ade4","ad2a673349939e48652bf304cccf673c3412198f"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"1db68e96dd908fcd79ef809095822736aa601d08":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["d52e48927ca4ef3655a261f2230b968b6fdf3608","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["1db68e96dd908fcd79ef809095822736aa601d08"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"8249072f13ea4354ab7635c2d7a59cc682806dab":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"ad2a673349939e48652bf304cccf673c3412198f":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d3f7ab1a502671bbdb03bcced21e764d2483221"]},"commit2Childs":{"400558e34d57baf6a8e8c42d60fc1a87b5acb596":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["1db68e96dd908fcd79ef809095822736aa601d08"],"1db68e96dd908fcd79ef809095822736aa601d08":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"d52e48927ca4ef3655a261f2230b968b6fdf3608":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["400558e34d57baf6a8e8c42d60fc1a87b5acb596"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["8249072f13ea4354ab7635c2d7a59cc682806dab"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","ad2a673349939e48652bf304cccf673c3412198f"],"8249072f13ea4354ab7635c2d7a59cc682806dab":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["1d3f7ab1a502671bbdb03bcced21e764d2483221","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"ad2a673349939e48652bf304cccf673c3412198f":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}