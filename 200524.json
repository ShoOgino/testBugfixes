{"path":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","commits":[{"id":"5a07459b30549ba2b7b6ff6ab0a28200e60b0294","date":1431450341,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName, String textFieldName) throws IOException {\n\n    Map<String, Map<String, Long>> counts = new HashMap<>();\n\n    for (int i = 0; i < reader.maxDoc(); i++) {\n      StoredDocument doc = reader.document(i);\n      String correctAnswer = doc.get(classFieldName);\n\n      if (correctAnswer != null && correctAnswer.length() > 0) {\n\n        ClassificationResult<T> result = classifier.assignClass(doc.get(textFieldName));\n        T assignedClass = result.getAssignedClass();\n        String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n        Map<String, Long> stringLongMap = counts.get(correctAnswer);\n        if (stringLongMap != null) {\n          Long aLong = stringLongMap.get(classified);\n          if (aLong != null) {\n            stringLongMap.put(classified, aLong + 1);\n          } else {\n            stringLongMap.put(classified, 1l);\n          }\n        } else {\n          stringLongMap = new HashMap<>();\n          stringLongMap.put(classified, 1l);\n          counts.put(correctAnswer, stringLongMap);\n        }\n\n      }\n    }\n    return new ConfusionMatrix(counts);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ba9b7b122d927a15ff4837e3d72876c609fef1b","date":1441232513,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1);\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new WildcardQuery(new Term(classFieldName, \"*\")), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String correctAnswer = doc.get(classFieldName);\n\n        if (correctAnswer != null && correctAnswer.length() > 0) {\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName, String textFieldName) throws IOException {\n\n    Map<String, Map<String, Long>> counts = new HashMap<>();\n\n    for (int i = 0; i < reader.maxDoc(); i++) {\n      StoredDocument doc = reader.document(i);\n      String correctAnswer = doc.get(classFieldName);\n\n      if (correctAnswer != null && correctAnswer.length() > 0) {\n\n        ClassificationResult<T> result = classifier.assignClass(doc.get(textFieldName));\n        T assignedClass = result.getAssignedClass();\n        String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n        Map<String, Long> stringLongMap = counts.get(correctAnswer);\n        if (stringLongMap != null) {\n          Long aLong = stringLongMap.get(classified);\n          if (aLong != null) {\n            stringLongMap.put(classified, aLong + 1);\n          } else {\n            stringLongMap.put(classified, 1l);\n          }\n        } else {\n          stringLongMap = new HashMap<>();\n          stringLongMap.put(classified, 1l);\n          counts.put(correctAnswer, stringLongMap);\n        }\n\n      }\n    }\n    return new ConfusionMatrix(counts);\n  }\n\n","bugFix":null,"bugIntro":["cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3356f545614a071c3f06030f216740052069f075","date":1441259415,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new WildcardQuery(new Term(classFieldName, \"*\")), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String correctAnswer = doc.get(classFieldName);\n\n        if (correctAnswer != null && correctAnswer.length() > 0) {\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1);\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new WildcardQuery(new Term(classFieldName, \"*\")), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String correctAnswer = doc.get(classFieldName);\n\n        if (correctAnswer != null && correctAnswer.length() > 0) {\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c707e50d5d9db6929b753b3c0b0254186ee0986","date":1445602910,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new WildcardQuery(new Term(classFieldName, \"*\")), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String correctAnswer = doc.get(classFieldName);\n\n        if (correctAnswer != null && correctAnswer.length() > 0) {\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        StoredDocument doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2","date":1459428331,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1l);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1l);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":["9ba9b7b122d927a15ff4837e3d72876c609fef1b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299","date":1460106403,"type":5,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String,long).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/utils/ConfusionMatrixGenerator#[T]_getConfusionMatrix(LeafReader,Classifier[T],String,String).mjava","sourceNew":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader              the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier          the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName      the name of the Lucene field used as the classifier's output\n   * @param textFieldName       the nome the Lucene field used as the classifier's input\n   * @param timeoutMilliseconds timeout to wait before stopping creating the confusion matrix\n   * @param <T>                 the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName, long timeoutMilliseconds) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      int counter = 0;\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n\n        if (timeoutMilliseconds > 0 && time >= timeoutMilliseconds) {\n          break;\n        }\n\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  counter++;\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add classification timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / counter, counter);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","sourceOld":"  /**\n   * get the {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix} of a given {@link Classifier},\n   * generated on the given {@link LeafReader}, class and text fields.\n   *\n   * @param reader         the {@link LeafReader} containing the index used for creating the {@link Classifier}\n   * @param classifier     the {@link Classifier} whose confusion matrix has to be generated\n   * @param classFieldName the name of the Lucene field used as the classifier's output\n   * @param textFieldName  the nome the Lucene field used as the classifier's input\n   * @param <T>            the return type of the {@link ClassificationResult} returned by the given {@link Classifier}\n   * @return a {@link org.apache.lucene.classification.utils.ConfusionMatrixGenerator.ConfusionMatrix}\n   * @throws IOException if problems occurr while reading the index or using the classifier\n   */\n  public static <T> ConfusionMatrix getConfusionMatrix(LeafReader reader, Classifier<T> classifier, String classFieldName,\n                                                       String textFieldName) throws IOException {\n\n    ExecutorService executorService = Executors.newFixedThreadPool(1, new NamedThreadFactory(\"confusion-matrix-gen-\"));\n\n    try {\n\n      Map<String, Map<String, Long>> counts = new HashMap<>();\n      IndexSearcher indexSearcher = new IndexSearcher(reader);\n      TopDocs topDocs = indexSearcher.search(new TermRangeQuery(classFieldName, null, null, true, true), Integer.MAX_VALUE);\n      double time = 0d;\n\n      for (ScoreDoc scoreDoc : topDocs.scoreDocs) {\n        Document doc = reader.document(scoreDoc.doc);\n        String[] correctAnswers = doc.getValues(classFieldName);\n\n        if (correctAnswers != null && correctAnswers.length > 0) {\n          Arrays.sort(correctAnswers);\n          ClassificationResult<T> result;\n          String text = doc.get(textFieldName);\n          if (text != null) {\n            try {\n              // fail if classification takes more than 5s\n              long start = System.currentTimeMillis();\n              result = executorService.submit(() -> classifier.assignClass(text)).get(5, TimeUnit.SECONDS);\n              long end = System.currentTimeMillis();\n              time += end - start;\n\n              if (result != null) {\n                T assignedClass = result.getAssignedClass();\n                if (assignedClass != null) {\n                  String classified = assignedClass instanceof BytesRef ? ((BytesRef) assignedClass).utf8ToString() : assignedClass.toString();\n\n                  String correctAnswer;\n                  if (Arrays.binarySearch(correctAnswers, classified) >= 0) {\n                    correctAnswer = classified;\n                  } else {\n                    correctAnswer = correctAnswers[0];\n                  }\n\n                  Map<String, Long> stringLongMap = counts.get(correctAnswer);\n                  if (stringLongMap != null) {\n                    Long aLong = stringLongMap.get(classified);\n                    if (aLong != null) {\n                      stringLongMap.put(classified, aLong + 1);\n                    } else {\n                      stringLongMap.put(classified, 1L);\n                    }\n                  } else {\n                    stringLongMap = new HashMap<>();\n                    stringLongMap.put(classified, 1L);\n                    counts.put(correctAnswer, stringLongMap);\n                  }\n\n                }\n              }\n            } catch (TimeoutException timeoutException) {\n              // add timeout\n              time += 5000;\n            } catch (ExecutionException | InterruptedException executionException) {\n              throw new RuntimeException(executionException);\n            }\n\n          }\n        }\n      }\n      return new ConfusionMatrix(counts, time / topDocs.totalHits, topDocs.totalHits);\n    } finally {\n      executorService.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"9ba9b7b122d927a15ff4837e3d72876c609fef1b":["5a07459b30549ba2b7b6ff6ab0a28200e60b0294"],"5a07459b30549ba2b7b6ff6ab0a28200e60b0294":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299":["cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2"],"3356f545614a071c3f06030f216740052069f075":["9ba9b7b122d927a15ff4837e3d72876c609fef1b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2","eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299"],"2c707e50d5d9db6929b753b3c0b0254186ee0986":["3356f545614a071c3f06030f216740052069f075"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["2c707e50d5d9db6929b753b3c0b0254186ee0986"]},"commit2Childs":{"cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2":["eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"9ba9b7b122d927a15ff4837e3d72876c609fef1b":["3356f545614a071c3f06030f216740052069f075"],"5a07459b30549ba2b7b6ff6ab0a28200e60b0294":["9ba9b7b122d927a15ff4837e3d72876c609fef1b"],"eff5db4d2f0dea2783c3351ff4b5b9e63e0b5299":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"3356f545614a071c3f06030f216740052069f075":["2c707e50d5d9db6929b753b3c0b0254186ee0986"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a07459b30549ba2b7b6ff6ab0a28200e60b0294"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c707e50d5d9db6929b753b3c0b0254186ee0986":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["cbc45ebd0910e885a4f2680ecb1875d36ca3d0e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}