{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#toBytes(ISchemaVersion).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#toBytes(ISchemaVersion).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Serializes the HLL to an array of bytes in correspondence with the format\n     * of the specified schema version.\n     *\n     * @param  schemaVersion the schema version dictating the serialization format\n     * @return the array of bytes representing the HLL. This will never be\n     *         <code>null</code> or empty.\n     */\n    public byte[] toBytes(final ISchemaVersion schemaVersion) {\n        final byte[] bytes;\n        switch(type) {\n            case EMPTY:\n                bytes = new byte[schemaVersion.paddingBytes(type)];\n                break;\n            case EXPLICIT: {\n                final IWordSerializer serializer =\n                    schemaVersion.getSerializer(type, Long.SIZE, explicitStorage.size());\n\n                final long[] values = explicitStorage.toArray();\n                Arrays.sort(values);\n                for(final long value : values) {\n                    serializer.writeWord(value);\n                }\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            case SPARSE: {\n                final IWordSerializer serializer =\n                        schemaVersion.getSerializer(type, shortWordLength, sparseProbabilisticStorage.size());\n\n                final int[] indices = sparseProbabilisticStorage.keys().toArray();\n                Arrays.sort(indices);\n                for(final int registerIndex : indices) {\n                    assert sparseProbabilisticStorage.containsKey(registerIndex);\n                    final long registerValue = sparseProbabilisticStorage.get(registerIndex);\n                    // pack index and value into \"short word\"\n                    final long shortWord = ((registerIndex << regwidth) | registerValue);\n                    serializer.writeWord(shortWord);\n                }\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            case FULL: {\n                final IWordSerializer serializer = schemaVersion.getSerializer(type, regwidth, m);\n                probabilisticStorage.getRegisterContents(serializer);\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n\n        final IHLLMetadata metadata = new HLLMetadata(schemaVersion.schemaVersionNumber(),\n                                                      type,\n                                                      log2m,\n                                                      regwidth,\n                                                      (int)NumberUtil.log2(explicitThreshold),\n                                                      explicitOff,\n                                                      explicitAuto,\n                                                      !sparseOff);\n        schemaVersion.writeMetadata(bytes, metadata);\n\n        return bytes;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#toBytes(ISchemaVersion).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Serializes the HLL to an array of bytes in correspondence with the format\n     * of the specified schema version.\n     *\n     * @param  schemaVersion the schema version dictating the serialization format\n     * @return the array of bytes representing the HLL. This will never be\n     *         <code>null</code> or empty.\n     */\n    public byte[] toBytes(final ISchemaVersion schemaVersion) {\n        final byte[] bytes;\n        switch(type) {\n            case EMPTY:\n                bytes = new byte[schemaVersion.paddingBytes(type)];\n                break;\n            case EXPLICIT: {\n                final IWordSerializer serializer =\n                    schemaVersion.getSerializer(type, Long.SIZE, explicitStorage.size());\n\n                final long[] values = explicitStorage.toArray();\n                Arrays.sort(values);\n                for(final long value : values) {\n                    serializer.writeWord(value);\n                }\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            case SPARSE: {\n                final IWordSerializer serializer =\n                        schemaVersion.getSerializer(type, shortWordLength, sparseProbabilisticStorage.size());\n\n                final int[] indices = sparseProbabilisticStorage.keys().toArray();\n                Arrays.sort(indices);\n                for(final int registerIndex : indices) {\n                    assert sparseProbabilisticStorage.containsKey(registerIndex);\n                    final long registerValue = sparseProbabilisticStorage.get(registerIndex);\n                    // pack index and value into \"short word\"\n                    final long shortWord = ((registerIndex << regwidth) | registerValue);\n                    serializer.writeWord(shortWord);\n                }\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            case FULL: {\n                final IWordSerializer serializer = schemaVersion.getSerializer(type, regwidth, m);\n                probabilisticStorage.getRegisterContents(serializer);\n\n                bytes = serializer.getBytes();\n                break;\n            }\n            default:\n                throw new RuntimeException(\"Unsupported HLL type \" + type);\n        }\n\n        final IHLLMetadata metadata = new HLLMetadata(schemaVersion.schemaVersionNumber(),\n                                                      type,\n                                                      log2m,\n                                                      regwidth,\n                                                      (int)NumberUtil.log2(explicitThreshold),\n                                                      explicitOff,\n                                                      explicitAuto,\n                                                      !sparseOff);\n        schemaVersion.writeMetadata(bytes, metadata);\n\n        return bytes;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}