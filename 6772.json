{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint,Plane).mjava","commits":[{"id":"4417cae689ce0fc964a3546ded2b0ab6e374f1b0","date":1523635542,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint,Plane).mjava","pathOld":"/dev/null","sourceNew":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   * Returns null if the planes are effectively parallel and reasonable adjoining points cannot be determined.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane, final Plane envelopePlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    double distanceFactor = 0.0;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n      distanceFactor += DELTA_DISTANCE;\n      // Compute two new points along this vector from the original\n      final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * distanceFactor,\n        pointOnPlane.y + perpendicular.y * distanceFactor,\n        pointOnPlane.z + perpendicular.z * distanceFactor);\n      final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * distanceFactor,\n        pointOnPlane.y - perpendicular.y * distanceFactor,\n        pointOnPlane.z - perpendicular.z * distanceFactor);\n      if (Math.abs(envelopePlane.evaluate(pointA)) > OFF_PLANE_AMOUNT && Math.abs(envelopePlane.evaluate(pointB)) > OFF_PLANE_AMOUNT) {\n        //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n        return new GeoPoint[]{pointA, pointB};\n      }\n      // Loop back around and use a bigger delta\n    }\n    // Had to abort, so return null.\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cd25c083a7199445f2db6f32d322eeac1afc99e","date":1527642183,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#findAdjoiningPoints(Plane,GeoPoint,Plane).mjava","sourceNew":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   * Returns null if the planes are effectively parallel and reasonable adjoining points cannot be determined.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane, final Plane envelopePlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    double distanceFactor = 0.0;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n      distanceFactor += DELTA_DISTANCE;\n      // Compute two new points along this vector from the original\n      final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * distanceFactor,\n        pointOnPlane.y + perpendicular.y * distanceFactor,\n        pointOnPlane.z + perpendicular.z * distanceFactor);\n      final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * distanceFactor,\n        pointOnPlane.y - perpendicular.y * distanceFactor,\n        pointOnPlane.z - perpendicular.z * distanceFactor);\n      if (Math.abs(envelopePlane.evaluate(pointA)) > OFF_PLANE_AMOUNT && Math.abs(envelopePlane.evaluate(pointB)) > OFF_PLANE_AMOUNT) {\n        //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n        return new GeoPoint[]{pointA, pointB};\n      }\n      // Loop back around and use a bigger delta\n    }\n    // Had to abort, so return null.\n    //System.out.println(\"     Adjoining points not found.  Are planes parallel?  edge = \"+plane+\"; envelope = \"+envelopePlane+\"; perpendicular = \"+perpendicular);\n    return null;\n  }\n\n","sourceOld":"  /** Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points on either side of the plane, which are\n   * about MINIMUM_RESOLUTION away from the given point.  This only works for planes which go through the center of the world.\n   * Returns null if the planes are effectively parallel and reasonable adjoining points cannot be determined.\n   */\n  private GeoPoint[] findAdjoiningPoints(final Plane plane, final GeoPoint pointOnPlane, final Plane envelopePlane) {\n    // Compute a normalized perpendicular vector\n    final Vector perpendicular = new Vector(plane, pointOnPlane);\n    double distanceFactor = 0.0;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n      distanceFactor += DELTA_DISTANCE;\n      // Compute two new points along this vector from the original\n      final GeoPoint pointA = planetModel.createSurfacePoint(pointOnPlane.x + perpendicular.x * distanceFactor,\n        pointOnPlane.y + perpendicular.y * distanceFactor,\n        pointOnPlane.z + perpendicular.z * distanceFactor);\n      final GeoPoint pointB = planetModel.createSurfacePoint(pointOnPlane.x - perpendicular.x * distanceFactor,\n        pointOnPlane.y - perpendicular.y * distanceFactor,\n        pointOnPlane.z - perpendicular.z * distanceFactor);\n      if (Math.abs(envelopePlane.evaluate(pointA)) > OFF_PLANE_AMOUNT && Math.abs(envelopePlane.evaluate(pointB)) > OFF_PLANE_AMOUNT) {\n        //System.out.println(\"Distance: \"+computeSquaredDistance(rval[0], pointOnPlane)+\" and \"+computeSquaredDistance(rval[1], pointOnPlane));\n        return new GeoPoint[]{pointA, pointB};\n      }\n      // Loop back around and use a bigger delta\n    }\n    // Had to abort, so return null.\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cd25c083a7199445f2db6f32d322eeac1afc99e":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cd25c083a7199445f2db6f32d322eeac1afc99e"]},"commit2Childs":{"3cd25c083a7199445f2db6f32d322eeac1afc99e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4417cae689ce0fc964a3546ded2b0ab6e374f1b0":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4417cae689ce0fc964a3546ded2b0ab6e374f1b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}