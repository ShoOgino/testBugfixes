{"path":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","commits":[{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67006a60923e2124212d3baa0d29b444bcbd8373","date":1191425052,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0018e7a0579df5d3de71d0bd878322a7abef04d9","date":1202242049,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (autoCommit) {\n        assertTrue(policy.numOnCommit > 2);\n      } else {\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac785906c92e4048ffc28f7c23a45541d3cca9bf","date":1214322066,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0607932f46aecaff6aa9d5498ef1eac67a64b7d9","date":1215164592,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4ae99f08f69aa3acba7cd75134e8447eb747559","date":1222344278,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, false, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d54c7739bfe85d68f0352823cd70c10c619fad38","date":1228496593,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.list().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.list().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":["8b6187898fc4413ccd18229711786550a280383c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87c966e9308847938a7c905c2e46a56d8df788b8","date":1255035452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<4;pass++) {\n\n      boolean autoCommit = pass < 2;\n      boolean useCompoundFile = (pass % 2) > 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n        if (autoCommit && i%10 == 0)\n          writer.commit();\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n      if (!autoCommit)\n        // If we are not auto committing then there should\n        // be exactly 2 commits (one per close above):\n        assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      if (!autoCommit)\n        // 1 from opening writer + 2 from closing writer\n        assertEquals(3, commits.size());\n      else\n        // 1 from opening writer + 2 from closing writer +\n        // 11 from calling writer.commit() explicitly above\n        assertEquals(14, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e450c7d50c2fc84c963d0d7ade9d3217d868064d","date":1259932067,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      Iterator it = commits.iterator();\n      // Make sure we can open a reader on each commit:\n      while(it.hasNext()) {\n        IndexCommit commit = (IndexCommit) it.next();\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe0932c1d340f83fb0a611e5829b3046a1cc1152","date":1264946739,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6","date":1265808957,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT).setIndexDeletionPolicy(policy)\n          .setMaxBufferedDocs(10).setMergeScheduler(new SerialMergeScheduler()));\n      LogMergePolicy lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT)\n          .setOpenMode(OpenMode.APPEND).setIndexDeletionPolicy(policy));\n      lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT).setOpenMode(OpenMode.APPEND)\n              .setIndexDeletionPolicy(policy));\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT).setIndexDeletionPolicy(policy)\n          .setMaxBufferedDocs(10).setMergeScheduler(new SerialMergeScheduler()));\n      LogMergePolicy lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT)\n          .setOpenMode(OpenMode.APPEND).setIndexDeletionPolicy(policy));\n      lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT).setOpenMode(OpenMode.APPEND)\n              .setIndexDeletionPolicy(policy));\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))\n          .setIndexDeletionPolicy(policy).setMaxBufferedDocs(10)\n          .setMergeScheduler(new SerialMergeScheduler()));\n      LogMergePolicy lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT,\n          new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy));\n      lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT,\n              new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n              OpenMode.APPEND).setIndexDeletionPolicy(policy));\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), true, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setMaxBufferedDocs(10);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.setMergeScheduler(new SerialMergeScheduler());\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.UNLIMITED);\n      writer.setUseCompoundFile(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), false, policy, IndexWriter.MaxFieldLength.LIMITED);\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","pathOld":"src/test/org/apache/lucene/index/TestDeletionPolicy#testKeepAllDeletionPolicy().mjava","sourceNew":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))\n          .setIndexDeletionPolicy(policy).setMaxBufferedDocs(10)\n          .setMergeScheduler(new SerialMergeScheduler()));\n      LogMergePolicy lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT,\n          new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy));\n      lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT,\n              new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n              OpenMode.APPEND).setIndexDeletionPolicy(policy));\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /*\n   * Test a silly deletion policy that keeps all commits around.\n   */\n  public void testKeepAllDeletionPolicy() throws IOException {\n\n    for(int pass=0;pass<2;pass++) {\n\n      boolean useCompoundFile = (pass % 2) != 0;\n\n      // Never deletes a commit\n      KeepAllDeletionPolicy policy = new KeepAllDeletionPolicy();\n\n      Directory dir = new RAMDirectory();\n      policy.dir = dir;\n\n      IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n          TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))\n          .setIndexDeletionPolicy(policy).setMaxBufferedDocs(10)\n          .setMergeScheduler(new SerialMergeScheduler()));\n      LogMergePolicy lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      for(int i=0;i<107;i++) {\n        addDoc(writer);\n      }\n      writer.close();\n\n      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT,\n          new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n          OpenMode.APPEND).setIndexDeletionPolicy(policy));\n      lmp = (LogMergePolicy) writer.getMergePolicy();\n      lmp.setUseCompoundFile(useCompoundFile);\n      lmp.setUseCompoundDocStore(useCompoundFile);\n      writer.optimize();\n      writer.close();\n\n      assertEquals(2, policy.numOnInit);\n\n      // If we are not auto committing then there should\n      // be exactly 2 commits (one per close above):\n      assertEquals(2, policy.numOnCommit);\n\n      // Test listCommits\n      Collection<IndexCommit> commits = IndexReader.listCommits(dir);\n      // 1 from opening writer + 2 from closing writer\n      assertEquals(3, commits.size());\n\n      // Make sure we can open a reader on each commit:\n      for (final IndexCommit commit : commits) {\n        IndexReader r = IndexReader.open(commit, null, false);\n        r.close();\n      }\n\n      // Simplistic check: just verify all segments_N's still\n      // exist, and, I can open a reader on each:\n      dir.deleteFile(IndexFileNames.SEGMENTS_GEN);\n      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);\n      while(gen > 0) {\n        IndexReader reader = IndexReader.open(dir, true);\n        reader.close();\n        dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, \"\", gen));\n        gen--;\n\n        if (gen > 0) {\n          // Now that we've removed a commit point, which\n          // should have orphan'd at least one index file.\n          // Open & close a writer and assert that it\n          // actually removed something:\n          int preCount = dir.listAll().length;\n          writer = new IndexWriter(dir, new IndexWriterConfig(\n              TEST_VERSION_CURRENT,\n              new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setOpenMode(\n              OpenMode.APPEND).setIndexDeletionPolicy(policy));\n          writer.close();\n          int postCount = dir.listAll().length;\n          assertTrue(postCount < preCount);\n        }\n      }\n\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c4ae99f08f69aa3acba7cd75134e8447eb747559":["0607932f46aecaff6aa9d5498ef1eac67a64b7d9"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"67006a60923e2124212d3baa0d29b444bcbd8373":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"0a046c0c310bc77931fc8441bd920053b607dd14":["d54c7739bfe85d68f0352823cd70c10c619fad38","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"0018e7a0579df5d3de71d0bd878322a7abef04d9":["67006a60923e2124212d3baa0d29b444bcbd8373"],"0607932f46aecaff6aa9d5498ef1eac67a64b7d9":["ac785906c92e4048ffc28f7c23a45541d3cca9bf"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["87c966e9308847938a7c905c2e46a56d8df788b8"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["8b6187898fc4413ccd18229711786550a280383c"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["c4ae99f08f69aa3acba7cd75134e8447eb747559"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e82780afe6097066eb5befb86e9432f077667e3d":["0018e7a0579df5d3de71d0bd878322a7abef04d9"],"8b6187898fc4413ccd18229711786550a280383c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"87c966e9308847938a7c905c2e46a56d8df788b8":["0a046c0c310bc77931fc8441bd920053b607dd14"],"ac785906c92e4048ffc28f7c23a45541d3cca9bf":["e82780afe6097066eb5befb86e9432f077667e3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"c4ae99f08f69aa3acba7cd75134e8447eb747559":["d54c7739bfe85d68f0352823cd70c10c619fad38"],"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"67006a60923e2124212d3baa0d29b444bcbd8373":["0018e7a0579df5d3de71d0bd878322a7abef04d9"],"0a046c0c310bc77931fc8441bd920053b607dd14":["87c966e9308847938a7c905c2e46a56d8df788b8"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"0018e7a0579df5d3de71d0bd878322a7abef04d9":["e82780afe6097066eb5befb86e9432f077667e3d"],"0607932f46aecaff6aa9d5498ef1eac67a64b7d9":["c4ae99f08f69aa3acba7cd75134e8447eb747559"],"e450c7d50c2fc84c963d0d7ade9d3217d868064d":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["67006a60923e2124212d3baa0d29b444bcbd8373"],"d54c7739bfe85d68f0352823cd70c10c619fad38":["0a046c0c310bc77931fc8441bd920053b607dd14","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b6187898fc4413ccd18229711786550a280383c"],"8b6187898fc4413ccd18229711786550a280383c":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"e82780afe6097066eb5befb86e9432f077667e3d":["ac785906c92e4048ffc28f7c23a45541d3cca9bf"],"87c966e9308847938a7c905c2e46a56d8df788b8":["e450c7d50c2fc84c963d0d7ade9d3217d868064d"],"ac785906c92e4048ffc28f7c23a45541d3cca9bf":["0607932f46aecaff6aa9d5498ef1eac67a64b7d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}