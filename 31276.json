{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","commits":[{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor[FacetRequest]#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      subProcessor.process();\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      subProcessor.process();\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf","date":1450457061,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      subProcessor.process();\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":["7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1480a9d175b147e15628e77342c4175ad3fc4611","date":1452646257,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79759974460bc59933cd169acc94f5c6b16368d5","date":1471318443,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  protected void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n        \n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n      \n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70","date":1478625053,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":["faf1236ae092482293a7e0659e347d172185ef6f","7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    // TODO: what if a zero bucket has a sub-facet with an exclusion that would yield results?\n    // should we check for domain-altering exclusions, or even ask the sub-facet for\n    // it's domain and then only skip it if it's 0?\n\n    if (domain == null || domain.size() == 0 && !freq.processEmpty) {\n      return;\n    }\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = sub.getValue().createFacetProcessor(subContext);\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(sub.getValue().getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":["248f6ecc900c3a5633fd5ca6f564ea8b717720da","248f6ecc900c3a5633fd5ca6f564ea8b717720da","248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":5,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["1480a9d175b147e15628e77342c4175ad3fc4611","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"1480a9d175b147e15628e77342c4175ad3fc4611":["7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["1480a9d175b147e15628e77342c4175ad3fc4611","79759974460bc59933cd169acc94f5c6b16368d5"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70"],"7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1480a9d175b147e15628e77342c4175ad3fc4611","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"11ab475c994c79138885cc8a30b2641d929cdc43":["7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"79759974460bc59933cd169acc94f5c6b16368d5":["1480a9d175b147e15628e77342c4175ad3fc4611"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"]},"commit2Childs":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70"],"1480a9d175b147e15628e77342c4175ad3fc4611":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","79759974460bc59933cd169acc94f5c6b16368d5"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf":["1480a9d175b147e15628e77342c4175ad3fc4611"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["7c2faf42ce045d4bd93fa175ef185dc88f4f3bcf"],"11ab475c994c79138885cc8a30b2641d929cdc43":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"7bc83dec7a87b9a843f16fd1b9ae2597fef3fc70":["199dfa410f1fdbfd3294106b04096cce5ed34b21","8ec805ca8fedc0166461148c7182f1bcbbd18ee1","11ab475c994c79138885cc8a30b2641d929cdc43"],"79759974460bc59933cd169acc94f5c6b16368d5":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","11ab475c994c79138885cc8a30b2641d929cdc43","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}