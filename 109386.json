{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","commits":[{"id":"6466e433d7f5218e77c8115ed28176855fc3c143","date":1436824910,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = initSchema(config, schema);\n\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = initSchema(config, schema);\n\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = initSchema(config, schema);\n\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20eb14adcb76cac6b8ae297eb37caec72e3a2140","date":1447952616,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a626ec4d1c92e59fe390724d6220081047b03ce7","date":1448021525,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstanceDir(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":null,"bugIntro":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f1bee4bba8988141f8357bda2ccd9405926c4e5","date":1449703835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n    \n    // For debugging   \n//    numOpens.incrementAndGet();\n//    openHandles.put(this, new RuntimeException(\"unclosed core - name:\" + getName() + \" refs: \" + refCount.get()));\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2679aff35efbec5a5b825d59f006636fda4224d4","date":1457445730,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // Handle things that should eventually go away\n      initDeprecatedSupport();\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d","9aea0485ecacb6734c17da2d02569816c23a69c1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable<Void>() {\n        @Override\n        public Void call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91e2345fb81b6c1c7faefa550ee5eaafadc54486","date":1469730189,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f0c8426396c925de8db3ed3f8ff40fd73670a5c","date":1474556641,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"126d6ad24eed13163ba0959435d5a80e5672837c","date":1474567302,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e13696c44d3e2405098726359ab81dab178e7bc","date":1476726926,"type":3,"author":"Hrishikesh Gadre","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.info(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c609c76a49c17e5c1c8a5d5cd2d685be9f306a47","date":1477689538,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"320888923ec13b91f53082558f01f4c9960dd226","date":1477926871,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    checkNotNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    \n    this.coreDescriptor = coreDescriptor;\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0265144286422ad99682a00904cc2536b79c8535","date":1482222684,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcher\");\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherTime\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherWarmup\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherMaxReached\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherErrors\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcher\");\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherTime\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherWarmup\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherMaxReached\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherErrors\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f7df713a0f1e310d18dd8da91c89a07a13f86f8","date":1483441921,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcher\");\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherTime\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherWarmup\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherMaxReached\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherErrors\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcher\");\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherTime\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"newSearcherWarmup\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherMaxReached\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"newSearcherErrors\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad28156288ac00b91352582904d97e6653205757","date":1486850922,"type":5,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ad28156288ac00b91352582904d97e6653205757":["2f7df713a0f1e310d18dd8da91c89a07a13f86f8"],"20eb14adcb76cac6b8ae297eb37caec72e3a2140":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"320888923ec13b91f53082558f01f4c9960dd226":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c609c76a49c17e5c1c8a5d5cd2d685be9f306a47"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["91e2345fb81b6c1c7faefa550ee5eaafadc54486"],"2679aff35efbec5a5b825d59f006636fda4224d4":["536b47681314488eb94706248be6047a3f142841"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["20eb14adcb76cac6b8ae297eb37caec72e3a2140"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["320888923ec13b91f53082558f01f4c9960dd226","0265144286422ad99682a00904cc2536b79c8535"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["91e2345fb81b6c1c7faefa550ee5eaafadc54486","126d6ad24eed13163ba0959435d5a80e5672837c"],"91e2345fb81b6c1c7faefa550ee5eaafadc54486":["b6284684320a9808c41a5e43de958b2da22f89bd"],"3e13696c44d3e2405098726359ab81dab178e7bc":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6466e433d7f5218e77c8115ed28176855fc3c143":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"043df2e9a841864922c32756a44c939ed768cb89":["2679aff35efbec5a5b825d59f006636fda4224d4"],"536b47681314488eb94706248be6047a3f142841":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"c609c76a49c17e5c1c8a5d5cd2d685be9f306a47":["3e13696c44d3e2405098726359ab81dab178e7bc"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","3e13696c44d3e2405098726359ab81dab178e7bc"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","2f7df713a0f1e310d18dd8da91c89a07a13f86f8"],"0265144286422ad99682a00904cc2536b79c8535":["c609c76a49c17e5c1c8a5d5cd2d685be9f306a47"],"126d6ad24eed13163ba0959435d5a80e5672837c":["91e2345fb81b6c1c7faefa550ee5eaafadc54486","7f0c8426396c925de8db3ed3f8ff40fd73670a5c"],"b6284684320a9808c41a5e43de958b2da22f89bd":["2679aff35efbec5a5b825d59f006636fda4224d4","043df2e9a841864922c32756a44c939ed768cb89"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["6466e433d7f5218e77c8115ed28176855fc3c143"],"2f7df713a0f1e310d18dd8da91c89a07a13f86f8":["0265144286422ad99682a00904cc2536b79c8535"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["b6284684320a9808c41a5e43de958b2da22f89bd","91e2345fb81b6c1c7faefa550ee5eaafadc54486"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad28156288ac00b91352582904d97e6653205757"]},"commit2Childs":{"ad28156288ac00b91352582904d97e6653205757":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"20eb14adcb76cac6b8ae297eb37caec72e3a2140":["a626ec4d1c92e59fe390724d6220081047b03ce7"],"320888923ec13b91f53082558f01f4c9960dd226":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"7f0c8426396c925de8db3ed3f8ff40fd73670a5c":["126d6ad24eed13163ba0959435d5a80e5672837c"],"2679aff35efbec5a5b825d59f006636fda4224d4":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"a626ec4d1c92e59fe390724d6220081047b03ce7":["9f1bee4bba8988141f8357bda2ccd9405926c4e5"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6466e433d7f5218e77c8115ed28176855fc3c143"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3e13696c44d3e2405098726359ab81dab178e7bc"],"91e2345fb81b6c1c7faefa550ee5eaafadc54486":["7f0c8426396c925de8db3ed3f8ff40fd73670a5c","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","126d6ad24eed13163ba0959435d5a80e5672837c","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3e13696c44d3e2405098726359ab81dab178e7bc":["c609c76a49c17e5c1c8a5d5cd2d685be9f306a47","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6466e433d7f5218e77c8115ed28176855fc3c143":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"536b47681314488eb94706248be6047a3f142841":["2679aff35efbec5a5b825d59f006636fda4224d4"],"9f1bee4bba8988141f8357bda2ccd9405926c4e5":["536b47681314488eb94706248be6047a3f142841"],"c609c76a49c17e5c1c8a5d5cd2d685be9f306a47":["320888923ec13b91f53082558f01f4c9960dd226","0265144286422ad99682a00904cc2536b79c8535"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["320888923ec13b91f53082558f01f4c9960dd226"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"0265144286422ad99682a00904cc2536b79c8535":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","2f7df713a0f1e310d18dd8da91c89a07a13f86f8"],"126d6ad24eed13163ba0959435d5a80e5672837c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b6284684320a9808c41a5e43de958b2da22f89bd":["91e2345fb81b6c1c7faefa550ee5eaafadc54486","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["20eb14adcb76cac6b8ae297eb37caec72e3a2140"],"2f7df713a0f1e310d18dd8da91c89a07a13f86f8":["ad28156288ac00b91352582904d97e6653205757","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f03e4bed5023ec3ef93a771b8888cae991cf448d","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}