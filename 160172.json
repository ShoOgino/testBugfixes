{"path":"lucene/core/src/test/org/apache/lucene/index/TestSimpleDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","commits":[{"id":"55d38708477d49511977195bad066d9ced001005","date":1353348143,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSimpleDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b156d846032fbeed5bbb6c45481d6dcab2339ec6","date":1358288319,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestSimpleDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","sourceNew":null,"sourceOld":"  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,\n      List<Type> valueVarList, boolean withDeletions, int bytesSize)\n      throws IOException {\n    final boolean isNumeric = NUMERICS.contains(valueType);\n    FixedBitSet deleted = new FixedBitSet(numValues);\n    Document doc = new Document();\n    final Field valField;\n    if (isNumeric) {\n      switch (valueType) {\n      case VAR_INTS:\n        valField = new PackedLongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_16:\n        valField = new ShortDocValuesField(valueType.name(), (short) 0);\n        break;\n      case FIXED_INTS_32:\n        valField = new IntDocValuesField(valueType.name(), 0);\n        break;\n      case FIXED_INTS_64:\n        valField = new LongDocValuesField(valueType.name(), (long) 0);\n        break;\n      case FIXED_INTS_8:\n        valField = new ByteDocValuesField(valueType.name(), (byte) 0);\n        break;\n      case FLOAT_32:\n        valField = new FloatDocValuesField(valueType.name(), (float) 0);\n        break;\n      case FLOAT_64:\n        valField = new DoubleDocValuesField(valueType.name(), (double) 0);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    } else {\n      switch (valueType) {\n      case BYTES_FIXED_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_STRAIGHT:\n        valField = new StraightBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_DEREF:\n        valField = new DerefBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      case BYTES_FIXED_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), true);\n        break;\n      case BYTES_VAR_SORTED:\n        valField = new SortedBytesDocValuesField(valueType.name(), new BytesRef(), false);\n        break;\n      default:\n        valField = null;\n        fail(\"unhandled case\");\n      }\n    }\n    doc.add(valField);\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = valueType.name() + \"_\";\n    final byte[] b = new byte[bytesSize];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (valueType) {\n        case VAR_INTS:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_16:\n          valField.setShortValue((short)i);\n          break;\n        case FIXED_INTS_32:\n          valField.setIntValue(i);\n          break;\n        case FIXED_INTS_64:\n          valField.setLongValue((long)i);\n          break;\n        case FIXED_INTS_8:\n          valField.setByteValue((byte)(0xFF & (i % 128)));\n          break;\n        case FLOAT_32:\n          valField.setFloatValue(2.0f * i);\n          break;\n        case FLOAT_64:\n          valField.setDoubleValue(2.0d * i);\n          break;\n        default:\n          fail(\"unexpected value \" + valueType);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        if (bytesRef != null) {\n          valField.setBytesValue(bytesRef);\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new StringField(\"id\", idBase + i, Field.Store.YES));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random().nextBoolean()) {\n          Type val = valueVarList.get(random().nextInt(1 + valueVarList\n              .indexOf(valueType)));\n          final int randInt = val == valueType ? random().nextInt(1 + i) : random()\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == valueType) {\n            deleted.set(randInt);\n          }\n        }\n        if (random().nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test multi seg with deletions\n    if (withDeletions || random().nextBoolean()) {\n      w.forceMerge(1, true);\n    }\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"55d38708477d49511977195bad066d9ced001005":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b156d846032fbeed5bbb6c45481d6dcab2339ec6":["55d38708477d49511977195bad066d9ced001005"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55d38708477d49511977195bad066d9ced001005","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"55d38708477d49511977195bad066d9ced001005":["b156d846032fbeed5bbb6c45481d6dcab2339ec6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b156d846032fbeed5bbb6c45481d6dcab2339ec6":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b156d846032fbeed5bbb6c45481d6dcab2339ec6"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}