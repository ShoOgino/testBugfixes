{"path":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","commits":[{"id":"0f719faa74f7213d4a395510dbc1f1b7cb178484","date":1410881394,"type":1,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c495edcca4d0bc51bf62d9be3527c87bf9b44ded","date":1498673617,"type":4,"author":"Dennis Gove","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":null,"sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":null,"sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":null,"sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c8e5574b55d57947e989443dfde611646530ee":["0f719faa74f7213d4a395510dbc1f1b7cb178484","28288370235ed02234a64753cdbf0c6ec096304a"],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["0f719faa74f7213d4a395510dbc1f1b7cb178484"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["0f719faa74f7213d4a395510dbc1f1b7cb178484","c495edcca4d0bc51bf62d9be3527c87bf9b44ded"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f719faa74f7213d4a395510dbc1f1b7cb178484"],"30c8e5574b55d57947e989443dfde611646530ee":[],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["28288370235ed02234a64753cdbf0c6ec096304a"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["30c8e5574b55d57947e989443dfde611646530ee","c495edcca4d0bc51bf62d9be3527c87bf9b44ded","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}