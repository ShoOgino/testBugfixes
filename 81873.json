{"path":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","commits":[{"id":"2070bf73ffa1039a505000f99ea245884ff19e11","date":1177653367,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    int filterCacheSize = SolrConfig.config.getInt( \"query/filterCache/@size\", -1 );\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority quey for each map in our set\n    Map<String,TopTermQueue> ttinfo = getTopTerms(reader, fields, numTerms, null );\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only return one\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      \n      Query q = qp.parse( fieldName+\":[* TO *]\" ); \n      int docCount = searcher.numDocs( q, matchAllDocs );\n// TODO?  Is there a way to get the Fieldable infomation for this field?\n// The following approach works fine for stored fields, but does not work for non-stored fields\n//      if( docCount > 0 ) {\n//        // Find a document with this field\n//        DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n//        try {\n//          Document doc = searcher.doc( ds.iterator().next() );\n//          Fieldable fld = doc.getFieldable( fieldName );\n//          f.add( \"index\", getFieldFlags( fld ) );\n//        }\n//        catch( Exception ex ) {\n//          log.warning( \"error reading field: \"+fieldName );\n//        }\n//        // Find one document so we can get the fieldable\n//      }\n      f.add( \"docs\", docCount );\n      \n      TopTermQueue topTerms = ttinfo.get( fieldName );\n      if( topTerms != null ) {\n        f.add( \"distinct\", topTerms.distinctTerms );\n        \n        // TODO? is this the correct logic?\n        f.add( \"cacheableFaceting\", topTerms.distinctTerms < filterCacheSize );\n        \n        // Only show them if we specify something\n        f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6511cb621c585259d6a1f2da408bad8c636c7035","date":1177826927,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority quey for each map in our set\n    Map<String,TopTermQueue> ttinfo = getTopTerms(reader, fields, numTerms, null );\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      \n      Query q = qp.parse( fieldName+\":[* TO *]\" ); \n      int docCount = searcher.numDocs( q, matchAllDocs );\n      if( docCount > 0 ) {\n        // Find a document with this field\n        DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n        try {\n          Document doc = searcher.doc( ds.iterator().next() );\n          Fieldable fld = doc.getFieldable( fieldName );\n          if( fld != null ) {\n            f.add( \"index\", getFieldFlags( fld ) );\n          }\n          else {\n            // it is a non-stored field...\n            f.add( \"index\", \"(unstored field)\" );\n          }\n        }\n        catch( Exception ex ) {\n          log.warning( \"error reading field: \"+fieldName );\n        }\n        // Find one document so we can get the fieldable\n      }\n      f.add( \"docs\", docCount );\n      \n      TopTermQueue topTerms = ttinfo.get( fieldName );\n      if( topTerms != null ) {\n        f.add( \"distinct\", topTerms.distinctTerms );\n        \n        // Include top terms\n        f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n\n        // Add a histogram\n        f.add( \"histogram\", topTerms.histogram.toNamedList() );\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    int filterCacheSize = SolrConfig.config.getInt( \"query/filterCache/@size\", -1 );\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority quey for each map in our set\n    Map<String,TopTermQueue> ttinfo = getTopTerms(reader, fields, numTerms, null );\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only return one\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      \n      Query q = qp.parse( fieldName+\":[* TO *]\" ); \n      int docCount = searcher.numDocs( q, matchAllDocs );\n// TODO?  Is there a way to get the Fieldable infomation for this field?\n// The following approach works fine for stored fields, but does not work for non-stored fields\n//      if( docCount > 0 ) {\n//        // Find a document with this field\n//        DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n//        try {\n//          Document doc = searcher.doc( ds.iterator().next() );\n//          Fieldable fld = doc.getFieldable( fieldName );\n//          f.add( \"index\", getFieldFlags( fld ) );\n//        }\n//        catch( Exception ex ) {\n//          log.warning( \"error reading field: \"+fieldName );\n//        }\n//        // Find one document so we can get the fieldable\n//      }\n      f.add( \"docs\", docCount );\n      \n      TopTermQueue topTerms = ttinfo.get( fieldName );\n      if( topTerms != null ) {\n        f.add( \"distinct\", topTerms.distinctTerms );\n        \n        // TODO? is this the correct logic?\n        f.add( \"cacheableFaceting\", topTerms.distinctTerms < filterCacheSize );\n        \n        // Only show them if we specify something\n        f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a3ba66d289fab97b1bad9db1f4be6bf42977499","date":1180032380,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority quey for each map in our set\n    Map<String,TopTermQueue> ttinfo = getTopTerms(reader, fields, numTerms, null );\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      \n      Query q = qp.parse( fieldName+\":[* TO *]\" ); \n      int docCount = searcher.numDocs( q, matchAllDocs );\n      if( docCount > 0 ) {\n        // Find a document with this field\n        DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n        try {\n          Document doc = searcher.doc( ds.iterator().next() );\n          Fieldable fld = doc.getFieldable( fieldName );\n          if( fld != null ) {\n            f.add( \"index\", getFieldFlags( fld ) );\n          }\n          else {\n            // it is a non-stored field...\n            f.add( \"index\", \"(unstored field)\" );\n          }\n        }\n        catch( Exception ex ) {\n          log.warning( \"error reading field: \"+fieldName );\n        }\n        // Find one document so we can get the fieldable\n      }\n      f.add( \"docs\", docCount );\n      \n      TopTermQueue topTerms = ttinfo.get( fieldName );\n      if( topTerms != null ) {\n        f.add( \"distinct\", topTerms.distinctTerms );\n        \n        // Include top terms\n        f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n\n        // Add a histogram\n        f.add( \"histogram\", topTerms.histogram.toNamedList() );\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e29bfbddd06800a98e68d84468a4acb683e27f0","date":1180136849,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d2039f9b69cef7b394370ee828e100bc25233e1","date":1205614161,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception\n  { \n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a5aaf08085c1afff6743436ba62b24242641c42","date":1206042977,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":["8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warning( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236","date":1241436901,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":["3a5aaf08085c1afff6743436ba62b24242641c42"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"210db4446f6edb8eddbd43f02aba3b6541c1f050","date":1245186048,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    Query matchAllDocs = new MatchAllDocsQuery();\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        int docCount = searcher.numDocs( q, matchAllDocs );\n        if( docCount > 0 ) {\n          // Find a document with this field\n          DocList ds = searcher.getDocList( q, (Query)null, (Sort)null, 0, 1 );\n          try {\n            Document doc = searcher.doc( ds.iterator().next() );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n          // Find one document so we can get the fieldable\n        }\n        f.add( \"docs\", docCount );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3eb715ed91243e8b1fcae938bfd3c5641e439f4d","date":1247183420,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = new ConstantScoreRangeQuery(fieldName,null,null,false,false); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n    SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = qp.parse( fieldName+\":[* TO *]\" ); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef28ac95f5f85bbf872801277448c0924b0a6827","date":1268600312,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = new TermRangeQuery(fieldName,null,null,false,false); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = new ConstantScoreRangeQuery(fieldName,null,null,false,false); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","pathOld":"src/java/org/apache/solr/handler/admin/LukeRequestHandler#getIndexedFieldsInfo(SolrIndexSearcher,Set[String],int).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = new TermRangeQuery(fieldName,null,null,false,false); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private static SimpleOrderedMap<Object> getIndexedFieldsInfo( \n    final SolrIndexSearcher searcher, final Set<String> fields, final int numTerms ) \n    throws Exception {\n\n    IndexReader reader = searcher.getReader();\n    IndexSchema schema = searcher.getSchema();\n    \n    // Walk the term enum and keep a priority queue for each map in our set\n    Map<String,TopTermQueue> ttinfo = null;\n    if( numTerms > 0 ) {\n      ttinfo = getTopTerms(reader, fields, numTerms, null );\n    }\n    SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();\n    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    for (String fieldName : fieldNames) {\n      if( fields != null && !fields.contains( fieldName ) ) {\n        continue; // if a field is specified, only them\n      }\n      \n      SimpleOrderedMap<Object> f = new SimpleOrderedMap<Object>();\n      \n      SchemaField sfield = schema.getFieldOrNull( fieldName );\n      FieldType ftype = (sfield==null)?null:sfield.getType();\n\n      f.add( \"type\", (ftype==null)?null:ftype.getTypeName() );\n      f.add( \"schema\", getFieldFlags( sfield ) );\n      if (sfield != null && schema.isDynamicField(sfield.getName()) && schema.getDynamicPattern(sfield.getName()) != null) {\n    \t  f.add(\"dynamicBase\", schema.getDynamicPattern(sfield.getName()));\n      }\n\n      // If numTerms==0, the call is just asking for a quick field list\n      if( ttinfo != null && sfield != null && sfield.indexed() ) {\n        Query q = new TermRangeQuery(fieldName,null,null,false,false); \n        TopDocs top = searcher.search( q, 1 );\n        if( top.totalHits > 0 ) {\n          // Find a document with this field\n          try {\n            Document doc = searcher.doc( top.scoreDocs[0].doc );\n            Fieldable fld = doc.getFieldable( fieldName );\n            if( fld != null ) {\n              f.add( \"index\", getFieldFlags( fld ) );\n            }\n            else {\n              // it is a non-stored field...\n              f.add( \"index\", \"(unstored field)\" );\n            }\n          }\n          catch( Exception ex ) {\n            log.warn( \"error reading field: \"+fieldName );\n          }\n        }\n        f.add( \"docs\", top.totalHits );\n        \n        TopTermQueue topTerms = ttinfo.get( fieldName );\n        if( topTerms != null ) {\n          f.add( \"distinct\", topTerms.distinctTerms );\n          \n          // Include top terms\n          f.add( \"topTerms\", topTerms.toNamedList( searcher.getSchema() ) );\n  \n          // Add a histogram\n          f.add( \"histogram\", topTerms.histogram.toNamedList() );\n        }\n      }\n      \n      // Add the field\n      finfo.add( fieldName, f );\n    }\n    return finfo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e29bfbddd06800a98e68d84468a4acb683e27f0":["6a3ba66d289fab97b1bad9db1f4be6bf42977499"],"3eb715ed91243e8b1fcae938bfd3c5641e439f4d":["210db4446f6edb8eddbd43f02aba3b6541c1f050"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ef28ac95f5f85bbf872801277448c0924b0a6827":["3eb715ed91243e8b1fcae938bfd3c5641e439f4d"],"2070bf73ffa1039a505000f99ea245884ff19e11":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["3a5aaf08085c1afff6743436ba62b24242641c42"],"6a3ba66d289fab97b1bad9db1f4be6bf42977499":["6511cb621c585259d6a1f2da408bad8c636c7035"],"6511cb621c585259d6a1f2da408bad8c636c7035":["2070bf73ffa1039a505000f99ea245884ff19e11"],"8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"0d2039f9b69cef7b394370ee828e100bc25233e1":["1e29bfbddd06800a98e68d84468a4acb683e27f0"],"3a5aaf08085c1afff6743436ba62b24242641c42":["0d2039f9b69cef7b394370ee828e100bc25233e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad94625fb8d088209f46650c8097196fec67f00c":["ef28ac95f5f85bbf872801277448c0924b0a6827"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"210db4446f6edb8eddbd43f02aba3b6541c1f050":["8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236"]},"commit2Childs":{"1e29bfbddd06800a98e68d84468a4acb683e27f0":["0d2039f9b69cef7b394370ee828e100bc25233e1"],"3eb715ed91243e8b1fcae938bfd3c5641e439f4d":["ef28ac95f5f85bbf872801277448c0924b0a6827"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["2070bf73ffa1039a505000f99ea245884ff19e11"],"ef28ac95f5f85bbf872801277448c0924b0a6827":["ad94625fb8d088209f46650c8097196fec67f00c"],"2070bf73ffa1039a505000f99ea245884ff19e11":["6511cb621c585259d6a1f2da408bad8c636c7035"],"6a3ba66d289fab97b1bad9db1f4be6bf42977499":["1e29bfbddd06800a98e68d84468a4acb683e27f0"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236"],"6511cb621c585259d6a1f2da408bad8c636c7035":["6a3ba66d289fab97b1bad9db1f4be6bf42977499"],"8553c2d20e1c882eb6dbcf8bcb69bc8a7d82e236":["210db4446f6edb8eddbd43f02aba3b6541c1f050"],"0d2039f9b69cef7b394370ee828e100bc25233e1":["3a5aaf08085c1afff6743436ba62b24242641c42"],"3a5aaf08085c1afff6743436ba62b24242641c42":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"210db4446f6edb8eddbd43f02aba3b6541c1f050":["3eb715ed91243e8b1fcae938bfd3c5641e439f4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}