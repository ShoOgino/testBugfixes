{"path":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    FixedBitSet res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new FixedBitSet(reader.maxDoc());\n          res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    return BitsFilteredDocIdSet.wrap(res, acceptDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","sourceNew":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    FixedBitSet res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new FixedBitSet(reader.maxDoc());\n          res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(new FixedBitDocIdSet(res), acceptDocs);\n  }\n\n","sourceOld":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    FixedBitSet res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new FixedBitSet(reader.maxDoc());\n          res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    return BitsFilteredDocIdSet.wrap(res, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","sourceNew":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    DocIdSetBuilder res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new DocIdSetBuilder(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new DocIdSetBuilder(reader.maxDoc(), true); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new DocIdSetBuilder(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(res.build(), acceptDocs);\n  }\n\n","sourceOld":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    FixedBitSet res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new FixedBitSet(reader.maxDoc());\n          res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new FixedBitSet(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(new FixedBitDocIdSet(res), acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b012914a8110b2ff1d075ed1ef72aa57084d4897","date":1414685177,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","sourceNew":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    BitDocIdSet.Builder res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new BitDocIdSet.Builder(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new BitDocIdSet.Builder(reader.maxDoc(), true); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new BitDocIdSet.Builder(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(res.build(), acceptDocs);\n  }\n\n","sourceOld":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    DocIdSetBuilder res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new DocIdSetBuilder(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new DocIdSetBuilder(reader.maxDoc(), true); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new DocIdSetBuilder(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(res.build(), acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"099c774ddd27f4ad437ca5df14d153bab0a3affe","date":1424527689,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter#getDocIdSet(LeafReaderContext,Bits).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns the a DocIdSetIterator representing the Boolean composition\n   * of the filters that have been added.\n   */\n  @Override\n  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n    BitDocIdSet.Builder res = null;\n    final LeafReader reader = context.reader();\n    \n    boolean hasShouldClauses = false;\n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.SHOULD) {\n        hasShouldClauses = true;\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) continue;\n        if (res == null) {\n          res = new BitDocIdSet.Builder(reader.maxDoc());\n        }\n        res.or(disi);\n      }\n    }\n    if (hasShouldClauses && res == null)\n      return null;\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST_NOT) {\n        if (res == null) {\n          assert !hasShouldClauses;\n          res = new BitDocIdSet.Builder(reader.maxDoc(), true); // NOTE: may set bits on deleted docs\n        }\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi != null) {\n          res.andNot(disi);\n        }\n      }\n    }\n    \n    for (final FilterClause fc : clauses) {\n      if (fc.getOccur() == Occur.MUST) {\n        final DocIdSetIterator disi = getDISI(fc.getFilter(), context);\n        if (disi == null) {\n          return null; // no documents can match\n        }\n        if (res == null) {\n          res = new BitDocIdSet.Builder(reader.maxDoc());\n          res.or(disi);\n        } else {\n          res.and(disi);\n        }\n      }\n    }\n\n    if (res == null) {\n      return null;\n    }\n    return BitsFilteredDocIdSet.wrap(res.build(), acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"099c774ddd27f4ad437ca5df14d153bab0a3affe":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80c55596a764e2d397e982828e75fcac5ce430a0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["099c774ddd27f4ad437ca5df14d153bab0a3affe"]},"commit2Childs":{"b012914a8110b2ff1d075ed1ef72aa57084d4897":["099c774ddd27f4ad437ca5df14d153bab0a3affe"],"099c774ddd27f4ad437ca5df14d153bab0a3affe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["b012914a8110b2ff1d075ed1ef72aa57084d4897"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["80c55596a764e2d397e982828e75fcac5ce430a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}