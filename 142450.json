{"path":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","commits":[{"id":"7455ee5c847b2ee7e44656e4218141f62dacb572","date":1386032125,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean).mjava","sourceNew":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5861b8cc31cea983eaee225e952748aa8a77861c","date":1449812318,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","sourceNew":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":["11bf766bfc5fc48f7099fd6d555b16d5ad4478f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","sourceNew":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access {}\", fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: {}\", fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5861b8cc31cea983eaee225e952748aa8a77861c":["7455ee5c847b2ee7e44656e4218141f62dacb572"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7455ee5c847b2ee7e44656e4218141f62dacb572":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7455ee5c847b2ee7e44656e4218141f62dacb572"],"575e66bd4b2349209027f6801184da7fc3cba13f":["5861b8cc31cea983eaee225e952748aa8a77861c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"5861b8cc31cea983eaee225e952748aa8a77861c":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7455ee5c847b2ee7e44656e4218141f62dacb572","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"7455ee5c847b2ee7e44656e4218141f62dacb572":["5861b8cc31cea983eaee225e952748aa8a77861c","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}