{"path":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","commits":[{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((float) ((similarity - minSimilarity) * scale_factor));\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df9ba72278ee433b2352986cbf97ab7161006953","date":1286047596,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((float) ((similarity - minSimilarity) * scale_factor));\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((float) ((similarity - minSimilarity) * scale_factor));\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"738f2eb25785a6c55c9bcf17cf20f9dd5200c812","date":1293511643,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","date":1294014627,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, 0, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c955fe2dae6b53fe4911a5a004a00f35e8c3422a","date":1297267800,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      int ed = matchers.length - 1;\n      \n      if (matches(term, ed)) { // we match the outer dfa\n        // now compute exact edit distance\n        while (ed > 0) {\n          if (matches(term, ed - 1)) {\n            ed--;\n          } else {\n            break;\n          }\n        }\n        \n        // scale to a boost and return (if similarity > minSimilarity)\n        if (ed == 0) { // exact match\n          boostAtt.setBoost(1.0F);\n          return AcceptStatus.YES_AND_SEEK;\n        } else {\n          final int codePointCount = UnicodeUtil.codePointCount(term);\n          final float similarity = 1.0f - ((float) ed / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      } else {\n        return AcceptStatus.NO_AND_SEEK;\n      }\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      int ed = matchers.length - 1;\n      \n      if (matches(term, ed)) { // we match the outer dfa\n        // now compute exact edit distance\n        while (ed > 0) {\n          if (matches(term, ed - 1)) {\n            ed--;\n          } else {\n            break;\n          }\n        }\n        \n        // scale to a boost and return (if similarity > minSimilarity)\n        if (ed == 0) { // exact match\n          boostAtt.setBoost(1.0F);\n          return AcceptStatus.YES_AND_SEEK;\n        } else {\n          final int codePointCount = UnicodeUtil.codePointCount(term);\n          final float similarity = 1.0f - ((float) ed / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      } else {\n        return AcceptStatus.NO_AND_SEEK;\n      }\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      int ed = matchers.length - 1;\n      \n      if (matches(term, ed)) { // we match the outer dfa\n        // now compute exact edit distance\n        while (ed > 0) {\n          if (matches(term, ed - 1)) {\n            ed--;\n          } else {\n            break;\n          }\n        }\n        \n        // scale to a boost and return (if similarity > minSimilarity)\n        if (ed == 0) { // exact match\n          boostAtt.setBoost(1.0F);\n          return AcceptStatus.YES_AND_SEEK;\n        } else {\n          final int codePointCount = UnicodeUtil.codePointCount(term);\n          final float similarity = 1.0f - ((float) ed / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      } else {\n        return AcceptStatus.NO_AND_SEEK;\n      }\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {\n      if (term.equals(termRef)) { // ed = 0\n        boostAtt.setBoost(1.0F);\n        return AcceptStatus.YES_AND_SEEK;\n      }\n      \n      int codePointCount = -1;\n      \n      // TODO: benchmark doing this backwards\n      for (int i = 1; i < matchers.length; i++)\n        if (matchers[i].run(term.bytes, term.offset, term.length)) {\n          // this sucks, we convert just to score based on length.\n          if (codePointCount == -1) {\n            codePointCount = UnicodeUtil.codePointCount(term);\n          }\n          final float similarity = 1.0f - ((float) i / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      \n      return AcceptStatus.NO_AND_SEEK;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      //System.out.println(\"AFTE.accept term=\" + term);\n      int ed = matchers.length - 1;\n      \n      // we are wrapping either an intersect() TermsEnum or an AutomatonTermsENum,\n      // so we know the outer DFA always matches.\n      // now compute exact edit distance\n      while (ed > 0) {\n        if (matches(term, ed - 1)) {\n          ed--;\n        } else {\n          break;\n        }\n      }\n      //System.out.println(\"CHECK term=\" + term.utf8ToString() + \" ed=\" + ed);\n      \n      // scale to a boost and return (if similarity > minSimilarity)\n      if (ed == 0) { // exact match\n        boostAtt.setBoost(1.0F);\n        //System.out.println(\"  yes\");\n        return AcceptStatus.YES;\n      } else {\n        final int codePointCount = UnicodeUtil.codePointCount(term);\n        final float similarity = 1.0f - ((float) ed / (float) \n            (Math.min(codePointCount, termLength)));\n        if (similarity > minSimilarity) {\n          boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n          //System.out.println(\"  yes\");\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      int ed = matchers.length - 1;\n      \n      if (matches(term, ed)) { // we match the outer dfa\n        // now compute exact edit distance\n        while (ed > 0) {\n          if (matches(term, ed - 1)) {\n            ed--;\n          } else {\n            break;\n          }\n        }\n        \n        // scale to a boost and return (if similarity > minSimilarity)\n        if (ed == 0) { // exact match\n          boostAtt.setBoost(1.0F);\n          return AcceptStatus.YES_AND_SEEK;\n        } else {\n          final int codePointCount = UnicodeUtil.codePointCount(term);\n          final float similarity = 1.0f - ((float) ed / (float) \n              (Math.min(codePointCount, termLength)));\n          if (similarity > minSimilarity) {\n            boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n            return AcceptStatus.YES_AND_SEEK;\n          } else {\n            return AcceptStatus.NO_AND_SEEK;\n          }\n        }\n      } else {\n        return AcceptStatus.NO_AND_SEEK;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.AutomatonFuzzyTermsEnum#accept(BytesRef).mjava","sourceNew":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      //System.out.println(\"AFTE.accept term=\" + term);\n      int ed = matchers.length - 1;\n      \n      // we are wrapping either an intersect() TermsEnum or an AutomatonTermsENum,\n      // so we know the outer DFA always matches.\n      // now compute exact edit distance\n      while (ed > 0) {\n        if (matches(term, ed - 1)) {\n          ed--;\n        } else {\n          break;\n        }\n      }\n      //System.out.println(\"CHECK term=\" + term.utf8ToString() + \" ed=\" + ed);\n      \n      // scale to a boost and return (if similarity > minSimilarity)\n      if (ed == 0) { // exact match\n        boostAtt.setBoost(1.0F);\n        //System.out.println(\"  yes\");\n        return AcceptStatus.YES;\n      } else {\n        final int codePointCount = UnicodeUtil.codePointCount(term);\n        final float similarity = 1.0f - ((float) ed / (float) \n            (Math.min(codePointCount, termLength)));\n        if (similarity > minSimilarity) {\n          boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n          //System.out.println(\"  yes\");\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    }\n\n","sourceOld":"    /** finds the smallest Lev(n) DFA that accepts the term. */\n    @Override\n    protected AcceptStatus accept(BytesRef term) {    \n      //System.out.println(\"AFTE.accept term=\" + term);\n      int ed = matchers.length - 1;\n      \n      // we are wrapping either an intersect() TermsEnum or an AutomatonTermsENum,\n      // so we know the outer DFA always matches.\n      // now compute exact edit distance\n      while (ed > 0) {\n        if (matches(term, ed - 1)) {\n          ed--;\n        } else {\n          break;\n        }\n      }\n      //System.out.println(\"CHECK term=\" + term.utf8ToString() + \" ed=\" + ed);\n      \n      // scale to a boost and return (if similarity > minSimilarity)\n      if (ed == 0) { // exact match\n        boostAtt.setBoost(1.0F);\n        //System.out.println(\"  yes\");\n        return AcceptStatus.YES;\n      } else {\n        final int codePointCount = UnicodeUtil.codePointCount(term);\n        final float similarity = 1.0f - ((float) ed / (float) \n            (Math.min(codePointCount, termLength)));\n        if (similarity > minSimilarity) {\n          boostAtt.setBoost((similarity - minSimilarity) * scale_factor);\n          //System.out.println(\"  yes\");\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["df9ba72278ee433b2352986cbf97ab7161006953","738f2eb25785a6c55c9bcf17cf20f9dd5200c812"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["70ad682703b8585f5d0a637efec044d57ec05efb","c955fe2dae6b53fe4911a5a004a00f35e8c3422a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","df9ba72278ee433b2352986cbf97ab7161006953"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["c955fe2dae6b53fe4911a5a004a00f35e8c3422a"],"c955fe2dae6b53fe4911a5a004a00f35e8c3422a":["738f2eb25785a6c55c9bcf17cf20f9dd5200c812"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","738f2eb25785a6c55c9bcf17cf20f9dd5200c812"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"738f2eb25785a6c55c9bcf17cf20f9dd5200c812":["df9ba72278ee433b2352986cbf97ab7161006953"],"df9ba72278ee433b2352986cbf97ab7161006953":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c","c955fe2dae6b53fe4911a5a004a00f35e8c3422a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","df9ba72278ee433b2352986cbf97ab7161006953"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c955fe2dae6b53fe4911a5a004a00f35e8c3422a":["f1bdbf92da222965b46c0a942c3857ba56e5c638","60ba444201d2570214b6fcf1d15600dc1a01f548","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"df9ba72278ee433b2352986cbf97ab7161006953":["70ad682703b8585f5d0a637efec044d57ec05efb","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","738f2eb25785a6c55c9bcf17cf20f9dd5200c812"],"738f2eb25785a6c55c9bcf17cf20f9dd5200c812":["70ad682703b8585f5d0a637efec044d57ec05efb","c955fe2dae6b53fe4911a5a004a00f35e8c3422a","ff9cf7165d6cbafe4ef4431ecc2dc1af9cb2316c"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f1bdbf92da222965b46c0a942c3857ba56e5c638","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}