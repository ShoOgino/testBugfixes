{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","commits":[{"id":"b2e70b697d9f5a6130848741a4f0cdc08a1fe258","date":1168661303,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"/dev/null","sourceNew":"  private int doParallelTasks() throws Exception {\r\n    final int count [] = {0};\r\n    Thread t[] = new Thread [repetitions * tasks.size()];\r\n    // prepare threads\r\n    int indx = 0;\r\n    for (int k=0; k<repetitions; k++) {\r\n      for (int i = 0; i < tasks.size(); i++) {\r\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\r\n        t[indx++] = new Thread() {\r\n          public void run() {\r\n            int n;\r\n            try {\r\n              n = task.runAndMaybeStats(letChildReport);\r\n            } catch (Exception e) {\r\n              throw new RuntimeException(e);\r\n            }\r\n            synchronized (count) {\r\n              count[0] += n;\r\n            }\r\n          }\r\n        };\r\n      }\r\n    }\r\n    // run threads\r\n    startThreads(t);\r\n    // wait for all threads to complete\r\n    for (int i = 0; i < t.length; i++) {\r\n      t[i].join();\r\n    }\r\n    // return total count\r\n    return count[0];\r\n  }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738fa43eaa87dc7b393fe98b04cde1019e20bac","date":1175557034,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasks.size(); i++) {\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n            synchronized (count) {\n              count[0] += n;\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\r\n    final int count [] = {0};\r\n    Thread t[] = new Thread [repetitions * tasks.size()];\r\n    // prepare threads\r\n    int indx = 0;\r\n    for (int k=0; k<repetitions; k++) {\r\n      for (int i = 0; i < tasks.size(); i++) {\r\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\r\n        t[indx++] = new Thread() {\r\n          public void run() {\r\n            int n;\r\n            try {\r\n              n = task.runAndMaybeStats(letChildReport);\r\n            } catch (Exception e) {\r\n              throw new RuntimeException(e);\r\n            }\r\n            synchronized (count) {\r\n              count[0] += n;\r\n            }\r\n          }\r\n        };\r\n      }\r\n    }\r\n    // run threads\r\n    startThreads(t);\r\n    // wait for all threads to complete\r\n    for (int i = 0; i < t.length; i++) {\r\n      t[i].join();\r\n    }\r\n    // return total count\r\n    return count[0];\r\n  }\r\n\n","bugFix":null,"bugIntro":["1d6b7628166e3e58a411c83f120233cbaf3fc052"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"774d97e6f8928526e14d363d098229df30c5e3ca","date":1190106306,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasks.size(); i++) {\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n              updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasks.size(); i++) {\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n            synchronized (count) {\n              count[0] += n;\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d6b7628166e3e58a411c83f120233cbaf3fc052","date":1199324898,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n              updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasks.size(); i++) {\n        final PerfTask task = (PerfTask) ((PerfTask) tasks.get(i)).clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n              updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","bugFix":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95bf9c30ed04bd202c0161831dc06decc6670b73","date":1200828698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            try {\n              int n = task.runAndMaybeStats(letChildReport);\n              if (anyExhaustibleTasks)\n                updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            int n;\n            try {\n              n = task.runAndMaybeStats(letChildReport);\n              updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              int n = task.runAndMaybeStats(letChildReport);\n              if (anyExhaustibleTasks)\n                updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          public void run() {\n            try {\n              int n = task.runAndMaybeStats(letChildReport);\n              if (anyExhaustibleTasks)\n                updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3353540ef2debe4c4c017e9d86e2c60f9e784336","date":1258197258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    ParallelTask t[] = runningParallelTasks = new ParallelTask[repetitions * tasks.size()];\n    // prepare threads\n    int index = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[index++] = new ParallelTask(task);\n      }\n    }\n    // run threads\n    startThreads(t);\n\n    // wait for all threads to complete\n    int count = 0;\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n      count += t[i].count;\n    }\n\n    // return total count\n    return count;\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    final int count [] = {0};\n    Thread t[] = new Thread [repetitions * tasks.size()];\n    // prepare threads\n    int indx = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[indx++] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              int n = task.runAndMaybeStats(letChildReport);\n              if (anyExhaustibleTasks)\n                updateExhausted(task);\n              synchronized (count) {\n                count[0] += n;\n              }\n            } catch (NoMoreDataException e) {\n              exhausted = true;\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      }\n    }\n    // run threads\n    startThreads(t);\n    // wait for all threads to complete\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n    }\n    // return total count\n    return count[0];\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5ebdc25cde64f1bd2b6337721292bdd1b23f714","date":1258737814,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n\n    final TaskStats stats = getRunData().getPoints().getCurrentStats();\n\n    initTasksArray();\n    ParallelTask t[] = runningParallelTasks = new ParallelTask[repetitions * tasks.size()];\n    // prepare threads\n    int index = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[index++] = new ParallelTask(task);\n      }\n    }\n    // run threads\n    startThreads(t);\n\n    // wait for all threads to complete\n    int count = 0;\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n      count += t[i].count;\n      if (t[i].task instanceof TaskSequence) {\n        TaskSequence sub = (TaskSequence) t[i].task;\n        if (sub.countsByTime != null) {\n          if (countsByTime == null) {\n            countsByTime = new int[sub.countsByTime.length];\n          } else if (countsByTime.length < sub.countsByTime.length) {\n            countsByTime = ArrayUtil.grow(countsByTime, sub.countsByTime.length);\n          }\n          for(int j=0;j<sub.countsByTime.length;j++) {\n            countsByTime[j] += sub.countsByTime[j];\n          }\n        }\n      }\n    }\n\n    if (countsByTime != null) {\n      stats.setCountsByTime(countsByTime, logByTimeMsec);\n    }\n\n    // return total count\n    return count;\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n    initTasksArray();\n    ParallelTask t[] = runningParallelTasks = new ParallelTask[repetitions * tasks.size()];\n    // prepare threads\n    int index = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[index++] = new ParallelTask(task);\n      }\n    }\n    // run threads\n    startThreads(t);\n\n    // wait for all threads to complete\n    int count = 0;\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n      count += t[i].count;\n    }\n\n    // return total count\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence#doParallelTasks().mjava","sourceNew":"  private int doParallelTasks() throws Exception {\n\n    final TaskStats stats = getRunData().getPoints().getCurrentStats();\n\n    initTasksArray();\n    ParallelTask t[] = runningParallelTasks = new ParallelTask[repetitions * tasks.size()];\n    // prepare threads\n    int index = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[index++] = new ParallelTask(task);\n      }\n    }\n    // run threads\n    startThreads(t);\n\n    // wait for all threads to complete\n    int count = 0;\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n      count += t[i].count;\n      if (t[i].task instanceof TaskSequence) {\n        TaskSequence sub = (TaskSequence) t[i].task;\n        if (sub.countsByTime != null) {\n          if (countsByTime == null) {\n            countsByTime = new int[sub.countsByTime.length];\n          } else if (countsByTime.length < sub.countsByTime.length) {\n            countsByTime = ArrayUtil.grow(countsByTime, sub.countsByTime.length);\n          }\n          for(int j=0;j<sub.countsByTime.length;j++) {\n            countsByTime[j] += sub.countsByTime[j];\n          }\n        }\n      }\n    }\n\n    if (countsByTime != null) {\n      stats.setCountsByTime(countsByTime, logByTimeMsec);\n    }\n\n    // return total count\n    return count;\n  }\n\n","sourceOld":"  private int doParallelTasks() throws Exception {\n\n    final TaskStats stats = getRunData().getPoints().getCurrentStats();\n\n    initTasksArray();\n    ParallelTask t[] = runningParallelTasks = new ParallelTask[repetitions * tasks.size()];\n    // prepare threads\n    int index = 0;\n    for (int k=0; k<repetitions; k++) {\n      for (int i = 0; i < tasksArray.length; i++) {\n        final PerfTask task = (PerfTask) tasksArray[i].clone();\n        t[index++] = new ParallelTask(task);\n      }\n    }\n    // run threads\n    startThreads(t);\n\n    // wait for all threads to complete\n    int count = 0;\n    for (int i = 0; i < t.length; i++) {\n      t[i].join();\n      count += t[i].count;\n      if (t[i].task instanceof TaskSequence) {\n        TaskSequence sub = (TaskSequence) t[i].task;\n        if (sub.countsByTime != null) {\n          if (countsByTime == null) {\n            countsByTime = new int[sub.countsByTime.length];\n          } else if (countsByTime.length < sub.countsByTime.length) {\n            countsByTime = ArrayUtil.grow(countsByTime, sub.countsByTime.length);\n          }\n          for(int j=0;j<sub.countsByTime.length;j++) {\n            countsByTime[j] += sub.countsByTime[j];\n          }\n        }\n      }\n    }\n\n    if (countsByTime != null) {\n      stats.setCountsByTime(countsByTime, logByTimeMsec);\n    }\n\n    // return total count\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3353540ef2debe4c4c017e9d86e2c60f9e784336":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"95bf9c30ed04bd202c0161831dc06decc6670b73":["1d6b7628166e3e58a411c83f120233cbaf3fc052"],"774d97e6f8928526e14d363d098229df30c5e3ca":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1d6b7628166e3e58a411c83f120233cbaf3fc052":["774d97e6f8928526e14d363d098229df30c5e3ca"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["95bf9c30ed04bd202c0161831dc06decc6670b73"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"]},"commit2Childs":{"3353540ef2debe4c4c017e9d86e2c60f9e784336":["f5ebdc25cde64f1bd2b6337721292bdd1b23f714"],"95bf9c30ed04bd202c0161831dc06decc6670b73":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"774d97e6f8928526e14d363d098229df30c5e3ca":["1d6b7628166e3e58a411c83f120233cbaf3fc052"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b2e70b697d9f5a6130848741a4f0cdc08a1fe258"],"1d6b7628166e3e58a411c83f120233cbaf3fc052":["95bf9c30ed04bd202c0161831dc06decc6670b73"],"3738fa43eaa87dc7b393fe98b04cde1019e20bac":["774d97e6f8928526e14d363d098229df30c5e3ca"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["3353540ef2debe4c4c017e9d86e2c60f9e784336"],"b2e70b697d9f5a6130848741a4f0cdc08a1fe258":["3738fa43eaa87dc7b393fe98b04cde1019e20bac"],"f5ebdc25cde64f1bd2b6337721292bdd1b23f714":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}