{"path":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","commits":[{"id":"7d6b8491b15b391062b53404b4af3c8f18924090","date":1193061194,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = getLatestFile(ffs.indexDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["144cd9248ef4df6739fe736179848f0b1dc05cd4","144cd9248ef4df6739fe736179848f0b1dc05cd4","144cd9248ef4df6739fe736179848f0b1dc05cd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ad2918ea17540a017ec8141ce643bd95bc6da2e","date":1198201413,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = getLatestFile(ffs.indexDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5391288921372c32bf6096df320497ad2d05757f","date":1200634221,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.severe( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.severe(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ce664c39aec5f3a923284c202061999768425db","date":1249649666,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName().intern();\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5391288921372c32bf6096df320497ad2d05757f":["7ad2918ea17540a017ec8141ce643bd95bc6da2e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"7d6b8491b15b391062b53404b4af3c8f18924090":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"7ad2918ea17540a017ec8141ce643bd95bc6da2e":["7d6b8491b15b391062b53404b4af3c8f18924090"],"ad94625fb8d088209f46650c8097196fec67f00c":["6ce664c39aec5f3a923284c202061999768425db"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["5391288921372c32bf6096df320497ad2d05757f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6ce664c39aec5f3a923284c202061999768425db":["00da8b51bdeae168a5b26ec506db372b219ca7a2"]},"commit2Childs":{"5391288921372c32bf6096df320497ad2d05757f":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["7d6b8491b15b391062b53404b4af3c8f18924090"],"7d6b8491b15b391062b53404b4af3c8f18924090":["7ad2918ea17540a017ec8141ce643bd95bc6da2e"],"7ad2918ea17540a017ec8141ce643bd95bc6da2e":["5391288921372c32bf6096df320497ad2d05757f"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["6ce664c39aec5f3a923284c202061999768425db"],"6ce664c39aec5f3a923284c202061999768425db":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}