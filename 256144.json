{"path":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","commits":[{"id":"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05","date":1446751515,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"/dev/null","sourceNew":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      zkController.getZkStateReader().updateClusterState();\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertEquals(\"Expected that the LIR state would've been down by now\",\n          Replica.State.DOWN, (lirState));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11a913bb5ba7bfbdeafe7790afa34e972f578d0d","date":1447784107,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      zkController.getZkStateReader().updateClusterState();\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","sourceOld":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      zkController.getZkStateReader().updateClusterState();\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertEquals(\"Expected that the LIR state would've been down by now\",\n          Replica.State.DOWN, (lirState));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","sourceOld":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      zkController.getZkStateReader().updateClusterState();\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","sourceOld":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","bugFix":["55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","sourceOld":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getSlice(collectionName, shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23899910c6ea46c4aff96056cfae91d3e31b262a","date":1522788117,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":"  private void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","sourceOld":"  void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180","date":1539076849,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/ForceLeaderTest#putNonLeadersIntoLIR(String,String,ZkController,Replica,List[Replica]).mjava","sourceNew":null,"sourceOld":"  private void putNonLeadersIntoLIR(String collectionName, String shard, ZkController zkController, Replica leader, List<Replica> notLeaders) throws Exception {\n    SocketProxy[] nonLeaderProxies = new SocketProxy[notLeaders.size()];\n    for (int i = 0; i < notLeaders.size(); i++)\n      nonLeaderProxies[i] = getProxyForReplica(notLeaders.get(i));\n\n    sendDoc(1);\n\n    // ok, now introduce a network partition between the leader and both replicas\n    log.info(\"Closing proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.close();\n\n    // indexing during a partition\n    log.info(\"Sending a doc during the network partition...\");\n    sendDoc(2);\n\n    // Wait a little\n    Thread.sleep(2000);\n\n    // Kill the leader\n    log.info(\"Killing leader for shard1 of \" + collectionName + \" on node \" + leader.getNodeName() + \"\");\n    JettySolrRunner leaderJetty = getJettyOnPort(getReplicaPort(leader));\n    getProxyForReplica(leader).close();\n    leaderJetty.stop();\n\n    // Wait for a steady state, till LIR flags have been set and the shard is leaderless\n    log.info(\"Sleep and periodically wake up to check for state...\");\n    for (int i = 0; i < 20; i++) {\n      Thread.sleep(1000);\n      State lirStates[] = new State[notLeaders.size()];\n      for (int j = 0; j < notLeaders.size(); j++)\n        lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n\n      ClusterState clusterState = zkController.getZkStateReader().getClusterState();\n      boolean allDown = true;\n      for (State lirState : lirStates)\n        if (Replica.State.DOWN.equals(lirState) == false)\n          allDown = false;\n      if (allDown && clusterState.getCollection(collectionName).getSlice(shard).getLeader() == null) {\n        break;\n      }\n      log.warn(\"Attempt \" + i + \", waiting on for 1 sec to settle down in the steady state. State: \" +\n          printClusterStateInfo(collectionName));\n      log.warn(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n    }\n    log.info(\"Waking up...\");\n\n    // remove the network partition\n    log.info(\"Reopening the proxies for the non-leader replicas...\");\n    for (SocketProxy proxy : nonLeaderProxies)\n      proxy.reopen();\n\n    log.info(\"LIR state: \" + getLIRState(zkController, collectionName, shard));\n\n    State lirStates[] = new State[notLeaders.size()];\n    for (int j = 0; j < notLeaders.size(); j++)\n      lirStates[j] = zkController.getLeaderInitiatedRecoveryState(collectionName, shard, notLeaders.get(j).getName());\n    for (State lirState : lirStates)\n      assertTrue(\"Expected that the replicas would be in LIR state by now. LIR states: \"+Arrays.toString(lirStates),\n          Replica.State.DOWN == lirState || Replica.State.RECOVERING == lirState);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"23899910c6ea46c4aff96056cfae91d3e31b262a":["344b0840364d990b29b97467bfcc766ff8325d11"],"11a913bb5ba7bfbdeafe7790afa34e972f578d0d":["55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05"],"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["23899910c6ea46c4aff96056cfae91d3e31b262a"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["11a913bb5ba7bfbdeafe7790afa34e972f578d0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","23899910c6ea46c4aff96056cfae91d3e31b262a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05"],"23899910c6ea46c4aff96056cfae91d3e31b262a":["b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180"],"11a913bb5ba7bfbdeafe7790afa34e972f578d0d":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"55dd60b0ec28d5f9b8d178ab4d1cc3abb74c3e05":["11a913bb5ba7bfbdeafe7790afa34e972f578d0d"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","344b0840364d990b29b97467bfcc766ff8325d11"],"b6d72c72ee67b4aa8bc8bdd91bae9069b04fc180":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}