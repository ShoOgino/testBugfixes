{"path":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","commits":[{"id":"7f4241c44998effab9382acfd7f0b042f3fe9c25","date":1432671323,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n\n      // Close and clear logs\n      for (TransactionLog log : logs) {\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n      logs.clear();\n\n      // reset lastDataDir for #init()\n      lastDataDir = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e586ff50ac71d5ef3a27ced78f69deb41ab35ad5","date":1446841099,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","sourceNew":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      // reset lastDataDir for triggering full #init()\n      lastDataDir = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n\n      // Close and clear logs\n      for (TransactionLog log : logs) {\n        log.deleteOnClose = false;\n        log.decref();\n        log.forceClose();\n      }\n      logs.clear();\n\n      // reset lastDataDir for #init()\n      lastDataDir = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1","date":1448389841,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#resetForRecovery().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","sourceNew":"  /**\n   * expert: Reset the update log before initialisation. This is called by\n   * {@link org.apache.solr.handler.IndexFetcher#moveTlogFiles(File)} during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   * @see #initForRecovery(File, long)\n   */\n  public BufferedUpdates resetForRecovery() {\n    synchronized (this) { // since we blocked updates in IndexFetcher, this synchronization shouldn't strictly be necessary.\n      // If we are buffering, we need to return the related information to the index fetcher\n      // for properly initialising the new update log - SOLR-8263\n      BufferedUpdates bufferedUpdates = new BufferedUpdates();\n      if (state == State.BUFFERING && tlog != null) {\n        bufferedUpdates.tlog = tlog.tlogFile; // file to keep\n        bufferedUpdates.offset = this.recoveryInfo.positionOfStart;\n      }\n\n      // Close readers\n      for (CdcrLogReader reader : logPointers.keySet()) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      tlogFiles = null;\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      return bufferedUpdates;\n    }\n  }\n\n","sourceOld":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      // reset lastDataDir for triggering full #init()\n      lastDataDir = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfa6bab72dc1ef7209657e6685f9204e2e49bac8","date":1448391014,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#resetForRecovery().mjava","sourceNew":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      // reset lastDataDir for triggering full #init()\n      lastDataDir = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * expert: Reset the update log before initialisation. This is called by\n   * {@link org.apache.solr.handler.IndexFetcher#moveTlogFiles(File)} during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   * @see #initForRecovery(File, long)\n   */\n  public BufferedUpdates resetForRecovery() {\n    synchronized (this) { // since we blocked updates in IndexFetcher, this synchronization shouldn't strictly be necessary.\n      // If we are buffering, we need to return the related information to the index fetcher\n      // for properly initialising the new update log - SOLR-8263\n      BufferedUpdates bufferedUpdates = new BufferedUpdates();\n      if (state == State.BUFFERING && tlog != null) {\n        bufferedUpdates.tlog = tlog.tlogFile; // file to keep\n        bufferedUpdates.offset = this.recoveryInfo.positionOfStart;\n      }\n\n      // Close readers\n      for (CdcrLogReader reader : logPointers.keySet()) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      tlogFiles = null;\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      return bufferedUpdates;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cae179618908dcb534af567cdf3019505ada6c","date":1449365361,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#resetForRecovery().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#reset().mjava","sourceNew":"  /**\n   * expert: Reset the update log before initialisation. This is called by\n   * {@link org.apache.solr.handler.IndexFetcher#moveTlogFiles(File)} during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   * @see #initForRecovery(File, long)\n   */\n  public BufferedUpdates resetForRecovery() {\n    synchronized (this) { // since we blocked updates in IndexFetcher, this synchronization shouldn't strictly be necessary.\n      // If we are buffering, we need to return the related information to the index fetcher\n      // for properly initialising the new update log - SOLR-8263\n      BufferedUpdates bufferedUpdates = new BufferedUpdates();\n      if (state == State.BUFFERING && tlog != null) {\n        bufferedUpdates.tlog = tlog.tlogFile; // file to keep\n        bufferedUpdates.offset = this.recoveryInfo.positionOfStart;\n      }\n\n      // Close readers\n      for (CdcrLogReader reader : logPointers.keySet()) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      tlogFiles = null;\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      return bufferedUpdates;\n    }\n  }\n\n","sourceOld":"  /**\n   * expert: Reset the update log before initialisation. This is needed by the IndexFetcher during a\n   * a Recovery operation in order to re-initialise the UpdateLog with a new set of tlog files.\n   */\n  public void reset() {\n    synchronized (this) {\n      // Close readers\n      for (CdcrLogReader reader : new ArrayList<>(logPointers.keySet())) {\n        reader.close();\n      }\n      logPointers.clear();\n\n      // Close and clear logs\n      doClose(prevTlog);\n      doClose(tlog);\n\n      for (TransactionLog log : logs) {\n        if (log == prevTlog || log == tlog) continue;\n        doClose(log);\n      }\n\n      logs.clear();\n      newestLogsOnStartup.clear();\n      tlog = prevTlog = null;\n      prevMapLog = prevMapLog2 = null;\n\n      map.clear();\n      if (prevMap != null) prevMap.clear();\n      if (prevMap2 != null) prevMap2.clear();\n\n      numOldRecords = 0;\n\n      oldDeletes.clear();\n      deleteByQueries.clear();\n\n      // reset lastDataDir for triggering full #init()\n      lastDataDir = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"77cae179618908dcb534af567cdf3019505ada6c":["cfa6bab72dc1ef7209657e6685f9204e2e49bac8"],"e586ff50ac71d5ef3a27ced78f69deb41ab35ad5":["7f4241c44998effab9382acfd7f0b042f3fe9c25"],"7f4241c44998effab9382acfd7f0b042f3fe9c25":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cfa6bab72dc1ef7209657e6685f9204e2e49bac8":["6776c9bdacef00ce712b87d1c8e999ae61c1c6a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1":["e586ff50ac71d5ef3a27ced78f69deb41ab35ad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["77cae179618908dcb534af567cdf3019505ada6c"]},"commit2Childs":{"77cae179618908dcb534af567cdf3019505ada6c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e586ff50ac71d5ef3a27ced78f69deb41ab35ad5":["6776c9bdacef00ce712b87d1c8e999ae61c1c6a1"],"7f4241c44998effab9382acfd7f0b042f3fe9c25":["e586ff50ac71d5ef3a27ced78f69deb41ab35ad5"],"cfa6bab72dc1ef7209657e6685f9204e2e49bac8":["77cae179618908dcb534af567cdf3019505ada6c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7f4241c44998effab9382acfd7f0b042f3fe9c25"],"6776c9bdacef00ce712b87d1c8e999ae61c1c6a1":["cfa6bab72dc1ef7209657e6685f9204e2e49bac8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}