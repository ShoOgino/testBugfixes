{"path":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","commits":[{"id":"4485732f2b76c4d25f5b4d6d48bc1b5204817e8e","date":1340876809,"type":0,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["437e65c578cab603d9201916b0e285f3d68aff45"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae81ef60a860c551619f7702a13ba15f7dc024f5","date":1341796635,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<Pattern,String>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, IOUtils.CHARSET_UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"437e65c578cab603d9201916b0e285f3d68aff45","date":1427831677,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":["4485732f2b76c4d25f5b4d6d48bc1b5204817e8e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","pathOld":"solr/contrib/extraction/src/java/org/apache/solr/handler/extraction/RegexRulesPasswordProvider#parseRulesFile(InputStream).mjava","sourceNew":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line {}\", linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line {} was not a valid regex pattern{}\", linenum, pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return rules;\n  }\n\n","sourceOld":"  /**\n   * Parses rule file from stream and returns a Map of all rules found\n   * @param is input stream for the file\n   */\n  public static LinkedHashMap<Pattern,String> parseRulesFile(InputStream is) {\n    LinkedHashMap<Pattern,String> rules = new LinkedHashMap<>();\n    BufferedReader br = new BufferedReader(IOUtils.getDecodingReader(is, StandardCharsets.UTF_8));\n    String line;\n    try {\n      int linenum = 0;\n      while ((line = br.readLine()) != null)   {\n        linenum++;\n        // Remove comments\n        String[] arr = line.split(\"#\");\n        if(arr.length > 0)\n          line = arr[0].trim();\n        if(line.length() == 0) \n          continue;\n        int sep = line.indexOf(\"=\");\n        if(sep <= 0) {\n          log.warn(\"Wrong format of password line \"+linenum);\n          continue;\n        }\n        String pass = line.substring(sep+1).trim();\n        String regex = line.substring(0, sep).trim();\n        try {\n          Pattern pattern = Pattern.compile(regex);\n          rules.put(pattern,  pass);\n        } catch(PatternSyntaxException pse) {\n          log.warn(\"Key of line \"+linenum+\" was not a valid regex pattern\", pse);\n          continue;\n        }\n      }\n      is.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return rules;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","7d89d7e4e5101347833eea558851bf4209218619"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2acf500f78aa12b92e371fd89c719291986b6b90"],"ae81ef60a860c551619f7702a13ba15f7dc024f5":["4485732f2b76c4d25f5b4d6d48bc1b5204817e8e"],"437e65c578cab603d9201916b0e285f3d68aff45":["7d89d7e4e5101347833eea558851bf4209218619"],"2acf500f78aa12b92e371fd89c719291986b6b90":["4485732f2b76c4d25f5b4d6d48bc1b5204817e8e","ae81ef60a860c551619f7702a13ba15f7dc024f5"],"7d89d7e4e5101347833eea558851bf4209218619":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4485732f2b76c4d25f5b4d6d48bc1b5204817e8e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["437e65c578cab603d9201916b0e285f3d68aff45"],"46d8ada1fff8d18cb197c38c7983225162599948":["4485732f2b76c4d25f5b4d6d48bc1b5204817e8e","2acf500f78aa12b92e371fd89c719291986b6b90"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fab172655716b96f7e42376116235017a922de3a":["7d89d7e4e5101347833eea558851bf4209218619","437e65c578cab603d9201916b0e285f3d68aff45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","7d89d7e4e5101347833eea558851bf4209218619"],"ae81ef60a860c551619f7702a13ba15f7dc024f5":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"437e65c578cab603d9201916b0e285f3d68aff45":["a966532d92cf9ba2856f15a8140151bb6b518e4b","fab172655716b96f7e42376116235017a922de3a"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","437e65c578cab603d9201916b0e285f3d68aff45","fab172655716b96f7e42376116235017a922de3a"],"4485732f2b76c4d25f5b4d6d48bc1b5204817e8e":["ae81ef60a860c551619f7702a13ba15f7dc024f5","2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4485732f2b76c4d25f5b4d6d48bc1b5204817e8e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fab172655716b96f7e42376116235017a922de3a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}