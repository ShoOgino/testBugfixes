{"path":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","commits":[{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object,float).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE))\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown value for enum field: \" + value.toString());\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value, float boost) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE))\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown value for enum field: \" + value.toString());\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    final org.apache.lucene.document.Field f;\n    f = new LegacyIntField(field.getName(), intValue.intValue(), newType);\n\n    f.setBoost(boost);\n    return f;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cb1fb4983bd6e9cea17d30e53d10d4c21629f22","date":1500036900,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE))\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown value for enum field: \" + value.toString());\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE))\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown value for enum field: \" + value.toString());\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ad8c9e9210e008dc7b8ad5a037ff20879150ea","date":1501889566,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","sourceNew":"  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = enumMapping.stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(EnumMapping.DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","sourceNew":"  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = enumMapping.stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(EnumMapping.DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/EnumField#createField(SchemaField,Object).mjava","sourceNew":"  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: {}\", field);\n      return null;\n    }\n    final Integer intValue = enumMapping.stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(EnumMapping.DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","sourceOld":"  @Override\n  public IndexableField createField(SchemaField field, Object value) {\n    final boolean indexed = field.indexed();\n    final boolean stored = field.stored();\n    final boolean docValues = field.hasDocValues();\n\n    if (!indexed && !stored && !docValues) {\n      if (log.isTraceEnabled())\n        log.trace(\"Ignoring unindexed/unstored field: \" + field);\n      return null;\n    }\n    final Integer intValue = enumMapping.stringValueToIntValue(value.toString());\n    if (intValue == null || intValue.equals(EnumMapping.DEFAULT_VALUE)) {\n      String exceptionMessage = String.format(Locale.ENGLISH, \"Unknown value for enum field: %s, value: %s\",\n          field.getName(), value.toString());\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  exceptionMessage);\n    }\n\n    final LegacyFieldType newType = new LegacyFieldType();\n\n    newType.setTokenized(field.isTokenized());\n    newType.setStored(field.stored());\n    newType.setOmitNorms(field.omitNorms());\n    newType.setIndexOptions(field.indexOptions());\n    newType.setStoreTermVectors(field.storeTermVector());\n    newType.setStoreTermVectorOffsets(field.storeTermOffsets());\n    newType.setStoreTermVectorPositions(field.storeTermPositions());\n    newType.setStoreTermVectorPayloads(field.storeTermPayloads());\n    newType.setNumericType(LegacyNumericType.INT);\n    newType.setNumericPrecisionStep(DEFAULT_PRECISION_STEP);\n\n    return new LegacyIntField(field.getName(), intValue.intValue(), newType);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["aaf90fc29510e72665ac7934f34c3d1c25efad64","54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["acd9883560fd89e6448b2b447302fe543040cd4f","1cb1fb4983bd6e9cea17d30e53d10d4c21629f22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1cb1fb4983bd6e9cea17d30e53d10d4c21629f22":["acd9883560fd89e6448b2b447302fe543040cd4f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["1cb1fb4983bd6e9cea17d30e53d10d4c21629f22"],"acd9883560fd89e6448b2b447302fe543040cd4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["acd9883560fd89e6448b2b447302fe543040cd4f"],"1cb1fb4983bd6e9cea17d30e53d10d4c21629f22":["aaf90fc29510e72665ac7934f34c3d1c25efad64","54ad8c9e9210e008dc7b8ad5a037ff20879150ea"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54ad8c9e9210e008dc7b8ad5a037ff20879150ea":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","575e66bd4b2349209027f6801184da7fc3cba13f"],"acd9883560fd89e6448b2b447302fe543040cd4f":["aaf90fc29510e72665ac7934f34c3d1c25efad64","1cb1fb4983bd6e9cea17d30e53d10d4c21629f22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}