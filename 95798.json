{"path":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexWriter#finish(int,long).mjava","commits":[{"id":"70a4487b07c49a1861c05720e04624826ecbe9fa","date":1580924108,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexWriter#finish(int,long).mjava","pathOld":"/dev/null","sourceNew":"  void finish(int numDocs, long maxPointer) throws IOException {\n    if (numDocs != totalDocs) {\n      throw new IllegalStateException(\"Expected \" + numDocs + \" docs, but got \" + totalDocs);\n    }\n    CodecUtil.writeFooter(docsOut);\n    CodecUtil.writeFooter(filePointersOut);\n    IOUtils.close(docsOut, filePointersOut);\n\n    try (IndexOutput metaOut = dir.createOutput(IndexFileNames.segmentFileName(name, suffix, extension + FIELDS_META_EXTENSION_SUFFIX), ioContext);\n        IndexOutput dataOut = dir.createOutput(IndexFileNames.segmentFileName(name, suffix, extension + FIELDS_INDEX_EXTENSION_SUFFIX), ioContext)) {\n\n      CodecUtil.writeIndexHeader(metaOut, codecName + \"Meta\", VERSION_CURRENT, id, suffix);\n      CodecUtil.writeIndexHeader(dataOut, codecName + \"Idx\", VERSION_CURRENT, id, suffix);\n\n      metaOut.writeInt(numDocs);\n      metaOut.writeInt(blockShift);\n      metaOut.writeInt(totalChunks + 1);\n      metaOut.writeLong(dataOut.getFilePointer());\n\n      try (ChecksumIndexInput docsIn = dir.openChecksumInput(docsOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(docsIn, codecName + \"Docs\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter docs = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long doc = 0;\n          docs.add(doc);\n          for (int i = 0; i < totalChunks; ++i) {\n            doc += docsIn.readVInt();\n            docs.add(doc);\n          }\n          docs.finish();\n          if (doc != totalDocs) {\n            throw new CorruptIndexException(\"Docs don't add up\", docsIn);\n          }\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(docsIn, priorE);\n        }\n      }\n      dir.deleteFile(docsOut.getName());\n      docsOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      try (ChecksumIndexInput filePointersIn = dir.openChecksumInput(filePointersOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(filePointersIn, codecName + \"FilePointers\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter filePointers = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long fp = 0;\n          for (int i = 0; i < totalChunks; ++i) {\n            fp += filePointersIn.readVLong();\n            filePointers.add(fp);\n          }\n          if (maxPointer < fp) {\n            throw new CorruptIndexException(\"File pointers don't add up\", filePointersIn);\n          }\n          filePointers.add(maxPointer);\n          filePointers.finish();\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(filePointersIn, priorE);\n        }\n      }\n      dir.deleteFile(filePointersOut.getName());\n      filePointersOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      metaOut.writeLong(maxPointer);\n\n      CodecUtil.writeFooter(metaOut);\n      CodecUtil.writeFooter(dataOut);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b78d8dfe50af510bace3600bfc4cfa0b031f776","date":1598430423,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexWriter#finish(int,long,IndexOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/compressing/FieldsIndexWriter#finish(int,long).mjava","sourceNew":"  void finish(int numDocs, long maxPointer, IndexOutput metaOut) throws IOException {\n    if (numDocs != totalDocs) {\n      throw new IllegalStateException(\"Expected \" + numDocs + \" docs, but got \" + totalDocs);\n    }\n    CodecUtil.writeFooter(docsOut);\n    CodecUtil.writeFooter(filePointersOut);\n    IOUtils.close(docsOut, filePointersOut);\n\n    try (IndexOutput dataOut = dir.createOutput(IndexFileNames.segmentFileName(name, suffix, extension), ioContext)) {\n      CodecUtil.writeIndexHeader(dataOut, codecName + \"Idx\", VERSION_CURRENT, id, suffix);\n\n      metaOut.writeInt(numDocs);\n      metaOut.writeInt(blockShift);\n      metaOut.writeInt(totalChunks + 1);\n      metaOut.writeLong(dataOut.getFilePointer());\n\n      try (ChecksumIndexInput docsIn = dir.openChecksumInput(docsOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(docsIn, codecName + \"Docs\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter docs = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long doc = 0;\n          docs.add(doc);\n          for (int i = 0; i < totalChunks; ++i) {\n            doc += docsIn.readVInt();\n            docs.add(doc);\n          }\n          docs.finish();\n          if (doc != totalDocs) {\n            throw new CorruptIndexException(\"Docs don't add up\", docsIn);\n          }\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(docsIn, priorE);\n        }\n      }\n      dir.deleteFile(docsOut.getName());\n      docsOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      try (ChecksumIndexInput filePointersIn = dir.openChecksumInput(filePointersOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(filePointersIn, codecName + \"FilePointers\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter filePointers = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long fp = 0;\n          for (int i = 0; i < totalChunks; ++i) {\n            fp += filePointersIn.readVLong();\n            filePointers.add(fp);\n          }\n          if (maxPointer < fp) {\n            throw new CorruptIndexException(\"File pointers don't add up\", filePointersIn);\n          }\n          filePointers.add(maxPointer);\n          filePointers.finish();\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(filePointersIn, priorE);\n        }\n      }\n      dir.deleteFile(filePointersOut.getName());\n      filePointersOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      metaOut.writeLong(maxPointer);\n\n      CodecUtil.writeFooter(dataOut);\n    }\n  }\n\n","sourceOld":"  void finish(int numDocs, long maxPointer) throws IOException {\n    if (numDocs != totalDocs) {\n      throw new IllegalStateException(\"Expected \" + numDocs + \" docs, but got \" + totalDocs);\n    }\n    CodecUtil.writeFooter(docsOut);\n    CodecUtil.writeFooter(filePointersOut);\n    IOUtils.close(docsOut, filePointersOut);\n\n    try (IndexOutput metaOut = dir.createOutput(IndexFileNames.segmentFileName(name, suffix, extension + FIELDS_META_EXTENSION_SUFFIX), ioContext);\n        IndexOutput dataOut = dir.createOutput(IndexFileNames.segmentFileName(name, suffix, extension + FIELDS_INDEX_EXTENSION_SUFFIX), ioContext)) {\n\n      CodecUtil.writeIndexHeader(metaOut, codecName + \"Meta\", VERSION_CURRENT, id, suffix);\n      CodecUtil.writeIndexHeader(dataOut, codecName + \"Idx\", VERSION_CURRENT, id, suffix);\n\n      metaOut.writeInt(numDocs);\n      metaOut.writeInt(blockShift);\n      metaOut.writeInt(totalChunks + 1);\n      metaOut.writeLong(dataOut.getFilePointer());\n\n      try (ChecksumIndexInput docsIn = dir.openChecksumInput(docsOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(docsIn, codecName + \"Docs\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter docs = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long doc = 0;\n          docs.add(doc);\n          for (int i = 0; i < totalChunks; ++i) {\n            doc += docsIn.readVInt();\n            docs.add(doc);\n          }\n          docs.finish();\n          if (doc != totalDocs) {\n            throw new CorruptIndexException(\"Docs don't add up\", docsIn);\n          }\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(docsIn, priorE);\n        }\n      }\n      dir.deleteFile(docsOut.getName());\n      docsOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      try (ChecksumIndexInput filePointersIn = dir.openChecksumInput(filePointersOut.getName(), IOContext.READONCE)) {\n        CodecUtil.checkHeader(filePointersIn, codecName + \"FilePointers\", VERSION_CURRENT, VERSION_CURRENT);\n        Throwable priorE = null;\n        try {\n          final DirectMonotonicWriter filePointers = DirectMonotonicWriter.getInstance(metaOut, dataOut, totalChunks + 1, blockShift);\n          long fp = 0;\n          for (int i = 0; i < totalChunks; ++i) {\n            fp += filePointersIn.readVLong();\n            filePointers.add(fp);\n          }\n          if (maxPointer < fp) {\n            throw new CorruptIndexException(\"File pointers don't add up\", filePointersIn);\n          }\n          filePointers.add(maxPointer);\n          filePointers.finish();\n        } catch (Throwable e) {\n          priorE = e;\n        } finally {\n          CodecUtil.checkFooter(filePointersIn, priorE);\n        }\n      }\n      dir.deleteFile(filePointersOut.getName());\n      filePointersOut = null;\n\n      metaOut.writeLong(dataOut.getFilePointer());\n      metaOut.writeLong(maxPointer);\n\n      CodecUtil.writeFooter(metaOut);\n      CodecUtil.writeFooter(dataOut);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2b78d8dfe50af510bace3600bfc4cfa0b031f776":["70a4487b07c49a1861c05720e04624826ecbe9fa"],"70a4487b07c49a1861c05720e04624826ecbe9fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b78d8dfe50af510bace3600bfc4cfa0b031f776"]},"commit2Childs":{"2b78d8dfe50af510bace3600bfc4cfa0b031f776":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70a4487b07c49a1861c05720e04624826ecbe9fa":["2b78d8dfe50af510bace3600bfc4cfa0b031f776"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70a4487b07c49a1861c05720e04624826ecbe9fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}