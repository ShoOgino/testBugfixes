{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","commits":[{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normType) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n\n        if (!fi.omitsNorms() && normType != null) {\n          fi.setNormValueType(normType);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,boolean,IndexOptions,DocValuesType).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,\n        boolean storeTermVector,\n        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues) {\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues);\n        fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, null);\n        assert !byName.containsKey(fi.name);\n        assert globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);\n\n        if (docValues != null) {\n          // only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = !fi.hasDocValues();\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          if (updateGlobal) {\n            // must also update docValuesType map so it's\n            // aware of this field's DocValueType \n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","05da2d758a6089e737cdfc230e57a51b472b94b6"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3184874f7f3aca850248483485b4995343066875":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3184874f7f3aca850248483485b4995343066875"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"3184874f7f3aca850248483485b4995343066875":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}